<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Parking Rush с эффектом аннигиляции</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #000;
      touch-action: none;
    }
    #game-container {
      position: relative;
      display: block;
      max-width: 100%;
      max-height: 100%;
    }
    .debug-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      font-family: monospace;
      z-index: 100;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>
  
	// Константы границ мира
	const WORLD_BOUNDS = {
	  left: 0,
	  right: 800,
	  top: 0,
	  bottom: 800,
	  padding: 75 // Зона предварительного торможения
	};
  
    // Конфигурация NPC
    const npcSpeed = 80;
    const npcParkingSpeed = 30;
    const npcFinalApproachSpeed = 40;
    const npcExitSpeed = 20;
    const REVERSE_SPEED = 40;
    const MAX_REVERSE_TIME = 1;
    const REVERSE_CHECK_DELAY = 5000;
    const MAX_REVERSE_ATTEMPTS = 3;
    const SCENE_BOUNDS_PADDING = 50;
    const COLLISION_WAIT_TIME = 1700;
    const NO_REVERSE_WAIT_TIME = 2000;
    const PARKING_START_POINTS = 1;
    const PARKING_END_POINTS = 2;
    const FINAL_APPROACH_POINTS = 3;
    const EXIT_PHASE_POINTS = 3;
    const PARKING_EXIT_DELAY = 3000;
    const NPC_PER_ROW = 5;
    const MAX_NPC_PER_ROW = 5;
    const ROWS_COUNT = 8;
    const MAX_COLLISION_CHECKS = 3;

    // Конфигурация сенсоров
    const npcSensors = {
      front: { width: 27, height: 20, offset: 27, angle: 0 },
      frontLeft: { width: 0, height: 0, offset: 0, angle: Math.PI/4 },
      frontRight: { width: 0, height: 0, offset: 0, angle: -Math.PI/4 },
      left: { width: 0, height: 0, offset: 0, angle: Math.PI/2 },
      right: { width: 0, height: 0, offset: 0, angle: -Math.PI/2 },
      debugColor: 0xff0000,
      debugAlpha: 0.55
    };

    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 800,
      parent: 'game-container',
      scene: {
        preload: preload,
        create: create,
        update: update
      },
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 },
          debug: false
        }
      },
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
      }
    };

    const game = new Phaser.Game(config);
    let npcs = [];
    let lastExitTime = 0;
    let exitQueue = [];
    let debugGraphics;
    let showDebug = false;
    let showCollisionHighlights = true;
    let gameArea;
    let background;
    let decorativeLayer;
    
    // Новые переменные для системы камеры
    let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    let cameraTarget;
    let currentTarget;
    let mapWidth = 1600;
    let mapHeight = 1600;
    
    // Парковочные места
    const upperLeftParkingSpots = [
      { x: 361, y: 380 }, { x: 454, y: 380 }, { x: 546, y: 380 }, { x: 641, y: 380 }, { x: 729, y: 380 }, { x: 823, y: 380 },
      { x: 361, y: 674 }, { x: 454, y: 674 }, { x: 546, y: 674 }, { x: 641, y: 674 }, { x: 729, y: 674 }, { x: 823, y: 674 },
      { x: 361, y: 1130 }, { x: 454, y: 1130 }, { x: 546, y: 1130 }, { x: 641, y: 1130 }, { x: 729, y: 1130 }, { x: 823, y: 1130 },
      { x: 361, y: 1420 }, { x: 454, y: 1420 }, { x: 546, y: 1420 }, { x: 641, y: 1420 }, { x: 729, y: 1420 }, { x: 823, y: 1420 }  
    ];
    
    const upperRightParkingSpots = [
      { x: 1094, y: 380 }, { x: 1189, y: 380 }, { x: 1279, y: 380 }, { x: 1371, y: 380 }, { x: 1462, y: 380 }, { x: 1555, y: 380 },
      { x: 1094, y: 674 }, { x: 1189, y: 674 }, { x: 1279, y: 674 }, { x: 1371, y: 674 }, { x: 1462, y: 674 }, { x: 1555, y: 674 },
      { x: 1094, y: 1130 }, { x: 1189, y: 1130 }, { x: 1279, y: 1130 }, { x: 1371, y: 1130 }, { x: 1462, y: 1130 }, { x: 1555, y: 1130 },
      { x: 1094, y: 1420 }, { x: 1189, y: 1420 }, { x: 1279, y: 1420 }, { x: 1371, y: 1420 }, { x: 1462, y: 1420 }, { x: 1555, y: 1420 }
    ];
    
    const allParkingSpots = [...upperLeftParkingSpots, ...upperRightParkingSpots];

    const npcOffset = 20;

    // Маршруты движения
    const allPossibleRoutes = [
      function clockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 690 - npcOffset, y: y - 37 }, { x: 690 - npcOffset, y: 665 - npcOffset },
          { x: 110 + npcOffset, y: 665 - npcOffset }, { x: 110 + npcOffset, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      function counterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 82 + npcOffset, y: y - 62 }, { x: 82 + npcOffset, y: 710 - npcOffset },
          { x: 725 - npcOffset, y: 710 - npcOffset }, { x: 725 - npcOffset, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      function leftBigHalfCounterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 82 + npcOffset, y: y - 62 }, { x: 82 + npcOffset, y: 710 - npcOffset },
          { x: 399, y: 710 - npcOffset }, { x: 399, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      function rightHalfClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 690 - npcOffset, y: y - 37 }, { x: 690 - npcOffset, y: 665 - npcOffset },
          { x: 420, y: 665 - npcOffset }, { x: 420, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      }
    ];

    function getRandomCarTexture() {
      const models = ['sedan', 'suv', 'hatchback', 'coupe', 'van'];
      const colors = ['red', 'blue', 'green', 'yellow', 'black'];
      return `car_${Phaser.Math.RND.pick(models)}_${Phaser.Math.RND.pick(colors)}`;
    }

    function scaleCoords(x, y, isRoad = false) {
      const parkingSpotWidth = 59;
      const parkingSpotHeight = 85;
      const scaleFactor = 0.4;
      const offsetX = (parkingSpotWidth / 2) * scaleFactor;
      const offsetY = (parkingSpotHeight / 2) * scaleFactor;
      const roadOffsetX = -12;
      const roadOffsetY = -16;
      
      const scaledX = (x / 2000) * 800 + offsetX;
      const scaledY = (y / 2000) * 800 + offsetY;
      if (isRoad) return { x: scaledX + roadOffsetX, y: scaledY + roadOffsetY };
      return { x: scaledX, y: scaledY };
    }

    function createShuffledRouteSequence() {
      const routes = [...allPossibleRoutes];
      for (let i = routes.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [routes[i], routes[j]] = [routes[j], routes[i]];
      }
      return routes;
    }

    function getRandomSpotsInRow(row, count) {
      const spotsToSelect = Math.min(count, MAX_NPC_PER_ROW, row.length);
      const shuffled = [...row].sort(() => 0.5 - Math.random());
      return shuffled.slice(0, spotsToSelect);
    }

    function createGameArea(scene) {
      const gameArea = scene.add.container();
      
      const roads = [
        { x: 3 + 252/2, y: 893 + 216/2, width: 252, height: 216 },
        { x: 237 + 104/2, y: 236 + 1529/2, width: 140, height: 1529 },
        { x: 1618 + 32 + 120/2, y: 237 + 1526/2, width: 120 + 64, height: 1526 },
        { x: 257 + 1485/2, y: 234 + 143/2, width: 1485, height: 143 },
        { x: 259 + 1479/2, y: 1622 - 40 + 141/2, width: 1479, height: 221 },
        { x: 257 + 1482/2, y: 872 - 40 + 252/2, width: 1482, height: 332 },
        { x: 887 + 203/2, y: 236 + 1528/2, width: 203, height: 1528 },
        { x: 259 + 1477/2, y: 579 - 42 + 94/2, width: 1477, height: 94 + 84 },
        { x: 259 + 1477/2, y: 1326 - 42 + 94/2, width: 1477, height: 94 + 84 }
      ];

      roads.forEach(road => {
        const { x, y } = scaleCoords(road.x, road.y, true);
        const roadRect = scene.add.rectangle(
          x, y,
          road.width * 0.4,
          road.height * 0.4,
          0x333333, 
          0.0
        ).setOrigin(0.5);
        
        scene.physics.add.existing(roadRect, true);
        gameArea.add(roadRect);
      });

      allParkingSpots.forEach(spot => {
        const { x, y } = scaleCoords(spot.x, spot.y);
        const parkingSpot = scene.add.rectangle(
          x, y,
          59 * 0.4,
          85 * 0.4,
          0x555555,
          0.0
        ).setOrigin(0.5);
        
        scene.physics.add.existing(parkingSpot, true);
        gameArea.add(parkingSpot);
      });

      return gameArea;
    }

    function isOutOfBounds(npc) {
      let outOfBounds = true;
      gameArea.each(child => {
        if (Phaser.Geom.Intersects.RectangleToRectangle(
          npc.getBounds(),
          child.getBounds()
        )) {
          outOfBounds = false;
        }
      });
      return outOfBounds;
    }

    function returnToSafePosition(npc) {
      let safeIndex = npc.routeIndex;
      while (safeIndex >= 0) {
        const point = npc.route[safeIndex];
        if (!isOutOfBounds({x: point.x, y: point.y, getBounds: () => new Phaser.Geom.Rectangle(point.x-5, point.y-5, 10, 10)})) {
          break;
        }
        safeIndex--;
      }
      
      if (safeIndex >= 0) {
        npc.routeIndex = safeIndex;
        npc.x = npc.route[safeIndex].x;
        npc.y = npc.route[safeIndex].y;
        npc.setVelocity(0, 0);
        npc.isReversing = false;
        npc.isWaiting = false;
        moveNPCToNextPoint(npc);
      } else {
        const {x, y} = scaleCoords(npc.originalSpot.x, npc.originalSpot.y);
        npc.x = x;
        npc.y = y;
        npc.routeIndex = 0;
        npc.setVelocity(0, 0);
        npc.isReversing = false;
        npc.isWaiting = true;
        npc.scene.time.delayedCall(2000, () => {
          npc.isWaiting = false;
          moveNPCToNextPoint(npc);
        });
      }
    }

    function createSensors(scene, npc) {
      if (npc.sensors) {
        Object.values(npc.sensors).forEach(sensor => sensor.destroy());
      }

      const sensorDepth = npc.depth + 1;

      npc.sensors = {
        front: createSensorRect(scene, npcSensors.front)
          .setDepth(sensorDepth)
          .setVisible(false),
        frontLeft: createSensorRect(scene, npcSensors.frontLeft)
          .setDepth(sensorDepth)
          .setVisible(false),
        frontRight: createSensorRect(scene, npcSensors.frontRight)
          .setDepth(sensorDepth)
          .setVisible(false),
        left: createSensorRect(scene, npcSensors.left)
          .setDepth(sensorDepth)
          .setVisible(false),
        right: createSensorRect(scene, npcSensors.right)
          .setDepth(sensorDepth)
          .setVisible(false)
      };

      if (showDebug) {
        npc.sensors.front.setFillStyle(0xFF0000);
        npc.sensors.frontLeft.setFillStyle(0x00FF00);
        npc.sensors.frontRight.setFillStyle(0x0000FF);
        npc.sensors.left.setFillStyle(0xFFFF00);
        npc.sensors.right.setFillStyle(0xFF00FF);
      }
    }

    function createSensorRect(scene, config) {
      return scene.add.rectangle(
        0, 0, 
        config.width, 
        config.height, 
        npcSensors.debugColor, 
        npcSensors.debugAlpha
      );
    }

    function updateSensors(npc) {
      if (!npc.sensors || npc.routeIndex < PARKING_START_POINTS || 
          npc.routeIndex > npc.route.length - (PARKING_END_POINTS + 1)) {
        return;
      }

      const rotation = npc.rotation - Math.PI/2;
      
      Object.keys(npc.sensors).forEach(key => {
        const sensor = npc.sensors[key];
        const config = npcSensors[key];
        
        sensor.x = npc.x + Math.cos(rotation + config.angle) * config.offset;
        sensor.y = npc.y + Math.sin(rotation + config.angle) * config.offset;
        sensor.rotation = rotation + config.angle;
        sensor.visible = showDebug && !npc.isReversing;
      });
    }

    function checkSensors(npc) {
      if (!npc.sensors || 
          npc.routeIndex < PARKING_START_POINTS || 
          npc.routeIndex > npc.route.length - (PARKING_END_POINTS + 1) ||
          npc.isReversing) {
        return [];
      }

      const collisions = [];
      const otherNpcs = npcs.filter(n => n !== npc && n.active);
      
      otherNpcs.forEach(other => {
        Object.entries(npc.sensors).forEach(([sensorName, sensor]) => {
          if (Phaser.Geom.Intersects.RectangleToRectangle(
            sensor.getBounds(),
            other.getBounds()
          )) {
            collisions.push({
              npc: other,
              sensor: sensorName,
              distance: Phaser.Math.Distance.Between(npc.x, npc.y, other.x, other.y)
            });

            if (sensorName === 'front' && !npc.isWaiting) {
              handleFrontCollision(npc, {npc: other, sensor: 'front'});
            }
          }
        });
      });
      
      return collisions;
    }

	function handleFrontCollision(npc, collision) {
	  // 1. Проверка входных параметров
	  if (!npc || !npc.scene || !npc.body || !collision || !collision.npc) {
		console.warn("Invalid collision data:", { npc, collision });
		return;
	  }

	  // 2. Проверка состояний NPC
	  if (npc.isWaiting || npc.isReversing || npc.isAvoiding || npc.isExiting) {
		if (showDebug) {
		  console.debug(`NPC ${npc.texture?.key || 'unknown'} ignored collision due to state`, {
			waiting: npc.isWaiting,
			reversing: npc.isReversing,
			avoiding: npc.isAvoiding,
			exiting: npc.isExiting
		  });
		}
		return;
	  }

	  // 3. Сохранение состояния перед столкновением
	  npc.preCollisionSpeed = npc.body.velocity.clone();
	  npc.setVelocity(0, 0);
	  npc.isWaiting = true;
	  npc.collisionCheckAttempts = 0;
	  npc.otherNpc = collision.npc;

	  // 4. Логирование для отладки
	  if (showDebug) {
		console.debug(`Collision detected between ${
		  npc.texture?.key || 'unknown'
		} and ${
		  collision.npc.texture?.key || 'unknown'
		} at ${npc.x.toFixed(1)},${npc.y.toFixed(1)}`);
	  }

	  // 5. Настройка отложенной повторной проверки
	  const delay = Phaser.Math.Between(
		COLLISION_WAIT_TIME * 0.9, 
		COLLISION_WAIT_TIME * 1.1
	  );

	  npc.scene.time.delayedCall(delay, () => {
		if (npc.active && npc.body && !npc.isDestroyed) {
		  recheckCollision(npc);
		} else if (showDebug) {
		  console.debug("Skipped recheck for destroyed NPC");
		}
	  });

	  // 6. Визуализация столкновения (в режиме отладки)
	  if (showDebug && showCollisionHighlights) {
		// Очистка предыдущей графики
		if (npc.collisionDebug) {
		  npc.collisionDebug.destroy();
		}
		
		// Создание временного графического объекта
		npc.collisionDebug = npc.scene.add.graphics()
		  .fillStyle(0xFF0000, 0.5)
		  .fillCircle(npc.x, npc.y, 15)
		  .setDepth(100)
		  .lineStyle(2, 0xFFFFFF)
		  .strokeCircle(npc.x, npc.y, 20);
		
		// Автоматическое удаление через 1 секунду
		npc.scene.time.delayedCall(1000, () => {
		  if (npc.collisionDebug && !npc.collisionDebug.destroyed) {
			npc.collisionDebug.destroy();
		  }
		});
	  }
	}
	
	function recheckCollision(npc) {
		// 1. Проверка валидности NPC
		if (!npc || !npc.scene || !npc.active || npc.isDestroyed) {
			console.warn('Recheck skipped: invalid NPC');
			return;
		}

		// 2. Увеличение счетчика попыток
		npc.collisionCheckAttempts = (npc.collisionCheckAttempts || 0) + 1;

		// 3. Проверка текущих столкновений
		const newCollisions = checkSensors(npc);
		const stillBlocked = newCollisions.some(c => 
			c.npc && c.npc.active && c.npc === npc.otherNpc
		);

		// 4. Логирование для отладки
		if (showDebug) {
			console.debug(`Recheck ${npc.collisionCheckAttempts}/${MAX_COLLISION_CHECKS} for ${
				npc.texture?.key || 'unknown'
			} - blocked: ${stillBlocked}`);
		}

		// 5. Решения по результатам проверки
		if (!stillBlocked) {
			// Свободен - возобновляем движение
			npc.isWaiting = false;
			npc.otherNpc = null;
			
			if (npc.preCollisionSpeed) {
				npc.setVelocity(npc.preCollisionSpeed.x, npc.preCollisionSpeed.y);
				npc.preCollisionSpeed = null;
			} else {
				moveNPCToNextPoint(npc);
			}
		} 
		else if (npc.collisionCheckAttempts >= MAX_COLLISION_CHECKS) {
			// Превышено максимальное число попыток - разрешаем тупик
			if (npc.otherNpc && npc.otherNpc.active) {
				resolveDeadlock(npc, npc.otherNpc);
			} else {
				// Если второй NPC уже уничтожен - просто продолжаем движение
				npc.isWaiting = false;
				moveNPCToNextPoint(npc);
			}
		} 
		else {
			// Продолжаем ожидание с новой проверкой
			const nextDelay = Phaser.Math.Between(
				COLLISION_WAIT_TIME * 0.8, 
				COLLISION_WAIT_TIME * 1.2
			);
			npc.scene.time.delayedCall(nextDelay, () => recheckCollision(npc));
		}
	}
	
    function resolveDeadlock(npc1, npc2) {
      const npcToRemove = Math.random() > 0.5 ? npc1 : npc2;
      const survivingNpc = npcToRemove === npc1 ? npc2 : npc1;

      createAnnihilationEffect(npcToRemove.scene, npcToRemove);
      destroyNpc(npcToRemove);

      npcs = npcs.filter(n => n !== npcToRemove);
      exitQueue = exitQueue.filter(n => n !== npcToRemove);

      if (survivingNpc.active && survivingNpc.preCollisionSpeed) {
        survivingNpc.isWaiting = false;
        survivingNpc.setVelocity(
          survivingNpc.preCollisionSpeed.x,
          survivingNpc.preCollisionSpeed.y
        );
        survivingNpc.preCollisionSpeed = null;
      }
    }

    function createAnnihilationEffect(scene, npc) {
      const explosion = scene.add.graphics()
        .fillStyle(0xFF4500, 1)
        .fillCircle(0, 0, 25)
        .setPosition(npc.x, npc.y)
        .setDepth(25);

      scene.tweens.add({
        targets: explosion,
        scaleX: 3,
        scaleY: 3,
        alpha: 0,
        duration: 500,
        ease: 'Back.easeOut',
        onComplete: () => explosion.destroy()
      });

      if (scene.textures.exists('flares')) {
        const frames = scene.textures.get('flares').getFrameNames();
        const availableFrames = frames.filter(frame => 
          frame.includes('blue') || 
          frame.includes('green') || 
          frame.includes('red') ||
          frame.includes('white') ||
          frame.includes('yellow') ||
          frame.includes('fire')
        );
        
        if (availableFrames.length > 0) {
          const emitter = scene.add.particles(
            npc.x, 
            npc.y,
            'flares',
            {
              frame: availableFrames,
              speed: { min: -200, max: 200 },
              scale: { start: 0.6, end: 0 },
              blendMode: 'ADD',
              lifespan: 900,
              quantity: 25,
              rotate: { start: 0, end: 360 },
              emitting: false
            }
          );
          
          emitter.explode(25);
          scene.time.delayedCall(700, () => emitter.destroy());
        }
      }

      if (scene.cameras && scene.cameras.main) {
        scene.cameras.main.shake(85, 0.005);
      }

      createSmokeEffect(scene, npc.x, npc.y);
    }
	
	function destroyNpc(npc) {
		if (!npc || !npc.scene) {
			console.warn("Попытка уничтожить несуществующий NPC");
			return;
		}

		// 1. Удаляем сенсоры
		if (npc.sensors) {
			Object.values(npc.sensors).forEach(sensor => {
				if (sensor && sensor.destroy) {
					sensor.destroy();
				}
			});
		}

		// 2. Удаляем дебаг-объекты
		if (npc.__debug) {
			npc.__debug.destroy();
		}

		// 3. Отключаем физику
		if (npc.body && npc.scene.physics.world) {
			npc.scene.physics.world.disableBody(npc.body);
		}

		// 4. Останавливаем связанные таймеры
		if (npc.recheckTimer) {
			npc.recheckTimer.remove();
		}
		if (npc.exitTimer) {
			npc.exitTimer.remove();
		}

		// 5. Удаляем из массивов
		npcs = npcs.filter(n => n !== npc);
		exitQueue = exitQueue.filter(n => n !== npc);

		// 6. Логирование перед уничтожением
		const posInfo = npc.x !== undefined ? `${npc.x.toFixed(0)},${npc.y.toFixed(0)}` : 'N/A';
		const textureInfo = npc.texture?.key || 'unknown';
		console.log(`Уничтожен NPC ${textureInfo} на ${posInfo}. Осталось: ${npcs.length}`);

		// 7. Финализация
		if (npc.destroy) {
			npc.destroy();
		} else {
			npc.active = false;
		}
	}	

    function createSmokeEffect(scene, x, y) {
      if (!scene || typeof x !== 'number' || typeof y !== 'number') return;

      const smokeConfig = {
        texture: scene.textures.exists('smoke4') ? 'smoke4' : null,
        scaleStart: 0.6,
        scaleEnd: 1.1,
        alphaStart: 0.7,
        alphaEnd: 0,
        riseDistance: 80,
        duration: 800,
        xOffset: 0,
        yOffset: 22,
        originX: 0.5,
        originY: 0.5,
        rotation: 0,
        rotationEnd: 0,
        ease: 'Sine.easeOut',
        randomX: 0,
        useAnimation: scene.anims.exists('smoke_anim')
      };

      if (!smokeConfig.texture) {
        if (scene.textures.exists('flares')) {
          createFallbackSmoke(scene, x, y);
        }
        return;
      }

      const smoke = scene.add.sprite(
        x + smokeConfig.xOffset + Phaser.Math.Between(-smokeConfig.randomX, smokeConfig.randomX),
        y + smokeConfig.yOffset,
        smokeConfig.texture
      )
      .setDepth(30)
      .setScale(smokeConfig.scaleStart)
      .setAlpha(smokeConfig.alphaStart)
      .setOrigin(smokeConfig.originX, smokeConfig.originY)
      .setRotation(smokeConfig.rotation);

      if (smokeConfig.useAnimation) {
        smoke.play('smoke_anim');
      }

      scene.tweens.add({
        targets: smoke,
        y: smoke.y - smokeConfig.riseDistance,
        scaleX: smokeConfig.scaleEnd,
        scaleY: smokeConfig.scaleEnd,
        alpha: smokeConfig.alphaEnd,
        rotation: smokeConfig.rotationEnd,
        duration: smokeConfig.duration,
        ease: smokeConfig.ease,
        onComplete: () => smoke.destroy()
      });
    }

    function createFallbackSmoke(scene, x, y) {
      const particles = scene.add.particles(x, y, 'flares', {
        frame: ['white', 'yellow'],
        scale: { start: 0.3, end: 0.8 },
        alpha: { start: 0.6, end: 0 },
        speed: { min: -20, max: 20 },
        lifespan: 1000,
        quantity: 5,
        gravityY: -40,
        emitting: false
      });
      particles.explode(5);
      scene.time.delayedCall(1000, () => particles.destroy());
    }

    function avoidObstacle(npc, obstacle) {
      if (npc.isAvoiding || npc.isReversing || !npc.route || !npc.route[npc.routeIndex]) return;
      
      npc.isAvoiding = true;
      npc.preAvoidState = {
        velocity: npc.body.velocity.clone(),
        routeIndex: npc.routeIndex,
        target: {...npc.route[npc.routeIndex]}
      };
      
      let avoidAngle;
      if (obstacle.sensor === 'left') {
        avoidAngle = npc.rotation - Math.PI/4;
      } else if (obstacle.sensor === 'right') {
        avoidAngle = npc.rotation + Math.PI/4;
      } else {
        avoidAngle = npc.rotation + (Math.random() > 0.5 ? Math.PI/4 : -Math.PI/4);
      }
      
      const avoidSpeed = npcSpeed * 0.7;
      npc.setVelocity(
        Math.cos(avoidAngle - Math.PI/2) * avoidSpeed,
        Math.sin(avoidAngle - Math.PI/2) * avoidSpeed
      );
      
      const boundsCheck = () => {
        if (!npc.active) return;
        
        if (isOutOfBounds(npc)) {
          npc.isAvoiding = false;
          returnToSafePosition(npc);
          return;
        }
        
        if (npc.isAvoiding) {
          npc.scene.time.delayedCall(100, boundsCheck, [], npc.scene);
        }
      };
      
      boundsCheck();
      
      npc.scene.time.delayedCall(500, () => {
        if (npc.active && npc.isAvoiding) {
          npc.isAvoiding = false;
          
          if (npc.preAvoidState && npc.route && npc.route[npc.routeIndex]) {
            const target = npc.route[npc.routeIndex];
            const angle = Phaser.Math.Angle.Between(npc.x, npc.y, target.x, target.y);
            
            let speed;
            const isExitPhase = npc.isExiting && npc.routeIndex < EXIT_PHASE_POINTS;
            const isApproachPhase = npc.routeIndex >= npc.route.length - FINAL_APPROACH_POINTS;
            
            if (isExitPhase) {
              speed = npcExitSpeed;
            } else if (isApproachPhase) {
              speed = npcFinalApproachSpeed;
            } else {
              speed = npcSpeed;
            }
            
            npc.setVelocity(
              Math.cos(angle) * speed,
              Math.sin(angle) * speed
            );
            npc.rotation = angle + Math.PI/2;
          }
        }
      });
    }

    function moveNPCToNextPoint(npc) {
      const isParkingPhase = (
        npc.routeIndex < PARKING_START_POINTS || 
        npc.routeIndex > npc.route.length - (PARKING_END_POINTS + 1)
      );

      if (npc.sensors) {
        Object.values(npc.sensors).forEach(s => {
          s.visible = showDebug && !isParkingPhase && !npc.isReversing;
        });
      }

      const target = npc.route[npc.routeIndex];
      const angle = Phaser.Math.Angle.Between(npc.x, npc.y, target.x, target.y);
      
      let speed;
      if (npc.isExiting && npc.routeIndex < EXIT_PHASE_POINTS) {
        speed = npcExitSpeed;
      } else if (npc.routeIndex >= npc.route.length - FINAL_APPROACH_POINTS) {
        speed = npcFinalApproachSpeed;
      } else if (npc.isReversing) {
        speed = REVERSE_SPEED;
      } else {
        speed = npcSpeed;
      }

      npc.setVelocity(
        Math.cos(angle) * speed,
        Math.sin(angle) * speed
      );
      npc.rotation = angle + Math.PI/2;
    }

    function handleRouteCompletion(npc) {
      const originalPos = scaleCoords(npc.originalSpot.x, npc.originalSpot.y);
      
      const finalApproach = () => {
        const distance = Phaser.Math.Distance.Between(npc.x, npc.y, originalPos.x, originalPos.y);
        
        if (distance > 2) {
          const angle = Phaser.Math.Angle.Between(npc.x, npc.y, originalPos.x, originalPos.y);
          npc.setVelocity(
            Math.cos(angle) * npcFinalApproachSpeed,
            Math.sin(angle) * npcFinalApproachSpeed
          );
          npc.rotation = angle + Math.PI/2;
          
          npc.scene.time.delayedCall(50, finalApproach);
        } else {
          npc.setVelocity(0, 0);
          npc.x = originalPos.x;
          npc.y = originalPos.y;
          
          npc.isExiting = false;
          npc.isInExitQueue = true;
          exitQueue.push(npc);
        }
      };

      finalApproach();
    }

    function processExitQueue() {
      if (exitQueue.length === 0 || Date.now() - lastExitTime < PARKING_EXIT_DELAY) {
        game.scene.scenes[0].time.delayedCall(300, processExitQueue, [], game.scene.scenes[0]);
        return;
      }

      const nextNpc = exitQueue.shift();
      if (!nextNpc.active || nextNpc.isDestroyed) {
        game.scene.scenes[0].time.delayedCall(100, processExitQueue, [], game.scene.scenes[0]);
        return;
      }

      if (nextNpc.body.velocity.length() > 5) {
        exitQueue.push(nextNpc);
        game.scene.scenes[0].time.delayedCall(300, processExitQueue, [], game.scene.scenes[0]);
        return;
      }

      lastExitTime = Date.now();
      nextNpc.isInExitQueue = false;
      
      const delay = Phaser.Math.Between(100, 500);
      nextNpc.scene.time.delayedCall(delay, () => {
        if (nextNpc.active) {
          startNpcExit(nextNpc);
        }
      });

      game.scene.scenes[0].time.delayedCall(300, processExitQueue, [], game.scene.scenes[0]);
    }

    function startNpcExit(npc) {
      if (!npc.active || npc.isDestroyed) return;

      npc.isExiting = true;
      npc.isInExitQueue = false;
      npc.isWaiting = false;
      
      const randomRouteIndex = Math.floor(Math.random() * allPossibleRoutes.length);
      const routeType = allPossibleRoutes[randomRouteIndex];
      npc.route = routeType(npc.originalSpot);
      npc.isCounterClockwise = routeType.toString().includes('Counter');
      npc.routeIndex = 0;
      npc.lastExitTime = Date.now();
      
      moveNPCToNextPoint(npc);
    }

    function createEntranceAndPavilion(scene) {
      const { x: entranceX, y: entranceY } = scaleCoords(3 + 252/2, 893 + 216/2, true);
      const entrance = scene.add.image(entranceX, entranceY, 'entrance').setScale(0.5);
      entrance.setDepth(0);

      const { x: pavilionX, y: pavilionY } = scaleCoords(700, 100);
      const pavilion = scene.add.image(pavilionX, pavilionY, 'pavilion').setScale(0.5);
      pavilion.setDepth(0);
    }

    function createDecorativeLayer(scene) {
      const grassOffsetX = 0, grassOffsetY = 20;
      const treeOffsetX = 45, treeOffsetY = 35;
      const bushOffsetX = 35, bushOffsetY = 25;
      const oilOffsetX = 15, oilOffsetY = 23;
      const houseOffsetX = 40, houseOffsetY = 30;

      const lampTopCoords = scaleCoords(850+90, 223+170);
      const lampBottomCoords = scaleCoords(854+90, 1650-140);
      const grass1Coords = scaleCoords(661 + grassOffsetX, 89 + grassOffsetY);
      const tree1Coords = scaleCoords(1635 + treeOffsetX, 127 + treeOffsetY);
      const tree2Coords = scaleCoords(100 + 10, 900 - 300);
      const bush1Coords = scaleCoords(1716 + bushOffsetX, 298 + bushOffsetY);
      const oilCoords = scaleCoords(25 + oilOffsetX, 938 + oilOffsetY);
      
      const bush2Coords = scaleCoords(1510 + bushOffsetX, 100 + bushOffsetY);
      const bush3Coords = scaleCoords(40 + bushOffsetX, 1155 + bushOffsetY); 
      const bush4Coords = scaleCoords(83 + bushOffsetX, 1260 + bushOffsetY);
      const bush5Coords = scaleCoords(90 + bushOffsetX, 1550 + bushOffsetY);
      const house1Coords = scaleCoords(1815 + houseOffsetX, 930 + houseOffsetY);  

      const lampTop = scene.add.image(lampTopCoords.x, lampTopCoords.y, 'lamp_top').setScale(0.5);
      const lampBottom = scene.add.image(lampBottomCoords.x, lampBottomCoords.y, 'lamp_bottom').setScale(0.5);
      const grass1 = scene.add.image(grass1Coords.x, grass1Coords.y, 'grass1').setScale(0.5);
      const tree1 = scene.add.image(tree1Coords.x, tree1Coords.y, 'tree1').setScale(0.5);
      const tree2 = scene.add.image(tree2Coords.x, tree2Coords.y, 'tree2').setScale(0.4);
      const bush1 = scene.add.image(bush1Coords.x, bush1Coords.y, 'bush1').setScale(0.5);
      const oil = scene.add.image(oilCoords.x, oilCoords.y, 'oil').setScale(0.5);
      
      const bush2 = scene.add.image(bush2Coords.x, bush2Coords.y, 'bush2').setScale(0.45);
      const bush3 = scene.add.image(bush3Coords.x, bush3Coords.y, 'bush3').setScale(0.43);
      const bush4 = scene.add.image(bush4Coords.x, bush4Coords.y, 'bush4').setScale(0.40); 
      const bush5 = scene.add.image(bush5Coords.x, bush5Coords.y, 'bush5').setScale(0.44);    
      const house1 = scene.add.image(house1Coords.x, house1Coords.y, 'house1').setScale(0.41);      
      
      lampTop.setDepth(11);
      lampBottom.setDepth(11);
      grass1.setDepth(0);
      tree1.setDepth(11);
      tree2.setDepth(10);
      bush1.setDepth(10);
      oil.setDepth(0);
      bush2.setDepth(10);
      bush3.setDepth(11);
      bush4.setDepth(10);
      bush5.setDepth(10);
      house1.setDepth(10);      
    }

    function preload() {
      this.load.image('background', 'assets/parking_map.png');
      this.load.image('entrance', 'assets/entrance.png');
      this.load.image('pavilion', 'assets/pavilion.png');
      this.load.image('grass1', 'assets/grass1.png');
      this.load.image('tree1', 'assets/tree1.png');
      this.load.image('tree2', 'assets/tree2.png');
      this.load.image('bush1', 'assets/bush1.png');
      this.load.image('oil', 'assets/oil.png');
      this.load.image('lamp_top', 'assets/lamp_top.png');
      this.load.image('lamp_bottom', 'assets/lamp_bottom.png');
      this.load.atlas('flares', 'assets/particles/flares.png', 'assets/particles/flares.json');
      this.load.image('bush2', 'assets/bush1.png');
      this.load.image('bush3', 'assets/bush1.png');
      this.load.image('bush4', 'assets/bush1.png');
      this.load.image('bush5', 'assets/bush1.png');
      this.load.image('house1', 'assets/house1.png');    
      this.load.image('smoke4', 'assets/smoke/smoke4.png');
      this.load.image('smoke5', 'assets/smoke/smoke5.png');

      const models = ['sedan', 'suv', 'hatchback', 'coupe', 'van'];
      const colors = ['red', 'blue', 'green', 'yellow', 'black'];
      
      models.forEach(model => {
        colors.forEach(color => {
          this.load.image(`car_${model}_${color}`, `assets/cars/${model}_${color}.png`);
        });
      });
    }
	
	function drawWorldBoundsDebug(graphics) {
	  if (!showDebug) return;
	  
	  graphics.lineStyle(2, 0xff0000, 0.8); // Красная линия толщиной 2px
	  
	  // Основные границы мира
	  graphics.strokeRect(
		WORLD_BOUNDS.left,
		WORLD_BOUNDS.top,
		WORLD_BOUNDS.right - WORLD_BOUNDS.left,
		WORLD_BOUNDS.bottom - WORLD_BOUNDS.top
	  );
	  
	  // Зона padding (торможения)
	  graphics.lineStyle(1, 0xff0000, 0.5); // Полупрозрачная красная линия
	  graphics.strokeRect(
		WORLD_BOUNDS.left + WORLD_BOUNDS.padding,
		WORLD_BOUNDS.top + WORLD_BOUNDS.padding,
		WORLD_BOUNDS.right - WORLD_BOUNDS.left - WORLD_BOUNDS.padding * 2,
		WORLD_BOUNDS.bottom - WORLD_BOUNDS.top - WORLD_BOUNDS.padding * 2
	  );
	}	

    function create() {
      const scene = this;
      
      // Определение типа устройства
      console.log('Устройство:', isMobile ? 'Мобильное' : 'ПК');
	  
	  console.log("=== ИНИЦИАЛИЗАЦИЯ НОВОЙ СЕССИИ ===");
	  console.log("Память (начало):", performance.memory); // Только Chrome
	  console.log("Текстуры загружены:", this.textures.getTextureKeys().length);	  
      
      // Создаем фон
      background = scene.add.image(400, 400, 'background').setDepth(1);
      background.setDisplaySize(800, 800);

      // Создаем игровую зону
      gameArea = createGameArea(scene);

      // Настройка отладки
      debugGraphics = scene.add.graphics();
      debugGraphics.setDepth(20);

      // Анимация дыма
      if (this.textures.exists('smoke4') && this.textures.exists('smoke5')) {
        this.anims.create({
          key: 'smoke_anim',
          frames: [
            { key: 'smoke4' },
            { key: 'smoke5' }
          ],
          frameRate: 8,
          repeat: 0
        });
      }

      // Инициализация рядов парковочных мест
      const leftRows = [
        upperLeftParkingSpots.slice(0, 6),
        upperLeftParkingSpots.slice(6, 12),
        upperLeftParkingSpots.slice(12, 18),
        upperLeftParkingSpots.slice(18, 24)
      ];

      const rightRows = [
        upperRightParkingSpots.slice(0, 6),
        upperRightParkingSpots.slice(6, 12),
        upperRightParkingSpots.slice(12, 18),
        upperRightParkingSpots.slice(18, 24)
      ];

      // Очищаем массивы
      npcs = [];
      exitQueue = [];
      lastExitTime = 0;

      // Создаем NPC
      const allRows = [...leftRows, ...rightRows];
      allRows.forEach(row => {
        const selectedSpots = getRandomSpotsInRow(row, NPC_PER_ROW);
        selectedSpots.forEach(spot => {
          const npc = scene.physics.add.sprite(
            scaleCoords(spot.x, spot.y).x,
            scaleCoords(spot.x, spot.y).y,
            getRandomCarTexture()
          )
          .setScale(0.47)
          .setDepth(5)
          .setCollideWorldBounds(false);

          npc.body.setSize(13, 20);
          npc.body.setOffset(0, 7);

          createSensors(scene, npc);

          npc.originalSpot = spot;
          npc.routeSequence = createShuffledRouteSequence();
          npc.currentRouteIndex = 0;
          npc.route = npc.routeSequence[0](npc.originalSpot);
          npc.isCounterClockwise = npc.routeSequence[0].toString().includes('Counter');
          npc.routeIndex = 0;
          npc.isWaiting = true;
          npc.isInExitQueue = true;
          npc.isExiting = false;
          npc.isReversing = false;
          npc.isAvoiding = false;
          npc.reverseAttempts = 0;
          npc.lastExitTime = 0;
          npc.collisionCheckAttempts = 0;

          npcs.push(npc);
          exitQueue.push(npc);
        });
      });

      // Система overlap
      scene.physics.add.overlap(
        npcs,
        npcs,
        (npc1, npc2) => {
          if (npc1 === npc2 || !npc1.active || !npc2.active) return;

          const angle = Phaser.Math.Angle.Between(npc1.x, npc1.y, npc2.x, npc2.y);
          const distance = Phaser.Math.Distance.Between(npc1.x, npc1.y, npc2.x, npc2.y);
          const minDistance = 3;
          
          if (distance < minDistance) {
            const pushForce = 1.0 * (minDistance - distance);
            const pushX = Math.cos(angle) * pushForce;
            const pushY = Math.sin(angle) * pushForce;
            
            npc1.body.velocity.x += pushX;
            npc1.body.velocity.y += pushY;
            npc2.body.velocity.x -= pushX;
            npc2.body.velocity.y -= pushY;
          }

          if (npc1.isAvoiding || npc2.isAvoiding) return;

          const avoidingNpc = Math.random() > 0.5 ? npc1 : npc2;
          const otherNpc = avoidingNpc === npc1 ? npc2 : npc1;
          
          const sensorCollisions = checkSensors(avoidingNpc);
          const leftCollision = sensorCollisions.find(c => c.sensor === 'left' && c.npc === otherNpc);
          const rightCollision = sensorCollisions.find(c => c.sensor === 'right' && c.npc === otherNpc);
          
          if (leftCollision) {
            avoidObstacle(avoidingNpc, leftCollision);
          } else if (rightCollision) {
            avoidObstacle(avoidingNpc, rightCollision);
          } else if (sensorCollisions.some(c => c.sensor === 'front')) {
            avoidObstacle(avoidingNpc, { sensor: 'front' });
          }
        },
        null,
        this
      );

      scene.physics.add.collider(npcs, gameArea);

      // ===== НОВЫЙ КОД: Система камеры для мобильных =====
      if (isMobile) {
        cameraTarget = scene.add.rectangle(400, 400, 10, 10).setAlpha(0);
        
        // Выбираем случайный NPC для слежения
        function updateCameraTarget() {
          if (npcs.length > 0) {
            currentTarget = Phaser.Math.RND.pick(npcs);
            console.log('Камера следует за:', currentTarget);
          }
        }
        
        // Настройка камеры
        scene.cameras.main.setZoom(1.8);
        scene.cameras.main.startFollow(cameraTarget);
        scene.cameras.main.setBounds(0, 0, mapWidth, mapHeight);
        
        // Обновляем цель каждые 3 секунды
        scene.time.addEvent({ 
          delay: 3000, 
          callback: updateCameraTarget, 
          loop: true 
        });
        
        updateCameraTarget();
        
        // Смена цели по тапу
        scene.input.on('pointerdown', () => {
          updateCameraTarget();
        });
      } else {
        // Для ПК оставляем стандартную камеру
        scene.cameras.main.setBounds(0, 0, mapWidth, mapHeight);
      }

      // Запуск обработчика очереди выезда
      processExitQueue();

      // Создаем декорации
      createEntranceAndPavilion(scene);
      createDecorativeLayer(scene);

      // Кнопка тестирования дыма (T)
      scene.input.keyboard.on('keydown-T', () => {
        const testX = Phaser.Math.Between(100, 700);
        const testY = Phaser.Math.Between(100, 700);
        createSmokeEffect(scene, testX, testY);
      });

      // Кнопка аннигиляции NPC (E)
      scene.input.keyboard.on('keydown-E', () => {
        if (npcs.length > 0) {
          const randomNpc = npcs[Phaser.Math.Between(0, npcs.length - 1)];
          createAnnihilationEffect(scene, randomNpc);
          
          scene.time.delayedCall(500, () => {
            destroyNpc(randomNpc);
            npcs = npcs.filter(n => n !== randomNpc);
          });
        }
      });

      // Настройка клавиш отладки
	  scene.input.keyboard.on('keydown-D', () => {
	    showDebug = !showDebug;
	    debugGraphics.clear();
	  
	    if (showDebug) {
		  // Отрисовка границ мира
		  drawWorldBoundsDebug(debugGraphics);
		
		  // Существующая отрисовка игровых зон
		  gameArea.each(child => {
		    debugGraphics.fillStyle(0x00ff00, 0.3);
		    debugGraphics.lineStyle(2, 0x00ff00, 0.6);
		    debugGraphics.fillRect(
			  child.x - child.width/2,
			  child.y - child.height/2,
			  child.width,
			  child.height
		    );
		    debugGraphics.strokeRect(
			  child.x - child.width/2,
			  child.y - child.height/2,
			  child.width,
			  child.height
		    );
		  });
	    }
	  });

      scene.input.keyboard.on('keydown-H', () => {
        if (showDebug) {
          showCollisionHighlights = !showCollisionHighlights;
        }
      });
	  
	  this.physics.world.setBounds(
	    WORLD_BOUNDS.left, 
	    WORLD_BOUNDS.top, 
	    WORLD_BOUNDS.right, 
	    WORLD_BOUNDS.bottom
	  );	  
    }
	
	function handleWorldBounds(npc) {
		if (!npc.active) return false;

		// Проверяем приближение к границам (зона торможения)
		const nearBounds = 
			npc.x < WORLD_BOUNDS.left + WORLD_BOUNDS.padding ||
			npc.x > WORLD_BOUNDS.right - WORLD_BOUNDS.padding ||
			npc.y < WORLD_BOUNDS.top + WORLD_BOUNDS.padding ||
			npc.y > WORLD_BOUNDS.bottom - WORLD_BOUNDS.padding;

		// Плавное торможение в зоне padding
		if (nearBounds) {
			npc.setVelocity(
				npc.body.velocity.x * 0.85,
				npc.body.velocity.y * 0.85
			);
		}

		// Проверка полного выхода за границы
		const outOfBounds = 
			npc.x < WORLD_BOUNDS.left ||
			npc.x > WORLD_BOUNDS.right ||
			npc.y < WORLD_BOUNDS.top ||
			npc.y > WORLD_BOUNDS.bottom;

		if (outOfBounds) {
			console.log(`NPC вышел за границы @ ${npc.x.toFixed(1)},${npc.y.toFixed(1)}`);
			destroyNpc(npc); // Полная очистка вместо деактивации
			return true;
		}
		
		return false;
	}	
    
	function update() {
	  // Фильтрация неактивных NPC
	  npcs = npcs.filter(n => n && n.active && n.body);
	  
	  // Для мобильных: плавное перемещение камеры
	  if (isMobile && cameraTarget && currentTarget && currentTarget.active) {
		cameraTarget.x = Phaser.Math.Linear(cameraTarget.x, currentTarget.x, 0.1);
		cameraTarget.y = Phaser.Math.Linear(cameraTarget.y, currentTarget.y, 0.1);
	  }

	  // Основной цикл обработки NPC
	  for (let i = 0; i < npcs.length; i++) {
		const npc = npcs[i];
		
		// Проверка на валидность NPC
		if (!npc || !npc.active || !npc.body || !npc.route) {
		  continue;
		}

		// 1. Проверка границ мира
		if (handleWorldBounds(npc)) {
		  continue;
		}
		
		// 2. Обновление сенсоров
		updateSensors(npc);
		
		// 3. Пропуск NPC в состоянии ожидания/разворота
		if (npc.isReversing || npc.isAvoiding || npc.isWaiting) {
		  continue;
		}

		// 4. Проверка столкновений
		const collisions = checkSensors(npc);
		
		// 5. Движение к следующей точке маршрута
		const target = npc.route[npc.routeIndex];
		if (!target) {
		  console.warn("Отсутствует целевая точка для NPC:", npc.texture?.key || 'unknown');
		  npc.routeIndex = 0;
		  continue;
		}

		const distance = Phaser.Math.Distance.Between(npc.x, npc.y, target.x, target.y);
		if (distance < 5) {
		  npc.routeIndex++;
		  
		  if (npc.routeIndex >= npc.route.length) {
			handleRouteCompletion(npc);
			continue;
		  }
		  
		  moveNPCToNextPoint(npc);
		}
	  }

	  // Экстренная очистка при превышении лимита
	  if (npcs.length > 50) {
		console.error(`Превышен лимит NPC (${npcs.length})! Очистка...`);
		const excessCount = npcs.length - 25;
		const excessNpcs = npcs.splice(25, excessCount);
		excessNpcs.forEach(npc => {
		  if (npc) destroyNpc(npc);
		});
	  }
	}
  </script>
</head>
<body>
  <div id="game-container"></div>
  <div class="debug-panel">
    Режим: <span id="device-mode">ПК</span><br>
    <span id="camera-info">Камера: фиксированная</span><br>
    Debug: Нажмите 'D' для отображения границ<br>
    Нажмите 'E' и 'T' для аннигиляции и дымового эффекта
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      document.getElementById('device-mode').textContent = isMobile ? 'Мобильный' : 'ПК';
      document.getElementById('camera-info').textContent = isMobile 
        ? 'Камера: слежение за NPC' 
        : 'Камера: фиксированная';
    });
  </script>
</body>
</html>