<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Parking Rush</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #000;
    }
    #game-container {
      display: block;
      max-width: 100%;
      max-height: 100%;
    }
    .debug-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      font-family: monospace;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>
        /*
      ============================================
      ОПИСАНИЕ ИГРЫ "MASTER PARKING"
      ============================================

      Цель игры:
      Игрок должен как можно быстрее и точнее припарковать автомобиль на заданное парковочное место.
      На пути игрока встречаются препятствия: другие автомобили (NPC), мотоциклисты, пешеходы и т.д.

      Базовая механика:
      1. Игрок управляет автомобилем, который может двигаться только по дорогам.
      2. На карте есть парковочные места, на которые нужно припарковаться.
      3. NPC (другие автомобили, мотоциклисты, пешеходы) двигаются по своим маршрутам и создают препятствия.
      4. Игрок должен избегать столкновений с NPC и другими объектами.
      5. Победа засчитывается, когда игрок успешно паркуется на заданное место за минимальное время.

      Особенности:
      - Дороги: все объекты (игрок и NPC) могут двигаться только по дорогам.
      - Парковочные места: на них могут стоять NPC, и на одно из них нужно припарковаться.
      - NPC: двигаются по заданным маршрутам, могут заезжать и выезжать с парковочных мест.
      - Физика: реализована с использованием движка Phaser 3 (arcade physics).

      ============================================
     */ 
  
    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 800,
      parent: 'game-container',
      scene: {
        preload: preload,
        create: create,
        update: update
      },
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 },
          debug: false
        }
      },
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
      }
    };

    const game = new Phaser.Game(config);

    // Конфигурация
    const parkingSpotWidth = 59;
    const parkingSpotHeight = 85;
    const scaleFactor = 0.4;
    const offsetX = (parkingSpotWidth / 2) * scaleFactor;
    const offsetY = (parkingSpotHeight / 2) * scaleFactor;
    const roadOffsetX = -12;
    const roadOffsetY = -16;
    const npcWidth = 40;
    const npcOffset = npcWidth / 2;

    // Конфигурация сенсоров NPC
    const npcSensors = {
      front: { width: 60, height: 20, offset: 45 },
      left: { width: 20, height: 40, offset: 25 },
      right: { width: 20, height: 40, offset: 25 },
      debugColor: 0xff0000,
      debugAlpha: 0.3
    };
	
	const PARKING_PHASE_POINTS = 3; // Число точек для отключения сенсоров	
	const FINAL_APPROACH_POINTS = 3; // Число точек для снижения скорости (при парковке)
	const npcExitSpeed = 30; // Новая скорость для выезда (между обычной и парковочной)
	const EXIT_PHASE_POINTS = 3; // На скольки первых точках маршрута применять скорость выезда
    const PRIORITY_ROUTES = [0, 1, 2, 3]; // Маршруты с приоритетом движения

    // Парковочные места
    const upperLeftParkingSpots = [
		{ x: 361, y: 380 }, //{ x: 454, y: 380 }, { x: 546, y: 380 }, { x: 641, y: 380 }, { x: 729, y: 380 }, { x: 823, y: 380 },	// 1-й левый верхний ряд 6 мест
	//	{ x: 361, y: 674 }, { x: 454, y: 674 }, { x: 546, y: 674 }, { x: 641, y: 674 }, { x: 729, y: 674 }, { x: 823, y: 674 }, // 2-й левый верхний ряд 6 мест
	//	{ x: 361, y: 1130 }, { x: 454, y: 1130 }, { x: 546, y: 1130 }, { x: 641, y: 1130 }, { x: 729, y: 1130 }, { x: 823, y: 1130 }, // 3-й левый верхний ряд 6 мест
		{ x: 361, y: 1420 }, //{ x: 454, y: 1420 }, { x: 546, y: 1420 }, { x: 641, y: 1420 }, { x: 729, y: 1420 }, { x: 823, y: 1420 } // 4-й левый верхний ряд 6 мест  
    ];
	
    const upperRightParkingSpots = [
        { x: 1094, y: 380 }, //{ x: 1189, y: 380 }, { x: 1279, y: 380 }, { x: 1371, y: 380 }, { x: 1462, y: 380 }, { x: 1555, y: 380 }, // 1-й правый верхний ряд 6 мест
	//	{ x: 1094, y: 674 }, { x: 1189, y: 674 }, { x: 1279, y: 674 }, { x: 1371, y: 674 }, { x: 1462, y: 674 }, { x: 1555, y: 674 }, // 2-й правый верхний ряд 6 мест
	//	{ x: 1094, y: 1130 }, { x: 1189, y: 1130 }, { x: 1279, y: 1130 }, { x: 1371, y: 1130 }, { x: 1462, y: 1130 }, { x: 1555, y: 1130 }, // 3-й правый нижний ряд 6 мест 
	//	{ x: 1094, y: 1420 }, { x: 1189, y: 1420 }, { x: 1279, y: 1420 }, { x: 1371, y: 1420 }, { x: 1462, y: 1420 }, { x: 1555, y: 1420 } // 4-й правый нижний ряд 6 мест  
    ];
	
    const allParkingSpots = [...upperLeftParkingSpots, ...upperRightParkingSpots];

    // Все 15 маршрутов
    const allPossibleRoutes = [
      // 1. Полный круг по часовой стрелке
      function clockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 690 - npcOffset, y: y - 37 }, { x: 690 - npcOffset, y: 665 - npcOffset },
          { x: 110 + npcOffset, y: 665 - npcOffset }, { x: 110 + npcOffset, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      // 2. Полный круг против часовой стрелки
      function counterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 82 + npcOffset, y: y - 62 }, { x: 82 + npcOffset, y: 710 - npcOffset },
          { x: 725 - npcOffset, y: 710 - npcOffset }, { x: 725 - npcOffset, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      // 3. Верхняя половина по часовой стрелке
      function upperHalfClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 690 - npcOffset, y: y - 37 }, { x: 690 - npcOffset, y: 370 },
          { x: 110 + npcOffset, y: 370 }, { x: 110 + npcOffset, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      // 4. Верхняя половина против часовой стрелки
      function upperHalfCounterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 82 + npcOffset, y: y - 62 }, { x: 82 + npcOffset, y: 405 },
          { x: 725 - npcOffset, y: 405 }, { x: 725 - npcOffset, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },	  
      // 5. Левая верхняя четверть по часовой стрелке
      function leftHalfClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 390 - npcOffset, y: y - 37 }, { x: 390 - npcOffset, y: 360 },
          { x: 110 + npcOffset, y: 360 }, { x: 110 + npcOffset, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      // 6. Левая верхняя четверть против часовой стрелки
      function leftHalfCounterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 82 + npcOffset, y: y - 62 }, { x: 82 + npcOffset, y: 390 },
          { x: 395, y: 390 }, { x: 395, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      // 7. Правая половина по часовой стрелке
      function rightHalfClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 690 - npcOffset, y: y - 37 }, { x: 690 - npcOffset, y: 665 - npcOffset },
          { x: 420, y: 665 - npcOffset }, { x: 420, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      // 8. Правая половина против часовой стрелки
      function rightHalfCounterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 395, y: y - 62 }, { x: 395, y: 710 - npcOffset },
          { x: 725 - npcOffset, y: 710 - npcOffset }, { x: 725 - npcOffset, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      // 9. Правая верхняя четверть по часовой стрелке
      function rightUpperQuarterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 690 - npcOffset, y: y - 37 }, { x: 690 - npcOffset, y: 370 },
          { x: 420, y: 370 }, { x: 420, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      //10. Правая верхняя четверть против часовой стрелки
      function rightUpperQuarterCounterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 394, y: y - 62 }, { x: 394, y: 400 },
          { x: 725 - npcOffset, y: 400 }, { x: 725 - npcOffset, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },	  
      // 11. Правая верхняя малая половина по часовой стрелке
      function leftUpperSmallClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 690 - npcOffset, y: y - 37 }, { x: 690 - npcOffset, y: 220 },
          { x: 420, y: 220 }, { x: 420, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      // 12. Правая верхняя малая половина против часовой стрелки
      function rightUpperQuarterCounterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 394, y: y - 62 }, { x: 394, y: 245 },
          { x: 725 - npcOffset, y: 245 }, { x: 725 - npcOffset, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
     // 13. Левая верхняя малая половина по часовой стрелке
      function rightUpperHalfClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 390 - npcOffset, y: y - 37 }, { x: 390 - npcOffset, y: 220 },
          { x: 110 + npcOffset, y: 220 }, { x: 110 + npcOffset, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      // 14 Левая верхняя малая половина против часовой стрелки
      function leftSmallCounterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 82 + npcOffset, y: y - 62 }, { x: 82 + npcOffset, y: 245 },
          { x: 399, y: 245 }, { x: 399, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },	  
      // 15. Левая половина против часовой стрелки
      function leftBigHalfCounterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 82 + npcOffset, y: y - 62 }, { x: 82 + npcOffset, y: 710 - npcOffset },
          { x: 399, y: 710 - npcOffset }, { x: 399, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      }	  
    ];

    // Глобальные переменные
    let npcs = [];
    const npcSpeed = 100;
    const npcParkingSpeed = 30;
    const npcFinalApproachSpeed = 40;
    const PARKING_EXIT_DELAY = 4000; // 4 сек между выездами
    let lastExitTime = 0;
    let exitQueue = []; // Очередь машин, ожидающих выезда
    let debugGraphics;
    let showDebug = false;
    let roadsCollider;
    let combinedCollider;
	let showCollisionHighlights = true; // Новая переменная для управления подсветкой

    function scaleCoords(x, y, isRoad = false) {
      const scaledX = (x / 2000) * 800 + offsetX;
      const scaledY = ( y / 2000) * 800 + offsetY;
      if (isRoad) return { x: scaledX + roadOffsetX, y: scaledY + roadOffsetY };
      return { x: scaledX, y: scaledY };
    }

    function createShuffledRouteSequence() {
      const routes = [...allPossibleRoutes];
      for (let i = routes.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [routes[i], routes[j]] = [routes[j], routes[i]];
      }
      return routes;
    }

    function processExitQueue() {
      if (exitQueue.length > 0 && Date.now() - lastExitTime > PARKING_EXIT_DELAY) {
        const nextNpc = exitQueue.shift();
        nextNpc.isExiting = true;
        nextNpc.isInExitQueue = false;
        lastExitTime = Date.now();

        // Запускаем выезд
        startNpcExit(nextNpc);
      }

      // Продолжаем проверять очередь
      game.scene.scenes[0].time.delayedCall(100, processExitQueue, [], game.scene.scenes[0]);
    }

    function startNpcExit(npc) {
      npc.isWaiting = false;
      npc.routeIndex = 0;
      
      // Выбираем случайный маршрут для выезда
      const randomRouteIndex = Math.floor(Math.random() * allPossibleRoutes.length);
      const routeType = allPossibleRoutes[randomRouteIndex];
      npc.route = routeType(npc.originalSpot);
      npc.isCounterClockwise = routeType.toString().includes('Counter');
      
      moveNPCToNextPoint(npc);
    }

    // НОВЫЕ ФУНКЦИИ ДЛЯ ОБЪЕЗДА ПРЕПЯТСТВИЙ
	function tryOvertake(npc, obstacle) {
		// Определяем направление движения (горизонтальное/вертикальное)
		const nextPoint = npc.route[npc.routeIndex];
		const isHorizontalMove = Math.abs(nextPoint.x - npc.x) > Math.abs(nextPoint.y - npc.y);
		
		// Варианты объезда (влево/вправо или вверх/вниз)
		const overtakeOptions = isHorizontalMove ? 
			[{x: npc.x, y: npc.y - npc.width}, {x: npc.x, y: npc.y + npc.width}] : // Верх/низ
			[{x: npc.x - npc.width, y: npc.y}, {x: npc.x + npc.width, y: npc.y}];  // Лево/право

		// Ищем свободное направление
		let chosenOvertake = null;
		for (const option of overtakeOptions) {
			if (isPathClear(npc, option)) {
				chosenOvertake = option;
				break;
			}
		}

		if (!chosenOvertake) {
			performEmergencyReverse(npc);
			return;
		}

		// Временный маршрут объезда
		const originalRoute = [...npc.route];
		const originalIndex = npc.routeIndex;
		const returnPoint = isHorizontalMove ? 
			{x: nextPoint.x, y: chosenOvertake.y} : 
			{x: chosenOvertake.x, y: nextPoint.y};

		npc.route = [
			{x: npc.x, y: npc.y},  // Текущая позиция
			chosenOvertake,         // Точка смещения
			returnPoint,            // Возврат на линию маршрута
			nextPoint               // Исходная цель
		];
		npc.routeIndex = 0;

		// Контроль выполнения
		const cleanup = () => {
			if (npc.routeIndex >= 2) { // После возврата на маршрут
				npc.route = originalRoute;
				npc.routeIndex = originalIndex;
				moveNPCToNextPoint(npc);
			} else {
				npc.scene.time.delayedCall(100, cleanup);
			}
		};
		cleanup();
	}

	function isPathClear(npc, target) {
		const angle = Phaser.Math.Angle.Between(npc.x, npc.y, target.x, target.y);
		const distance = Phaser.Math.Distance.Between(npc.x, npc.y, target.x, target.y);
		const steps = Math.ceil(distance / 5);
		
		for (let i = 0; i <= steps; i++) {
			const checkX = npc.x + Math.cos(angle) * distance * (i/steps);
			const checkY = npc.y + Math.sin(angle) * distance * (i/steps);
			
			// Проверка столкновений с NPC
			if (npcs.some(other => 
				other !== npc && 
				other.active &&
				Phaser.Math.Distance.Between(checkX, checkY, other.x, other.y) < npc.width
			)) return false;
			
			// Проверка на дороге (если у вас есть коллайдер дорог)
			if (!isOnRoad(checkX, checkY)) return false;
		}
		return true;
	}

	function isOnRoad(x, y) {
		return combinedCollider.list.some(collider => 
			x >= collider.x - collider.width/2 &&
			x <= collider.x + collider.width/2 &&
			y >= collider.y - collider.height/2 &&
			y <= collider.y + collider.height/2
		);
	}

    function checkSensorCollisions(npc, sensorName) {
        if (!npc.sensors || !npc.sensors[sensorName]) return false;
        
        const sensor = npc.sensors[sensorName];
        const sensorBounds = sensor.getBounds();
        
        return npcs.some(other => {
            if (other === npc || !other.active) return false;
            return Phaser.Geom.Intersects.RectangleToRectangle(
                sensorBounds,
                other.getBounds()
            );
        });
    }

    function visualizeOvertakeOptions(npc, leftClear, rightClear) {
        const graphics = npc.scene.add.graphics();
        
        // Визуализация безопасных зон
        if (leftClear) {
            graphics.fillStyle(0xffffff, 0.5);
            graphics.fillRect(
                npc.x - npc.width - 20,
                npc.y - npc.height/2,
                20,
                npc.height
            );
        }
        
        if (rightClear) {
            graphics.fillStyle(0xffffff, 0.5);
            graphics.fillRect(
                npc.x + npc.width,
                npc.y - npc.height/2,
                20,
                npc.height
            );
        }
        
        npc.scene.time.delayedCall(1000, () => graphics.destroy());
    }

	function performOvertake(npc, obstacle, direction) {
		console.log(`NPC at (${npc.x.toFixed(0)}, ${npc.y.toFixed(0)}) объезжает ${direction} препятствие`);
		
		// Сохраняем оригинальный маршрут и текущую точку
		const originalRoute = npc.route;
		const originalIndex = npc.routeIndex;
		const originalTarget = originalRoute[originalIndex];
		
		// Вычисляем точку объезда
		const angleToObstacle = Phaser.Math.Angle.Between(npc.x, npc.y, obstacle.x, obstacle.y);
		const overtakeDistance = npc.width * 2; // Увеличиваем дистанцию объезда
		const overtakeAngle = angleToObstacle + (direction === 'left' ? -Math.PI/2 : Math.PI/2);
		
		// Точка смещения в сторону
		const sidePoint = {
			x: npc.x + Math.cos(overtakeAngle) * overtakeDistance,
			y: npc.y + Math.sin(overtakeAngle) * overtakeDistance
		};
		
		// Точка перед препятствием (сбоку)
		const forwardPoint = {
			x: sidePoint.x + Math.cos(angleToObstacle) * overtakeDistance,
			y: sidePoint.y + Math.sin(angleToObstacle) * overtakeDistance
		};
		
		// Точка возврата на маршрут
		const returnPoint = {
			x: forwardPoint.x - Math.cos(overtakeAngle) * overtakeDistance,
			y: forwardPoint.y - Math.sin(overtakeAngle) * overtakeDistance
		};
		
		// Временный маршрут объезда
		npc.route = [
			{ x: npc.x, y: npc.y },    // Текущая позиция
			sidePoint,                  // Смещение в сторону
			forwardPoint,               // Проезд вперед
			returnPoint,                // Возврат на линию маршрута
			originalTarget              // Оригинальная цель
		];
		npc.routeIndex = 0;
		
		// Восстановление оригинального маршрута
		const cleanup = () => {
			if (!npc.scene) return;
			
			// Проверяем, достигли ли мы точки возврата
			if (npc.routeIndex >= 3) { // После проезда returnPoint
				npc.route = originalRoute;
				npc.routeIndex = originalIndex;
				moveNPCToNextPoint(npc);
			} else {
				// Продолжаем движение по временному маршруту
				npc.scene.time.delayedCall(100, cleanup);
			}
		};
		
		// Запускаем проверку завершения объезда
		cleanup();
	}

	function performEmergencyReverse(npc) {
		const originalRoute = [...npc.route];
		const originalIndex = npc.routeIndex;
		
		// Точка заднего хода (на 2 длины NPC назад)
		const reverseAngle = npc.rotation - Math.PI/2;
		const reversePoint = {
			x: npc.x + Math.cos(reverseAngle) * npc.width * 2,
			y: npc.y + Math.sin(reverseAngle) * npc.width * 2
		};
		
		// Временный маршрут
		npc.route = [
			{x: npc.x, y: npc.y},
			reversePoint,
			{x: npc.x, y: npc.y}  // Возврат на исходную позицию
		];
		npc.routeIndex = 0;

		// Возврат на исходный маршрут через 2 секунды
		npc.scene.time.delayedCall(2000, () => {
			if (!npc.scene) return;
			npc.route = originalRoute;
			npc.routeIndex = originalIndex;
			moveNPCToNextPoint(npc);
		});
	}

    function updateSensors(npc) {
      if (!npc.sensors) return;
      
      // Определяем, находится ли NPC в зоне парковки/выезда
    const isParkingPhase = (
      npc.routeIndex < PARKING_PHASE_POINTS || 
      npc.routeIndex > npc.route.length - (PARKING_PHASE_POINTS + 1)
    );
      
      // Обновляем видимость (если в дебаг-режиме)
      const shouldShow = showDebug && !isParkingPhase;
      Object.values(npc.sensors).forEach(sensor => {
        sensor.visible = shouldShow;
      });

      // Не обновляем позиции сенсоров в парковочной фазе
      if (isParkingPhase) return;

      // Стандартное обновление позиций сенсоров
      const rotation = npc.rotation - Math.PI/2;
      
      // Фронтальный сенсор
      npc.sensors.front.x = npc.x + Math.cos(rotation) * npcSensors.front.offset;
      npc.sensors.front.y = npc.y + Math.sin(rotation) * npcSensors.front.offset;
      npc.sensors.front.rotation = rotation;
      
      // Левый сенсор
      npc.sensors.left.x = npc.x + Math.cos(rotation + Math.PI/2) * npcSensors.left.offset;
      npc.sensors.left.y = npc.y + Math.sin(rotation + Math.PI/2) * npcSensors.left.offset;
      npc.sensors.left.rotation = rotation;
      
      // Правый сенсор
      npc.sensors.right.x = npc.x + Math.cos(rotation - Math.PI/2) * npcSensors.right.offset;
      npc.sensors.right.y = npc.y + Math.sin(rotation - Math.PI/2) * npcSensors.right.offset;
      npc.sensors.right.rotation = rotation;
    }

    function checkCollisions(npc) {
        if (!npc.sensors || 
            npc.routeIndex < PARKING_PHASE_POINTS || 
            npc.routeIndex > npc.route.length - (PARKING_PHASE_POINTS + 1)) {
            return [];
        }

        const collisions = [];
        const npcBounds = npc.getBounds();
        
        // Оптимизация: проверяем только NPC в радиусе 200px
        const nearbyNpcs = npcs.filter(other => {
            return other !== npc && other.active && 
                   Phaser.Math.Distance.Between(npc.x, npc.y, other.x, other.y) < 200;
        });

        nearbyNpcs.forEach(other => {
            Object.entries(npc.sensors).forEach(([sensorName, sensor]) => {
                if (Phaser.Geom.Intersects.RectangleToRectangle(
                    sensor.getBounds(),
                    other.getBounds()
                )) {
                    collisions.push({
                        npc: other,
                        sensor: sensorName,
                        distance: Phaser.Math.Distance.Between(npc.x, npc.y, other.x, other.y)
                    });

                    if (showDebug && showCollisionHighlights) {
                        const debugGraphics = npc.scene.add.graphics();
                        debugGraphics.fillStyle(0xffff00, 0.5);
                        debugGraphics.fillRect(
                            other.x - other.width/2,
                            other.y - other.height/2,
                            other.width,
                            other.height
                        );
                        npc.scene.time.delayedCall(100, () => debugGraphics.destroy());
                    }
                }
            });
        });
        
        return collisions;
    }

    function handleFrontCollision(npc, collision) {
        if (showDebug && showCollisionHighlights) {
            const debugGraphics = npc.scene.add.graphics();
            debugGraphics.fillStyle(0xff0000, 0.5);
            debugGraphics.fillRect(
                collision.npc.x - collision.npc.width/2,
                collision.npc.y - collision.npc.height/2,
                collision.npc.width,
                collision.npc.height
            );
            npc.scene.time.delayedCall(1000, () => debugGraphics.destroy());
        }

        // Проверка приоритета
        if (collision.npc.hasPriority && !npc.hasPriority) {
            npc.scene.time.delayedCall(2000, () => {
                if (!npc.scene) return;
                npc.isWaiting = false;
                moveNPCToNextPoint(npc);
            });
            return;
        }

        npc.preCollisionSpeed = npc.body.velocity.clone();
        npc.setVelocity(0, 0);
        npc.isWaiting = true;
        
        npc.scene.time.delayedCall(1000, () => {
            if (!npc.scene) return;
            
            const newCollisions = checkCollisions(npc);
            if (newCollisions.some(c => c.sensor === 'front')) {
                tryOvertake(npc, collision.npc);
            } else {
                npc.isWaiting = false;
                if (npc.preCollisionSpeed) {
                    npc.setVelocity(npc.preCollisionSpeed.x, npc.preCollisionSpeed.y);
                } else {
                    moveNPCToNextPoint(npc);
                }
            }
        });
    }

    function preload() {
      this.load.image('lamp_top', 'assets/lamp_top.png');
      this.load.image('lamp_bottom', 'assets/lamp_bottom.png');	
      this.load.image('background', 'assets/parking_map.png');
      this.load.image('entrance', 'assets/entrance.png');
      this.load.image('pavilion', 'assets/pavilion.png');
      this.load.image('grass1', 'assets/grass1.png');
      this.load.image('tree1', 'assets/tree1.png');
      this.load.image('tree2', 'assets/tree2.png');
      this.load.image('bush1', 'assets/bush1.png');
      this.load.image('oil', 'assets/oil.png');
      this.load.image('npcCar', 'assets/npc_car.png');
    }
		
	function create() {
		// Фон
		const background = this.add.image(400, 400, 'background');
		background.setDisplaySize(800, 800);

		// Создание единого коллайдера для всех дорог и парковочных мест
		createCombinedCollider(this);

		// Дебаг графика для визуализации
		debugGraphics = this.add.graphics();
		debugGraphics.setDepth(20);
		if (showDebug) {
			drawDebugColliders(this);
		}

		// Функция создания невидимых парковочных мест
		const createInvisibleParkingSpots = (scene) => {
			allParkingSpots.forEach(spot => {
				const { x, y } = scaleCoords(spot.x, spot.y);
				const parkingSpot = scene.add.rectangle(
					x, y,
					parkingSpotWidth * scaleFactor,
					parkingSpotHeight * scaleFactor,
					0x000000,
					0
				).setOrigin(0.5);
				scene.physics.add.existing(parkingSpot, true);
			});
		};

		// Функция создания невидимых дорог
		const createInvisibleRoads = (scene) => {
			const roads = [
				{ x: 3 + 252/2, y: 893 + 216/2, width: 252, height: 216 },
				{ x: 237 + 104/2, y: 236 + 1529/2, width: 140, height: 1529 },
				{ x: 1618 + 32 + 120/2, y: 237 + 1526/2, width: 120 + 64, height: 1526 },
				{ x: 257 + 1485/2, y: 234 + 143/2, width: 1485, height: 143 },
				{ x: 259 + 1479/2, y: 1622 - 40 + 141/2, width: 1479, height: 221 },
				{ x: 257 + 1482/2, y: 872 - 40 + 252/2, width: 1482, height: 332 },
				{ x: 887 + 203/2, y: 236 + 1528/2, width: 203, height: 1528 },
				{ x: 259 + 1477/2, y: 579 - 42 + 94/2, width: 1477, height: 94 + 84 },
				{ x: 259 + 1477/2, y: 1326 - 42 + 94/2, width: 1477, height: 94 + 84 }
			];

			roads.forEach(road => {
				const { x, y } = scaleCoords(road.x, road.y, true);
				const roadRect = scene.add.rectangle(
					x, y,
					road.width * scaleFactor,
					road.height * scaleFactor,
					0x000000,
					0
				).setOrigin(0.5);
				scene.physics.add.existing(roadRect, true);
			});
		};

		// Создаем невидимые объекты
		createInvisibleParkingSpots(this);
		createInvisibleRoads(this);

		// Функция создания входа и павильона
		const createEntranceAndPavilion = (scene) => {
			// Въезд
			const { x: entranceX, y: entranceY } = scaleCoords(3 + 252/2, 893 + 216/2, true);
			scene.add.image(entranceX, entranceY, 'entrance').setScale(0.5);

			// Павильон
			const { x: pavilionX, y: pavilionY } = scaleCoords(700, 100);
			scene.add.image(pavilionX, pavilionY, 'pavilion').setScale(0.5);
		};

		// Функция создания декоративных элементов
		const createDecorativeLayer = (scene) => {
			// Смещения для декоративных элементов
			const grassOffsetX = 0, grassOffsetY = 20;
			const treeOffsetX = 45, treeOffsetY = 35;
			const bushOffsetX = 35, bushOffsetY = 25;
			const oilOffsetX = 15, oilOffsetY = 23;

			// Координаты элементов
			const lampTopCoords = scaleCoords(850+90, 223+170);
			const lampBottomCoords = scaleCoords(854+90, 1650-140);
			const grass1Coords = scaleCoords(661 + grassOffsetX, 89 + grassOffsetY);
			const tree1Coords = scaleCoords(1635 + treeOffsetX, 127 + treeOffsetY);
			const tree2Coords = scaleCoords(100 + 10, 900 - 300);
			const bush1Coords = scaleCoords(1716 + bushOffsetX, 298 + bushOffsetY);
			const oilCoords = scaleCoords(25 + oilOffsetX, 938 + oilOffsetY);

			// Создание элементов
			const lampTop = scene.add.image(lampTopCoords.x, lampTopCoords.y, 'lamp_top').setScale(0.5);
			const lampBottom = scene.add.image(lampBottomCoords.x, lampBottomCoords.y, 'lamp_bottom').setScale(0.5);
			const grass1 = scene.add.image(grass1Coords.x, grass1Coords.y, 'grass1').setScale(0.5);
			const tree1 = scene.add.image(tree1Coords.x, tree1Coords.y, 'tree1').setScale(0.5);
			const tree2 = scene.add.image(tree2Coords.x, tree2Coords.y, 'tree2').setScale(0.4);
			const bush1 = scene.add.image(bush1Coords.x, bush1Coords.y, 'bush1').setScale(0.5);
			const oil = scene.add.image(oilCoords.x, oilCoords.y, 'oil').setScale(0.5);

			// Установка глубины отображения
			lampTop.setDepth(11);
			lampBottom.setDepth(11);
			grass1.setDepth(2);
			tree1.setDepth(10);
			tree2.setDepth(10);
			bush1.setDepth(10);
			oil.setDepth(2);
		};

		// Создаем декорации
		createEntranceAndPavilion(this);
		createDecorativeLayer(this);

		// Создание NPC с сенсорами
		const shuffledSpots = Phaser.Utils.Array.Shuffle([...allParkingSpots]);
		npcs = shuffledSpots.map((spot) => {
			const { x, y } = scaleCoords(spot.x, spot.y);
			const npc = this.physics.add.sprite(x, y, 'npcCar')
				.setScale(0.5)
				.setDepth(3)
				.setCollideWorldBounds(true);
			
			// Система маршрутов
			npc.originalSpot = spot;
			npc.routeSequence = createShuffledRouteSequence();
			npc.currentRouteIndex = 0;
			
			// Определяем направление перед началом движения
			const firstRouteType = npc.routeSequence[npc.currentRouteIndex];
			npc.route = firstRouteType(npc.originalSpot);
			npc.isCounterClockwise = firstRouteType.toString().includes('Counter');
			npc.hasPriority = PRIORITY_ROUTES.includes(npc.currentRouteIndex);
			
			npc.routeIndex = 0;
			npc.isWaiting = true;
			npc.isInExitQueue = true;
			npc.isExiting = false;

			// Добавляем сенсоры (скрытые по умолчанию)
			npc.sensors = {
				front: this.add.rectangle(0, 0, npcSensors.front.width, npcSensors.front.height, npcSensors.debugColor, npcSensors.debugAlpha)
					.setVisible(false)
					.setDepth(15),
				left: this.add.rectangle(0, 0, npcSensors.left.width, npcSensors.left.height, npcSensors.debugColor, npcSensors.debugAlpha)
					.setVisible(false)
					.setDepth(15),
				right: this.add.rectangle(0, 0, npcSensors.right.width, npcSensors.right.height, npcSensors.debugColor, npcSensors.debugAlpha)
					.setVisible(false)
					.setDepth(15)
			};

			// Добавляем в очередь выезда
			exitQueue.push(npc);

			// Задержка перед началом движения
			this.time.delayedCall(Phaser.Math.Between(3000, 5000), () => {
				if (!npc.isInExitQueue) {
					npc.isWaiting = false;
					moveNPCToNextPoint(npc);
				}
			});
			
			return npc;
		});

		// Запускаем обработчик очереди
		processExitQueue();
		
		// Добавляем обработчик клавиш для отладки
		this.input.keyboard.on('keydown-D', () => {
			showDebug = !showDebug;
			debugGraphics.clear();
			
			if (showDebug) {
				drawDebugColliders(this);
			}
			
			// Переключаем видимость сенсоров с учётом парковочной фазы
			npcs.forEach(npc => {
				if (!npc.sensors) return;
				
				const isParkingPhase = (
					npc.routeIndex < PARKING_PHASE_POINTS || 
					npc.routeIndex > npc.route.length - (PARKING_PHASE_POINTS + 1)
				);
				
				Object.values(npc.sensors).forEach(sensor => {
					sensor.visible = showDebug && !isParkingPhase;
				});
			});
		});
		
		this.input.keyboard.on('keydown-H', () => {
			if (showDebug) {
				showCollisionHighlights = !showCollisionHighlights;
				console.log(`Подсветка препятствий: ${showCollisionHighlights ? 'ВКЛ' : 'ВЫКЛ'}`);
			}
		});
	}

    function createCombinedCollider(scene) {
      // Создаем контейнер для всех коллайдеров
      combinedCollider = scene.add.container();
      
      // 1. Добавляем дороги
      const roads = [
        { x: 3 + 252/2, y: 893 + 216/2, width: 252, height: 216 },
        { x: 237 + 104/2, y: 236 + 1529/2, width: 140, height: 1529 },
		{ x: 1618 + 32 + 120/2, y: 237 + 1526/2, width: 120 + 64, height: 1526 },
        { x: 257 + 1485/2, y: 234 + 143/2, width: 1485, height: 143 },
        { x: 259 + 1479/2, y: 1622 - 40 + 141/2, width: 1479, height: 221 },
        { x: 257 + 1482/2, y: 872 - 40 + 252/2, width: 1482, height: 332 },
        { x: 887 + 203/2, y: 236 + 1528/2, width: 203, height: 1528 },
        { x: 259 + 1477/2, y: 579 - 42 + 94/2, width: 1477, height: 94 + 84 },
        { x: 259 + 1477/2, y: 1326 - 42 + 94/2, width: 1477, height: 94 + 84 }
      ];

      roads.forEach(road => {
        const { x, y } = scaleCoords(road.x, road.y, true);
        const roadRect = scene.add.rectangle(
          x, y,
          road.width * scaleFactor,
          road.height * scaleFactor,
          0x000000,
          0
        ).setOrigin(0.5);
        scene.physics.add.existing(roadRect, true);
        combinedCollider.add(roadRect);
      });

      // 2. Добавляем парковочные места
      allParkingSpots.forEach(spot => {
        const { x, y } = scaleCoords(spot.x, spot.y);
        const parkingSpot = scene.add.rectangle(
          x, y,
          parkingSpotWidth * scaleFactor,
          parkingSpotHeight * scaleFactor,
          0x000000,
          0
        ).setOrigin(0.5);
        scene.physics.add.existing(parkingSpot, true);
        combinedCollider.add(parkingSpot);
      });

      return combinedCollider;
    }

    function drawDebugColliders(scene) {
      debugGraphics.clear();
      
      // Рисуем все дороги зеленым
      debugGraphics.fillStyle(0x00ff00, 0.3);
      debugGraphics.lineStyle(2, 0x00ff00, 0.6);

      combinedCollider.each(collider => {
        // Все дороги (горизонтальные и вертикальные) - зеленые
        if (collider.width > 100 || collider.height > 100) { 
          debugGraphics.fillStyle(0x00ff00, 0.3);
          debugGraphics.lineStyle(2, 0x00ff00, 0.6);
        } 
        // Парковочные места - синие
        else { 
          debugGraphics.fillStyle(0x0000ff, 0.3);
          debugGraphics.lineStyle(2, 0x0000ff, 0.6);
        }
        
        debugGraphics.fillRect(
          collider.x - collider.width / 2,
          collider.y - collider.height / 2,
          collider.width,
          collider.height
        );
        debugGraphics.strokeRect(
          collider.x - collider.width / 2,
          collider.y - collider.height / 2,
          collider.width,
          collider.height
        );
      });
    }

    function update() {
      const scene = this;

      npcs.forEach(npc => {
        if (!npc || !npc.route || !npc.route[npc.routeIndex]) return;

        // Обновляем позиции сенсоров
        updateSensors(npc);

        // Проверка столкновений
        const collisions = checkCollisions(npc);
        
        // Обработка фронтальных столкновений
        if (collisions.length > 0 && !npc.isWaiting && !npc.isInExitQueue) {
          const frontCollision = collisions.find(c => c.sensor === 'front');
          if (frontCollision) {
            handleFrontCollision(npc, frontCollision);
          }
        }

        // Оригинальная логика движения
        if ((!npc.isWaiting && !npc.isInExitQueue) || npc.isExiting) {
          const target = npc.route[npc.routeIndex];
          if (!target || target.x === undefined || target.y === undefined) return;

          const distance = Phaser.Math.Distance.Between(npc.x, npc.y, target.x, target.y);

          if (distance < 5) {
            npc.routeIndex++;

            if (npc.routeIndex >= npc.route.length) {
              const originalPos = scaleCoords(npc.originalSpot.x, npc.originalSpot.y);
              
              const finalApproach = () => {
                const remainingDist = Phaser.Math.Distance.Between(npc.x, npc.y, originalPos.x, originalPos.y);
                
                if (remainingDist > 2) {
                  const angle = Phaser.Math.Angle.Between(npc.x, npc.y, originalPos.x, originalPos.y);
                  npc.setVelocity(
                    Math.cos(angle) * npcFinalApproachSpeed,
                    Math.sin(angle) * npcFinalApproachSpeed
                  );
                  
                  scene.time.delayedCall(50, finalApproach, [], scene);
                } else {
                  npc.x = originalPos.x;
                  npc.y = originalPos.y;
                  npc.setVelocity(0, 0);
                  
                  if (npc.isExiting) {
                    handleNpcExit.call(scene, npc);
                  } else {
                    handleNpcParking.call(scene, npc);
                  }
                }
              };
              
              finalApproach();
              return;
            }
            moveNPCToNextPoint(npc);
          }
        }
      });
    }

    function handleNpcExit(npc) {
      const scene = this;
      npc.isExiting = false;
      
      scene.time.delayedCall(Phaser.Math.Between(2000, 5000), () => {
        if (!npc.scene) return;
        
        npc.currentRouteIndex = (npc.currentRouteIndex + 1) % npc.routeSequence.length;
        const nextRouteType = npc.routeSequence[npc.currentRouteIndex];
        npc.route = nextRouteType(npc.originalSpot);
        npc.isCounterClockwise = nextRouteType.toString().includes('Counter');
        npc.hasPriority = PRIORITY_ROUTES.includes(npc.currentRouteIndex);
        npc.routeIndex = 0;
        npc.isWaiting = false;
        
        moveNPCToNextPoint(npc);
      });
    }

    function handleNpcParking(npc) {
      const scene = this;
      
      npc.currentRouteIndex = (npc.currentRouteIndex + 1) % npc.routeSequence.length;
      const nextRouteType = npc.routeSequence[npc.currentRouteIndex];
      npc.route = nextRouteType(npc.originalSpot);
      npc.isCounterClockwise = nextRouteType.toString().includes('Counter');
      npc.hasPriority = PRIORITY_ROUTES.includes(npc.currentRouteIndex);
      npc.routeIndex = 0;
      npc.isWaiting = true;

      if (allParkingSpots.some(spot => 
        Math.abs(spot.x - npc.originalSpot.x) < 10 && 
        Math.abs(spot.y - npc.originalSpot.y) < 10)) {
        npc.isInExitQueue = true;
        exitQueue.push(npc);
      } else {
        scene.time.delayedCall(Phaser.Math.Between(2000, 5000), () => {
          if (!npc.scene) return;
          npc.isWaiting = false;
          moveNPCToNextPoint(npc);
        });
      }
    }
    
    function moveNPCToNextPoint(npc) {
      // Управление видимостью сенсоров
      const isParkingPhase = (
        npc.routeIndex < PARKING_PHASE_POINTS || 
        npc.routeIndex > npc.route.length - (PARKING_PHASE_POINTS + 1)
      );
      
      if (npc.sensors) {
        Object.values(npc.sensors).forEach(s => {
          s.visible = showDebug && !isParkingPhase;
        });
      }

      // Логика движения
      if (!npc.route || !npc.route[npc.routeIndex]) return;

      const target = npc.route[npc.routeIndex];
      const angle = Phaser.Math.Angle.Between(npc.x, npc.y, target.x, target.y);
      let speed = npcSpeed; // Стандартная скорость по умолчанию

      // Определение фаз движения
      const isApproachPhase = npc.routeIndex >= npc.route.length - FINAL_APPROACH_POINTS;
      const isExitPhase = npc.isExiting && npc.routeIndex < EXIT_PHASE_POINTS;

      // Приоритеты: Парковка > Выезд > Обычное движение
      if (isApproachPhase) {
        speed = npcFinalApproachSpeed; // Медленная скорость при парковке
      } 
      else if (isExitPhase) {
        speed = npcExitSpeed; // Средняя скорость при выезде
      }

      npc.setVelocity(
        Math.cos(angle) * speed,
        Math.sin(angle) * speed
      );
      npc.rotation = angle + Math.PI/2;
    }

  </script>
</head>
<body>
  <div id="game-container"></div>
	<div class="debug-panel">
		Debug: Press 'D' to toggle colliders visualization<br>
		Press 'H' to toggle collision highlights (when debug is on)<br>
		Green - roads, Blue - parking spots<br>
		Red - NPC sensors (front/left/right)
	</div>
</body>
</html>