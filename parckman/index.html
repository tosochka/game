<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Parking Rush с эффектом аннигиляции</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #000;
    }
    #game-container {
      position: relative;
      display: block;
      max-width: 100%;
      max-height: 100%;
    }
    .debug-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      font-family: monospace;
      z-index: 100;
    }

  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>
    // Конфигурация NPC
    const npcSpeed = 80;
    const npcParkingSpeed = 30;
    const npcFinalApproachSpeed = 40;
    const npcExitSpeed = 20;
    const REVERSE_SPEED = 40;
    const MAX_REVERSE_TIME = 1;
    const REVERSE_CHECK_DELAY = 5000;
    const MAX_REVERSE_ATTEMPTS = 3;
    const SCENE_BOUNDS_PADDING = 50;
    const COLLISION_WAIT_TIME = 1700;
    const NO_REVERSE_WAIT_TIME = 2000;
    const PARKING_START_POINTS = 1;
    const PARKING_END_POINTS = 2;
    const FINAL_APPROACH_POINTS = 3;
    const EXIT_PHASE_POINTS = 3;
    const PARKING_EXIT_DELAY = 3500;
    const NPC_PER_ROW = 5;
    const MAX_NPC_PER_ROW = 5;
    const ROWS_COUNT = 8;
    const MAX_COLLISION_CHECKS = 3;

    // Конфигурация сенсоров
    const npcSensors = {
      front: { width: 25, height: 20, offset: 25, angle: 0 },
      frontLeft: { width: 0, height: 0, offset: 0, angle: Math.PI/4 },
      frontRight: { width: 0, height: 0, offset: 0, angle: -Math.PI/4 },
      left: { width: 0, height: 0, offset: 0, angle: Math.PI/2 },
      right: { width: 0, height: 0, offset: 0, angle: -Math.PI/2 },
      debugColor: 0xff0000,
      debugAlpha: 0.55
    };

    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 800,
      parent: 'game-container',
      scene: {
        preload: preload,
        create: create,
        update: update
      },
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 },
          debug: false
        }
      },
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
      }
    };

    const game = new Phaser.Game(config);
    let npcs = [];
    let lastExitTime = 0;
    let exitQueue = [];
    let debugGraphics;
    let showDebug = false;
    let showCollisionHighlights = true;
    let gameArea;
    let background;
    let decorativeLayer;
    
    // Парковочные места
    const upperLeftParkingSpots = [
      { x: 361, y: 380 }, { x: 454, y: 380 }, { x: 546, y: 380 }, { x: 641, y: 380 }, { x: 729, y: 380 }, { x: 823, y: 380 },
      { x: 361, y: 674 }, { x: 454, y: 674 }, { x: 546, y: 674 }, { x: 641, y: 674 }, { x: 729, y: 674 }, { x: 823, y: 674 },
      { x: 361, y: 1130 }, { x: 454, y: 1130 }, { x: 546, y: 1130 }, { x: 641, y: 1130 }, { x: 729, y: 1130 }, { x: 823, y: 1130 },
      { x: 361, y: 1420 }, { x: 454, y: 1420 }, { x: 546, y: 1420 }, { x: 641, y: 1420 }, { x: 729, y: 1420 }, { x: 823, y: 1420 }  
    ];
    
    const upperRightParkingSpots = [
      { x: 1094, y: 380 }, { x: 1189, y: 380 }, { x: 1279, y: 380 }, { x: 1371, y: 380 }, { x: 1462, y: 380 }, { x: 1555, y: 380 },
      { x: 1094, y: 674 }, { x: 1189, y: 674 }, { x: 1279, y: 674 }, { x: 1371, y: 674 }, { x: 1462, y: 674 }, { x: 1555, y: 674 },
      { x: 1094, y: 1130 }, { x: 1189, y: 1130 }, { x: 1279, y: 1130 }, { x: 1371, y: 1130 }, { x: 1462, y: 1130 }, { x: 1555, y: 1130 },
      { x: 1094, y: 1420 }, { x: 1189, y: 1420 }, { x: 1279, y: 1420 }, { x: 1371, y: 1420 }, { x: 1462, y: 1420 }, { x: 1555, y: 1420 }
    ];
    
    const allParkingSpots = [...upperLeftParkingSpots, ...upperRightParkingSpots];

    const npcOffset = 20;

    // Маршруты движения
    const allPossibleRoutes = [
      function clockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 690 - npcOffset, y: y - 37 }, { x: 690 - npcOffset, y: 665 - npcOffset },
          { x: 110 + npcOffset, y: 665 - npcOffset }, { x: 110 + npcOffset, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      function counterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 82 + npcOffset, y: y - 62 }, { x: 82 + npcOffset, y: 710 - npcOffset },
          { x: 725 - npcOffset, y: 710 - npcOffset }, { x: 725 - npcOffset, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      function leftBigHalfCounterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 82 + npcOffset, y: y - 62 }, { x: 82 + npcOffset, y: 710 - npcOffset },
          { x: 399, y: 710 - npcOffset }, { x: 399, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      function rightHalfClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 690 - npcOffset, y: y - 37 }, { x: 690 - npcOffset, y: 665 - npcOffset },
          { x: 420, y: 665 - npcOffset }, { x: 420, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
    ];

    // Система контроля границ
    const boundarySystem = {
      disabledNPCs: new Set(),
      checkInterval: 100,
      lastCheckTime: 0,
      
      init: function(scene) {
        this.scene = scene;
      },
      
      update: function(time) {
        if (time - this.lastCheckTime < this.checkInterval) return;
        this.lastCheckTime = time;
        
        npcs.forEach(npc => {
          if (this.disabledNPCs.has(npc)) return;
          
          if (isOutOfBounds(npc)) {
            this.disableNPC(npc);
          }
        });
      },
      
      disableNPC: function(npc) {
        this.scene.tweens.add({
          targets: npc,
          props: {
            alpha: 0.9
          },
          duration: 250,
          ease: 'Power2',
          onComplete: () => {
            npc.setVelocity(0, 0);
            npc.body.enable = false;
            this.disabledNPCs.add(npc);
            
            const index = exitQueue.indexOf(npc);
            if (index !== -1) {
              exitQueue.splice(index, 1);
            }
          }
        });
      },
      
      isNPCDisabled: function(npc) {
        return this.disabledNPCs.has(npc);
      }
    };

    function scaleCoords(x, y, isRoad = false) {
      const parkingSpotWidth = 59;
      const parkingSpotHeight = 85;
      const scaleFactor = 0.4;
      const offsetX = (parkingSpotWidth / 2) * scaleFactor;
      const offsetY = (parkingSpotHeight / 2) * scaleFactor;
      const roadOffsetX = -12;
      const roadOffsetY = -16;
      
      const scaledX = (x / 2000) * 800 + offsetX;
      const scaledY = (y / 2000) * 800 + offsetY;
      if (isRoad) return { x: scaledX + roadOffsetX, y: scaledY + roadOffsetY };
      return { x: scaledX, y: scaledY };
    }

    function createShuffledRouteSequence() {
      const routes = [...allPossibleRoutes];
      for (let i = routes.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [routes[i], routes[j]] = [routes[j], routes[i]];
      }
      return routes;
    }

    function getRandomSpotsInRow(row, count) {
      const spotsToSelect = Math.min(count, MAX_NPC_PER_ROW, row.length);
      const shuffled = [...row].sort(() => 0.5 - Math.random());
      return shuffled.slice(0, spotsToSelect);
    }

    function createGameArea(scene) {
      const gameArea = scene.add.container();
      
      const roads = [
        { x: 3 + 252/2, y: 893 + 216/2, width: 252, height: 216 },
        { x: 237 + 104/2, y: 236 + 1529/2, width: 140, height: 1529 },
        { x: 1618 + 32 + 120/2, y: 237 + 1526/2, width: 120 + 64, height: 1526 },
        { x: 257 + 1485/2, y: 234 + 143/2, width: 1485, height: 143 },
        { x: 259 + 1479/2, y: 1622 - 40 + 141/2, width: 1479, height: 221 },
        { x: 257 + 1482/2, y: 872 - 40 + 252/2, width: 1482, height: 332 },
        { x: 887 + 203/2, y: 236 + 1528/2, width: 203, height: 1528 },
        { x: 259 + 1477/2, y: 579 - 42 + 94/2, width: 1477, height: 94 + 84 },
        { x: 259 + 1477/2, y: 1326 - 42 + 94/2, width: 1477, height: 94 + 84 }
      ];

      roads.forEach(road => {
        const { x, y } = scaleCoords(road.x, road.y, true);
        const roadRect = scene.add.rectangle(
          x, y,
          road.width * 0.4,
          road.height * 0.4,
          0x333333, 
          0.0
        ).setOrigin(0.5);
        
        scene.physics.add.existing(roadRect, true);
        gameArea.add(roadRect);
      });

      allParkingSpots.forEach(spot => {
        const { x, y } = scaleCoords(spot.x, spot.y);
        const parkingSpot = scene.add.rectangle(
          x, y,
          59 * 0.4,
          85 * 0.4,
          0x555555,
          0.0
        ).setOrigin(0.5);
        
        scene.physics.add.existing(parkingSpot, true);
        gameArea.add(parkingSpot);
      });

      return gameArea;
    }

    function isOutOfBounds(npc) {
      let outOfBounds = true;
      gameArea.each(child => {
        if (Phaser.Geom.Intersects.RectangleToRectangle(
          npc.getBounds(),
          child.getBounds()
        )) {
          outOfBounds = false;
        }
      });
      return outOfBounds;
    }

    function returnToSafePosition(npc) {
      let safeIndex = npc.routeIndex;
      while (safeIndex >= 0) {
        const point = npc.route[safeIndex];
        if (!isOutOfBounds({x: point.x, y: point.y, getBounds: () => new Phaser.Geom.Rectangle(point.x-5, point.y-5, 10, 10)})) {
          break;
        }
        safeIndex--;
      }
      
      if (safeIndex >= 0) {
        npc.routeIndex = safeIndex;
        npc.x = npc.route[safeIndex].x;
        npc.y = npc.route[safeIndex].y;
        npc.setVelocity(0, 0);
        npc.isReversing = false;
        npc.isWaiting = false;
        moveNPCToNextPoint(npc);
      } else {
        const {x, y} = scaleCoords(npc.originalSpot.x, npc.originalSpot.y);
        npc.x = x;
        npc.y = y;
        npc.routeIndex = 0;
        npc.setVelocity(0, 0);
        npc.isReversing = false;
        npc.isWaiting = true;
        npc.scene.time.delayedCall(2000, () => {
          npc.isWaiting = false;
          moveNPCToNextPoint(npc);
        });
      }
    }

    function createSensors(scene, npc) {
      if (npc.sensors) {
        Object.values(npc.sensors).forEach(sensor => sensor.destroy());
      }

      npc.sensors = {
        front: createSensorRect(scene, npcSensors.front),
        frontLeft: createSensorRect(scene, npcSensors.frontLeft),
        frontRight: createSensorRect(scene, npcSensors.frontRight),
        left: createSensorRect(scene, npcSensors.left),
        right: createSensorRect(scene, npcSensors.right)
      };
    }

    function createSensorRect(scene, config) {
      return scene.add.rectangle(
        0, 0, 
        config.width, 
        config.height, 
        npcSensors.debugColor, 
        npcSensors.debugAlpha
      ).setVisible(false);
    }

    function updateSensors(npc) {
      if (!npc.sensors || npc.routeIndex < PARKING_START_POINTS || 
          npc.routeIndex > npc.route.length - (PARKING_END_POINTS + 1)) {
        return;
      }

      const rotation = npc.rotation - Math.PI/2;
      
      Object.keys(npc.sensors).forEach(key => {
        const sensor = npc.sensors[key];
        const config = npcSensors[key];
        
        sensor.x = npc.x + Math.cos(rotation + config.angle) * config.offset;
        sensor.y = npc.y + Math.sin(rotation + config.angle) * config.offset;
        sensor.rotation = rotation + config.angle;
        sensor.visible = showDebug && !npc.isReversing;
      });
    }

    function checkSensors(npc) {
      if (!npc.sensors || 
          npc.routeIndex < PARKING_START_POINTS || 
          npc.routeIndex > npc.route.length - (PARKING_END_POINTS + 1) ||
          npc.isReversing) {
        return [];
      }

      const collisions = [];
      const otherNpcs = npcs.filter(n => n !== npc && n.active);
      
      otherNpcs.forEach(other => {
        Object.entries(npc.sensors).forEach(([sensorName, sensor]) => {
          if (Phaser.Geom.Intersects.RectangleToRectangle(
            sensor.getBounds(),
            other.getBounds()
          )) {
            collisions.push({
              npc: other,
              sensor: sensorName,
              distance: Phaser.Math.Distance.Between(npc.x, npc.y, other.x, other.y)
            });

            if (sensorName === 'front' && !npc.isWaiting) {
              handleFrontCollision(npc, {npc: other, sensor: 'front'});
            }
          }
        });
      });
      
      return collisions;
    }

    function handleFrontCollision(npc, collision) {
      if (npc.isWaiting || npc.isReversing || npc.isAvoiding) return;
      
      npc.preCollisionSpeed = npc.body.velocity.clone();
      npc.setVelocity(0, 0);
      npc.isWaiting = true;
      npc.collisionCheckAttempts = 0;
      npc.otherNpc = collision.npc;
      
      const recheckCollision = () => {
        if (!npc.scene || !npc.active) return;
        
        npc.collisionCheckAttempts++;
        const newCollisions = checkSensors(npc);
        const stillBlocked = newCollisions.some(c => c.npc === npc.otherNpc);
        
        if (!stillBlocked) {
          // Препятствие исчезло - продолжаем движение
          npc.isWaiting = false;
          if (npc.preCollisionSpeed) {
            npc.setVelocity(npc.preCollisionSpeed.x, npc.preCollisionSpeed.y);
          } else {
            moveNPCToNextPoint(npc);
          }
        } 
        else if (npc.collisionCheckAttempts >= MAX_COLLISION_CHECKS) {
          // После N проверок - решаем судьбу NPC
          resolveDeadlock(npc, npc.otherNpc);
        } 
        else {
          // Повторная проверка через 1.7 секунды
          npc.scene.time.delayedCall(COLLISION_WAIT_TIME, recheckCollision);
        }
      };
      
      // Первая проверка через 1.7 секунды
      npc.scene.time.delayedCall(COLLISION_WAIT_TIME, recheckCollision);
    }
	
	function resolveDeadlock(npc1, npc2) {
		// Выбираем случайный NPC для аннигиляции
		const npcToRemove = Math.random() > 0.5 ? npc1 : npc2;
		const survivingNpc = npcToRemove === npc1 ? npc2 : npc1;

		// Создаем эффект аннигиляции
		createAnnihilationEffect(npcToRemove.scene, npcToRemove);

		// Удаляем NPC из игры
		npcToRemove.destroy();

		// Обновляем массивы
		npcs = npcs.filter(n => n !== npcToRemove);
		exitQueue = exitQueue.filter(n => n !== npcToRemove);

		// Восстанавливаем движение второго NPC
		if (survivingNpc.active && survivingNpc.preCollisionSpeed) {
			survivingNpc.isWaiting = false;
			survivingNpc.setVelocity(
				survivingNpc.preCollisionSpeed.x,
				survivingNpc.preCollisionSpeed.y
			);
			survivingNpc.preCollisionSpeed = null;
		}
	}	

	function createAnnihilationEffect(scene, npc) {
		// 1. Основной круг взрыва
		const explosion = scene.add.graphics()
			.fillStyle(0xFF4500, 1)
			.fillCircle(0, 0, 25)
			.setPosition(npc.x, npc.y)
			.setDepth(25);

		// 2. Анимация расширения
		scene.tweens.add({
			targets: explosion,
			scaleX: 3,
			scaleY: 3,
			alpha: 0,
			duration: 500,
			ease: 'Back.easeOut',
			onComplete: () => explosion.destroy()
		});

		// 3. Частицы (если атлас загружен)
		if (scene.textures.exists('flares')) {
			const particles = scene.add.particles('flares');
			const emitter = particles.createEmitter({
				frame: ['red', 'yellow', 'orange'],
				x: npc.x,
				y: npc.y,
				speed: { min: -200, max: 200 },
				scale: { start: 0.6, end: 0 },
				blendMode: 'ADD',
				lifespan: 900,
				quantity: 25,
				rotate: { start: 0, end: 360 }
			});

			scene.time.delayedCall(700, () => particles.destroy());
		}

		// 4. Тряска камеры
		if (scene.cameras && scene.cameras.main) {
			scene.cameras.main.shake(85, 0.005); // Длительность в ms, Сила тряски (0-1)
		}
	}


    function avoidObstacle(npc, obstacle) {
      if (npc.isAvoiding || npc.isReversing || !npc.route || !npc.route[npc.routeIndex]) return;
      
      npc.isAvoiding = true;
      npc.preAvoidState = {
        velocity: npc.body.velocity.clone(),
        routeIndex: npc.routeIndex,
        target: {...npc.route[npc.routeIndex]}
      };
      
      let avoidAngle;
      if (obstacle.sensor === 'left') {
        avoidAngle = npc.rotation - Math.PI/4;
      } else if (obstacle.sensor === 'right') {
        avoidAngle = npc.rotation + Math.PI/4;
      } else {
        avoidAngle = npc.rotation + (Math.random() > 0.5 ? Math.PI/4 : -Math.PI/4);
      }
      
      const avoidSpeed = npcSpeed * 0.7;
      npc.setVelocity(
        Math.cos(avoidAngle - Math.PI/2) * avoidSpeed,
        Math.sin(avoidAngle - Math.PI/2) * avoidSpeed
      );
      
      const boundsCheck = () => {
        if (!npc.active) return;
        
        if (isOutOfBounds(npc)) {
          npc.isAvoiding = false;
          returnToSafePosition(npc);
          return;
        }
        
        if (npc.isAvoiding) {
          npc.scene.time.delayedCall(100, boundsCheck, [], npc.scene);
        }
      };
      
      boundsCheck();
      
      npc.scene.time.delayedCall(500, () => {
        if (npc.active && npc.isAvoiding) {
          npc.isAvoiding = false;
          
          if (npc.preAvoidState && npc.route && npc.route[npc.routeIndex]) {
            const target = npc.route[npc.routeIndex];
            const angle = Phaser.Math.Angle.Between(npc.x, npc.y, target.x, target.y);
            
            let speed;
            const isExitPhase = npc.isExiting && npc.routeIndex < EXIT_PHASE_POINTS;
            const isApproachPhase = npc.routeIndex >= npc.route.length - FINAL_APPROACH_POINTS;
            
            if (isExitPhase) {
              speed = npcExitSpeed;
            } else if (isApproachPhase) {
              speed = npcFinalApproachSpeed;
            } else {
              speed = npcSpeed;
            }
            
            npc.setVelocity(
              Math.cos(angle) * speed,
              Math.sin(angle) * speed
            );
            npc.rotation = angle + Math.PI/2;
          }
        }
      });
    }

    function moveNPCToNextPoint(npc) {
      const isParkingPhase = (
        npc.routeIndex < PARKING_START_POINTS || 
        npc.routeIndex > npc.route.length - (PARKING_END_POINTS + 1)
      );

      if (npc.sensors) {
        Object.values(npc.sensors).forEach(s => {
          s.visible = showDebug && !isParkingPhase && !npc.isReversing;
        });
      }

      const target = npc.route[npc.routeIndex];
      const angle = Phaser.Math.Angle.Between(npc.x, npc.y, target.x, target.y);
      
      let speed;
      if (npc.isExiting && npc.routeIndex < EXIT_PHASE_POINTS) {
        speed = npcExitSpeed;
      } else if (npc.routeIndex >= npc.route.length - FINAL_APPROACH_POINTS) {
        speed = npcFinalApproachSpeed;
      } else if (npc.isReversing) {
        speed = REVERSE_SPEED;
      } else {
        speed = npcSpeed;
      }

      npc.setVelocity(
        Math.cos(angle) * speed,
        Math.sin(angle) * speed
      );
      npc.rotation = angle + Math.PI/2;
    }

    function handleRouteCompletion(npc) {
      const originalPos = scaleCoords(npc.originalSpot.x, npc.originalSpot.y);
      
      const finalApproach = () => {
        const distance = Phaser.Math.Distance.Between(npc.x, npc.y, originalPos.x, originalPos.y);
        
        if (distance > 2) {
          const angle = Phaser.Math.Angle.Between(npc.x, npc.y, originalPos.x, originalPos.y);
          npc.setVelocity(
            Math.cos(angle) * npcFinalApproachSpeed,
            Math.sin(angle) * npcFinalApproachSpeed
          );
          npc.rotation = angle + Math.PI/2;
          
          npc.scene.time.delayedCall(50, finalApproach);
        } else {
          npc.setVelocity(0, 0);
          npc.x = originalPos.x;
          npc.y = originalPos.y;
          
          npc.isExiting = false;
          npc.isInExitQueue = true;
          exitQueue.push(npc);
        }
      };

      finalApproach();
    }

    function processExitQueue() {
      if (exitQueue.length === 0 || Date.now() - lastExitTime < PARKING_EXIT_DELAY) {
        game.scene.scenes[0].time.delayedCall(300, processExitQueue, [], game.scene.scenes[0]);
        return;
      }

      const nextNpc = exitQueue.shift();
      if (!nextNpc.active || nextNpc.isDestroyed) {
        game.scene.scenes[0].time.delayedCall(100, processExitQueue, [], game.scene.scenes[0]);
        return;
      }

      if (nextNpc.body.velocity.length() > 5) {
        exitQueue.push(nextNpc);
        game.scene.scenes[0].time.delayedCall(300, processExitQueue, [], game.scene.scenes[0]);
        return;
      }

      lastExitTime = Date.now();
      nextNpc.isInExitQueue = false;
      
      const delay = Phaser.Math.Between(100, 500);
      nextNpc.scene.time.delayedCall(delay, () => {
        if (nextNpc.active) {
          startNpcExit(nextNpc);
        }
      });

      game.scene.scenes[0].time.delayedCall(300, processExitQueue, [], game.scene.scenes[0]);
    }

    function startNpcExit(npc) {
      if (!npc.active || npc.isDestroyed) return;

      npc.isExiting = true;
      npc.isInExitQueue = false;
      npc.isWaiting = false;
      
      const randomRouteIndex = Math.floor(Math.random() * allPossibleRoutes.length);
      const routeType = allPossibleRoutes[randomRouteIndex];
      npc.route = routeType(npc.originalSpot);
      npc.isCounterClockwise = routeType.toString().includes('Counter');
      npc.routeIndex = 0;
      npc.lastExitTime = Date.now();
      
      moveNPCToNextPoint(npc);
    }

    function preload() {
      // Оригинальные изображения из исходного кода
      this.load.image('background', 'assets/parking_map.png');
      this.load.image('npcCar', 'assets/npc_car.png');
      this.load.image('entrance', 'assets/entrance.png');
      this.load.image('pavilion', 'assets/pavilion.png');
      this.load.image('grass1', 'assets/grass1.png');
      this.load.image('tree1', 'assets/tree1.png');
      this.load.image('tree2', 'assets/tree2.png');
      this.load.image('bush1', 'assets/bush1.png');
      this.load.image('oil', 'assets/oil.png');
      this.load.image('lamp_top', 'assets/lamp_top.png');
      this.load.image('lamp_bottom', 'assets/lamp_bottom.png');
	  this.load.atlas('flares', 'assets/particles/flares.png', 'assets/particles/flares.json');
    }

    function createEntranceAndPavilion(scene) {
      const { x: entranceX, y: entranceY } = scaleCoords(3 + 252/2, 893 + 216/2, true);
      const entrance = scene.add.image(entranceX, entranceY, 'entrance').setScale(0.5);
      entrance.setDepth(1);

      const { x: pavilionX, y: pavilionY } = scaleCoords(700, 100);
      const pavilion = scene.add.image(pavilionX, pavilionY, 'pavilion').setScale(0.5);
      pavilion.setDepth(1);
    }

    function createDecorativeLayer(scene) {
      const grassOffsetX = 0, grassOffsetY = 20;
      const treeOffsetX = 45, treeOffsetY = 35;
      const bushOffsetX = 35, bushOffsetY = 25;
      const oilOffsetX = 15, oilOffsetY = 23;

      const lampTopCoords = scaleCoords(850+90, 223+170);
      const lampBottomCoords = scaleCoords(854+90, 1650-140);
      const grass1Coords = scaleCoords(661 + grassOffsetX, 89 + grassOffsetY);
      const tree1Coords = scaleCoords(1635 + treeOffsetX, 127 + treeOffsetY);
      const tree2Coords = scaleCoords(100 + 10, 900 - 300);
      const bush1Coords = scaleCoords(1716 + bushOffsetX, 298 + bushOffsetY);
      const oilCoords = scaleCoords(25 + oilOffsetX, 938 + oilOffsetY);

      const lampTop = scene.add.image(lampTopCoords.x, lampTopCoords.y, 'lamp_top').setScale(0.5);
      const lampBottom = scene.add.image(lampBottomCoords.x, lampBottomCoords.y, 'lamp_bottom').setScale(0.5);
      const grass1 = scene.add.image(grass1Coords.x, grass1Coords.y, 'grass1').setScale(0.5);
      const tree1 = scene.add.image(tree1Coords.x, tree1Coords.y, 'tree1').setScale(0.5);
      const tree2 = scene.add.image(tree2Coords.x, tree2Coords.y, 'tree2').setScale(0.4);
      const bush1 = scene.add.image(bush1Coords.x, bush1Coords.y, 'bush1').setScale(0.5);
      const oil = scene.add.image(oilCoords.x, oilCoords.y, 'oil').setScale(0.5);

      lampTop.setDepth(11);
      lampBottom.setDepth(11);
      grass1.setDepth(2);
      tree1.setDepth(10);
      tree2.setDepth(10);
      bush1.setDepth(10);
      oil.setDepth(2);
    }

	function create() {
		const scene = this;
		
		// Инициализация системы границ
		boundarySystem.init(scene);
		
		// Создаем фон
		background = scene.add.image(400, 400, 'background').setDepth(0);
		background.setDisplaySize(800, 800);

		// Создаем игровую зону
		gameArea = createGameArea(scene);

		// Настройка отладки
		debugGraphics = scene.add.graphics();
		debugGraphics.setDepth(20);

		// Инициализация рядов парковочных мест
		const leftRows = [
			upperLeftParkingSpots.slice(0, 6),
			upperLeftParkingSpots.slice(6, 12),
			upperLeftParkingSpots.slice(12, 18),
			upperLeftParkingSpots.slice(18, 24)
		];

		const rightRows = [
			upperRightParkingSpots.slice(0, 6),
			upperRightParkingSpots.slice(6, 12),
			upperRightParkingSpots.slice(12, 18),
			upperRightParkingSpots.slice(18, 24)
		];

		// Очищаем массивы
		npcs = [];
		exitQueue = [];
		lastExitTime = 0;

		// Создаем NPC
		const allRows = [...leftRows, ...rightRows];
		allRows.forEach(row => {
			const selectedSpots = getRandomSpotsInRow(row, NPC_PER_ROW);
			selectedSpots.forEach(spot => {
				const npc = scene.physics.add.sprite(
					scaleCoords(spot.x, spot.y).x,
					scaleCoords(spot.x, spot.y).y,
					'npcCar'
				)
				.setScale(0.47)
				.setDepth(3)
				.setCollideWorldBounds(false);

				// Настройка физического тела
				npc.body.setSize(25, 45);
				npc.body.setOffset(0, 5);

				createSensors(scene, npc);

				npc.originalSpot = spot;
				npc.routeSequence = createShuffledRouteSequence();
				npc.currentRouteIndex = 0;
				npc.route = npc.routeSequence[0](npc.originalSpot);
				npc.isCounterClockwise = npc.routeSequence[0].toString().includes('Counter');
				npc.routeIndex = 0;
				npc.isWaiting = true;
				npc.isInExitQueue = true;
				npc.isExiting = false;
				npc.isReversing = false;
				npc.isAvoiding = false;
				npc.reverseAttempts = 0;
				npc.lastExitTime = 0;
				npc.collisionCheckAttempts = 0;

				npcs.push(npc);
				exitQueue.push(npc);
			});
		});

		// Система overlap с мягким отталкиванием
		scene.physics.add.overlap(
			npcs,
			npcs,
			(npc1, npc2) => {
				if (npc1 === npc2 || !npc1.active || !npc2.active) return;

				// Мягкое отталкивание
				const angle = Phaser.Math.Angle.Between(npc1.x, npc1.y, npc2.x, npc2.y);
				const distance = Phaser.Math.Distance.Between(npc1.x, npc1.y, npc2.x, npc2.y);
				const minDistance = 5;
				
				if (distance < minDistance) {
					const pushForce = 0.5 * (minDistance - distance);
					const pushX = Math.cos(angle) * pushForce;
					const pushY = Math.sin(angle) * pushForce;
					
					npc1.body.velocity.x += pushX;
					npc1.body.velocity.y += pushY;
					npc2.body.velocity.x -= pushX;
					npc2.body.velocity.y -= pushY;
				}

				// Проверка сенсоров
				if (npc1.isAvoiding || npc2.isAvoiding) return;

				const avoidingNpc = Math.random() > 0.5 ? npc1 : npc2;
				const otherNpc = avoidingNpc === npc1 ? npc2 : npc1;
				
				const sensorCollisions = checkSensors(avoidingNpc);
				const leftCollision = sensorCollisions.find(c => c.sensor === 'left' && c.npc === otherNpc);
				const rightCollision = sensorCollisions.find(c => c.sensor === 'right' && c.npc === otherNpc);
				
				if (leftCollision) {
					avoidObstacle(avoidingNpc, leftCollision);
				} else if (rightCollision) {
					avoidObstacle(avoidingNpc, rightCollision);
				} else if (sensorCollisions.some(c => c.sensor === 'front')) {
					avoidObstacle(avoidingNpc, { sensor: 'front' });
				}
			},
			null,
			this
		);

		// Коллайдеры с другими объектами
		scene.physics.add.collider(npcs, gameArea);

		// Запуск обработчика очереди выезда
		processExitQueue();

		// Создаем декорации
		createEntranceAndPavilion(scene);
		createDecorativeLayer(scene);

		// Тестовая кнопка (клавиша E)
		scene.input.keyboard.on('keydown-E', () => {
			if (npcs.length > 0) {
				const randomNpc = npcs[Phaser.Math.Between(0, npcs.length - 1)];
				createAnnihilationEffect(scene, randomNpc);
				
				// Для теста: удаляем NPC через 0.5с
				scene.time.delayedCall(500, () => {
					randomNpc.destroy();
					npcs = npcs.filter(n => n !== randomNpc);
				});
			}
		});

		// Настройка клавиш отладки
		scene.input.keyboard.on('keydown-D', () => {
			showDebug = !showDebug;
			debugGraphics.clear();
			
			if (showDebug) {
				gameArea.each(child => {
					debugGraphics.fillStyle(0x00ff00, 0.3);
					debugGraphics.lineStyle(2, 0x00ff00, 0.6);
					debugGraphics.fillRect(
						child.x - child.width/2,
						child.y - child.height/2,
						child.width,
						child.height
					);
					debugGraphics.strokeRect(
						child.x - child.width/2,
						child.y - child.height/2,
						child.width,
						child.height
					);
				});
			}
		});

		scene.input.keyboard.on('keydown-H', () => {
			if (showDebug) {
				showCollisionHighlights = !showCollisionHighlights;
				console.log(`Подсветка препятствий: ${showCollisionHighlights ? 'ВКЛ' : 'ВЫКЛ'}`);
			}
		});
	}

    function update() {
      boundarySystem.update(this.time.now);
      
      npcs.forEach(npc => {
        if (boundarySystem.isNPCDisabled(npc)) return;
        if (!npc.active || !npc.route || !npc.route[npc.routeIndex]) return;

        updateSensors(npc);
        
        if (npc.isReversing || npc.isAvoiding || npc.isWaiting) return;

        const collisions = checkSensors(npc);

        const target = npc.route[npc.routeIndex];
        const distance = Phaser.Math.Distance.Between(npc.x, npc.y, target.x, target.y);

        if (distance < 5) {
          npc.routeIndex++;
          if (npc.routeIndex >= npc.route.length) {
            handleRouteCompletion(npc);
            return;
          }
          moveNPCToNextPoint(npc);
        }
      });
    }
  </script>
</head>
<body>
  <div id="game-container"></div>
  <div class="debug-panel">
    Debug: Нажмите 'D' для отображения границ дорог<br>
    Нажмите 'H' для переключения подсветки столкновений (когда debug включен)<br>
    Зеленые зоны - физические коллайдеры, по которым могут двигаться NPC
  </div>
</body>
</html>