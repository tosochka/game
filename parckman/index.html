<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Parking Rush с эффектом аннигиляции</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #000;
      touch-action: none;
    }
    #game-container {
      position: relative;
      display: block;
      max-width: 100%;
      max-height: 100%;
    }
    .debug-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      font-family: monospace;
      z-index: 100;
    }
	
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>
  
	const WORLD_BOUNDS = {
	  left: 0,
	  right: 800,
	  top: 0,
	  bottom: 800,
	  padding: 75 // Зона предварительного торможения
	};  
  
    // Конфигурация NPC
    const npcSpeed = 80;
    const npcParkingSpeed = 30;
    const npcFinalApproachSpeed = 40;
    const npcExitSpeed = 20;
    const REVERSE_SPEED = 40;
    const MAX_REVERSE_TIME = 1;
    const REVERSE_CHECK_DELAY = 5000;
    const MAX_REVERSE_ATTEMPTS = 3;
    const SCENE_BOUNDS_PADDING = 50;
    const COLLISION_WAIT_TIME = 1700;
    const NO_REVERSE_WAIT_TIME = 2000;
    const PARKING_START_POINTS = 1;
    const PARKING_END_POINTS = 2;
    const FINAL_APPROACH_POINTS = 3;
    const EXIT_PHASE_POINTS = 3;
    const PARKING_EXIT_DELAY = 1700; // от 3000 до 1500
    const NPC_PER_ROW = 3; // от 3 до 5
    const MAX_NPC_PER_ROW = 5;
    const ROWS_COUNT = 8;
    const MAX_COLLISION_CHECKS = 3;

    // Конфигурация сенсоров
    const npcSensors = {
      front: { width: 27, height: 20, offset: 27, angle: 0 },
      frontLeft: { width: 0, height: 0, offset: 0, angle: Math.PI/4 },
      frontRight: { width: 0, height: 0, offset: 0, angle: -Math.PI/4 },
      left: { width: 0, height: 0, offset: 0, angle: Math.PI/2 },
      right: { width: 0, height: 0, offset: 0, angle: -Math.PI/2 },
      debugColor: 0xff0000,
      debugAlpha: 0.55
    };

    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 800,
      parent: 'game-container',
      scene: {
        preload: preload,
        create: create,
        update: update
      },
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 },
          debug: false
        }
      },
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
      }
    };

    const game = new Phaser.Game(config);
    let npcs = [];
    let lastExitTime = 0;
    let exitQueue = [];
    let debugGraphics;
    let showDebug = false;
    let showCollisionHighlights = true;
    let gameArea;
    let background;
    let decorativeLayer;
    
    // Новые переменные для системы камеры
    let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    let cameraTarget;
    let currentTarget;
    let mapWidth = 1600;
    let mapHeight = 1600;
    
    // Парковочные места
    const upperLeftParkingSpots = [
      { x: 361, y: 380 }, { x: 454, y: 380 }, { x: 546, y: 380 }, { x: 641, y: 380 }, { x: 729, y: 380 }, { x: 823, y: 380 },
      { x: 361, y: 674 }, { x: 454, y: 674 }, { x: 546, y: 674 }, { x: 641, y: 674 }, { x: 729, y: 674 }, { x: 823, y: 674 },
      { x: 361, y: 1130 }, { x: 454, y: 1130 }, { x: 546, y: 1130 }, { x: 641, y: 1130 }, { x: 729, y: 1130 }, { x: 823, y: 1130 },
      { x: 361, y: 1420 }, { x: 454, y: 1420 }, { x: 546, y: 1420 }, { x: 641, y: 1420 }, { x: 729, y: 1420 }, { x: 823, y: 1420 }  
    ];
    
    const upperRightParkingSpots = [
      { x: 1094, y: 380 }, { x: 1189, y: 380 }, { x: 1279, y: 380 }, { x: 1371, y: 380 }, { x: 1462, y: 380 }, { x: 1555, y: 380 },
      { x: 1094, y: 674 }, { x: 1189, y: 674 }, { x: 1279, y: 674 }, { x: 1371, y: 674 }, { x: 1462, y: 674 }, { x: 1555, y: 674 },
      { x: 1094, y: 1130 }, { x: 1189, y: 1130 }, { x: 1279, y: 1130 }, { x: 1371, y: 1130 }, { x: 1462, y: 1130 }, { x: 1555, y: 1130 },
      { x: 1094, y: 1420 }, { x: 1189, y: 1420 }, { x: 1279, y: 1420 }, { x: 1371, y: 1420 }, { x: 1462, y: 1420 }, { x: 1555, y: 1420 }
    ];
    
    const allParkingSpots = [...upperLeftParkingSpots, ...upperRightParkingSpots];

    const npcOffset = 20;

    // Маршруты движения
    const allPossibleRoutes = [
      function clockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 690 - npcOffset, y: y - 37 }, { x: 690 - npcOffset, y: 665 - npcOffset },
          { x: 110 + npcOffset, y: 665 - npcOffset }, { x: 110 + npcOffset, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      function counterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 82 + npcOffset, y: y - 62 }, { x: 82 + npcOffset, y: 710 - npcOffset },
          { x: 725 - npcOffset, y: 710 - npcOffset }, { x: 725 - npcOffset, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      function leftBigHalfCounterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 82 + npcOffset, y: y - 62 }, { x: 82 + npcOffset, y: 710 - npcOffset },
          { x: 399, y: 710 - npcOffset }, { x: 399, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      function rightHalfClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 690 - npcOffset, y: y - 37 }, { x: 690 - npcOffset, y: 665 - npcOffset },
          { x: 420, y: 665 - npcOffset }, { x: 420, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      }
    ];

    function getRandomCarTexture() {
      const models = ['sedan', 'suv', 'hatchback', 'coupe', 'van'];
      const colors = ['red', 'blue', 'green', 'yellow', 'black'];
      return `car_${Phaser.Math.RND.pick(models)}_${Phaser.Math.RND.pick(colors)}`;
    }

    function scaleCoords(x, y, isRoad = false) {
      const parkingSpotWidth = 59;
      const parkingSpotHeight = 85;
      const scaleFactor = 0.4;
      const offsetX = (parkingSpotWidth / 2) * scaleFactor;
      const offsetY = (parkingSpotHeight / 2) * scaleFactor;
      const roadOffsetX = -12;
      const roadOffsetY = -16;
      
      const scaledX = (x / 2000) * 800 + offsetX;
      const scaledY = (y / 2000) * 800 + offsetY;
      if (isRoad) return { x: scaledX + roadOffsetX, y: scaledY + roadOffsetY };
      return { x: scaledX, y: scaledY };
    }

    function createShuffledRouteSequence() {
      const routes = [...allPossibleRoutes];
      for (let i = routes.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [routes[i], routes[j]] = [routes[j], routes[i]];
      }
      return routes;
    }

    function getRandomSpotsInRow(row, count) {
      const spotsToSelect = Math.min(count, MAX_NPC_PER_ROW, row.length);
      const shuffled = [...row].sort(() => 0.5 - Math.random());
      return shuffled.slice(0, spotsToSelect);
    }

    function createGameArea(scene) {
      const gameArea = scene.add.container();
      
      const roads = [
        { x: 3 + 252/2, y: 893 + 216/2, width: 252, height: 216 },
        { x: 237 + 104/2, y: 236 + 1529/2, width: 140, height: 1529 },
        { x: 1618 + 32 + 120/2, y: 237 + 1526/2, width: 120 + 64, height: 1526 },
        { x: 257 + 1485/2, y: 234 + 143/2, width: 1485, height: 143 },
        { x: 259 + 1479/2, y: 1622 - 40 + 141/2, width: 1479, height: 221 },
        { x: 257 + 1482/2, y: 872 - 40 + 252/2, width: 1482, height: 332 },
        { x: 887 + 203/2, y: 236 + 1528/2, width: 203, height: 1528 },
        { x: 259 + 1477/2, y: 579 - 42 + 94/2, width: 1477, height: 94 + 84 },
        { x: 259 + 1477/2, y: 1326 - 42 + 94/2, width: 1477, height: 94 + 84 }
      ];

      roads.forEach(road => {
        const { x, y } = scaleCoords(road.x, road.y, true);
        const roadRect = scene.add.rectangle(
          x, y,
          road.width * 0.4,
          road.height * 0.4,
          0x333333, 
          0.0
        ).setOrigin(0.5);
        
        scene.physics.add.existing(roadRect, true);
        gameArea.add(roadRect);
      });

      allParkingSpots.forEach(spot => {
        const { x, y } = scaleCoords(spot.x, spot.y);
        const parkingSpot = scene.add.rectangle(
          x, y,
          59 * 0.4,
          85 * 0.4,
          0x555555,
          0.0
        ).setOrigin(0.5);
        
        scene.physics.add.existing(parkingSpot, true);
        gameArea.add(parkingSpot);
      });

      return gameArea;
    }

    function isOutOfBounds(npc) {
      let outOfBounds = true;
      gameArea.each(child => {
        if (Phaser.Geom.Intersects.RectangleToRectangle(
          npc.getBounds(),
          child.getBounds()
        )) {
          outOfBounds = false;
        }
      });
      return outOfBounds;
    }

    function returnToSafePosition(npc) {
      let safeIndex = npc.routeIndex;
      while (safeIndex >= 0) {
        const point = npc.route[safeIndex];
        if (!isOutOfBounds({x: point.x, y: point.y, getBounds: () => new Phaser.Geom.Rectangle(point.x-5, point.y-5, 10, 10)})) {
          break;
        }
        safeIndex--;
      }
      
      if (safeIndex >= 0) {
        npc.routeIndex = safeIndex;
        npc.x = npc.route[safeIndex].x;
        npc.y = npc.route[safeIndex].y;
        npc.setVelocity(0, 0);
        npc.isReversing = false;
        npc.isWaiting = false;
        moveNPCToNextPoint(npc);
      } else {
        const {x, y} = scaleCoords(npc.originalSpot.x, npc.originalSpot.y);
        npc.x = x;
        npc.y = y;
        npc.routeIndex = 0;
        npc.setVelocity(0, 0);
        npc.isReversing = false;
        npc.isWaiting = true;
        npc.scene.time.delayedCall(2000, () => {
          npc.isWaiting = false;
          moveNPCToNextPoint(npc);
        });
      }
    }

    function createSensors(scene, npc) {
      if (npc.sensors) {
        Object.values(npc.sensors).forEach(sensor => sensor.destroy());
      }

      const sensorDepth = npc.depth + 1;

      npc.sensors = {
        front: createSensorRect(scene, npcSensors.front)
          .setDepth(sensorDepth)
          .setVisible(false),
        frontLeft: createSensorRect(scene, npcSensors.frontLeft)
          .setDepth(sensorDepth)
          .setVisible(false),
        frontRight: createSensorRect(scene, npcSensors.frontRight)
          .setDepth(sensorDepth)
          .setVisible(false),
        left: createSensorRect(scene, npcSensors.left)
          .setDepth(sensorDepth)
          .setVisible(false),
        right: createSensorRect(scene, npcSensors.right)
          .setDepth(sensorDepth)
          .setVisible(false)
      };

      if (showDebug) {
        npc.sensors.front.setFillStyle(0xFF0000);
        npc.sensors.frontLeft.setFillStyle(0x00FF00);
        npc.sensors.frontRight.setFillStyle(0x0000FF);
        npc.sensors.left.setFillStyle(0xFFFF00);
        npc.sensors.right.setFillStyle(0xFF00FF);
      }
    }

    function createSensorRect(scene, config) {
      return scene.add.rectangle(
        0, 0, 
        config.width, 
        config.height, 
        npcSensors.debugColor, 
        npcSensors.debugAlpha
      );
    }

    function updateSensors(npc) {
      if (!npc.sensors || npc.routeIndex < PARKING_START_POINTS || 
          npc.routeIndex > npc.route.length - (PARKING_END_POINTS + 1)) {
        return;
      }

      const rotation = npc.rotation - Math.PI/2;
      
      Object.keys(npc.sensors).forEach(key => {
        const sensor = npc.sensors[key];
        const config = npcSensors[key];
        
        sensor.x = npc.x + Math.cos(rotation + config.angle) * config.offset;
        sensor.y = npc.y + Math.sin(rotation + config.angle) * config.offset;
        sensor.rotation = rotation + config.angle;
        sensor.visible = showDebug && !npc.isReversing;
      });
    }

    function checkSensors(npc) {
      if (!npc.sensors || 
          npc.routeIndex < PARKING_START_POINTS || 
          npc.routeIndex > npc.route.length - (PARKING_END_POINTS + 1) ||
          npc.isReversing) {
        return [];
      }

      const collisions = [];
      const otherNpcs = npcs.filter(n => n !== npc && n.active);
      
      otherNpcs.forEach(other => {
        Object.entries(npc.sensors).forEach(([sensorName, sensor]) => {
          if (Phaser.Geom.Intersects.RectangleToRectangle(
            sensor.getBounds(),
            other.getBounds()
          )) {
            collisions.push({
              npc: other,
              sensor: sensorName,
              distance: Phaser.Math.Distance.Between(npc.x, npc.y, other.x, other.y)
            });

            if (sensorName === 'front' && !npc.isWaiting) {
              handleFrontCollision(npc, {npc: other, sensor: 'front'});
            }
          }
        });
      });
      
      return collisions;
    }
	
	function handleFrontCollision(npc, collision) {
		if (!npc || !npc.body || !collision || !collision.npc) return;

		// Конфигурация
		const BACKSTEP = {
			DISTANCE: 5,
			DURATION: 1000,
			EASE: 'Sine.easeOut',
			COOLDOWN: 3000
		};

		if (npc.isWaiting || npc.isReversing || npc.isAvoiding) return;

		const otherNpc = collision.npc;
		if (!otherNpc.active || !otherNpc.body) return;

		// 1. Сохраняем текущий target point
		const currentTarget = npc.route && npc.route[npc.routeIndex] ? 
			{ ...npc.route[npc.routeIndex] } : 
			{ x: npc.x, y: npc.y };

		// 2. Определение фронт-бок столкновения
		let isFrontToSide = false;
		try {
			const angleToOther = Phaser.Math.Angle.Between(npc.x, npc.y, otherNpc.x, otherNpc.y);
			const angleDiff = Phaser.Math.Angle.Wrap(angleToOther - (otherNpc.rotation - Math.PI/2));
			isFrontToSide = (
				collision.sensor === 'front' && 
				Math.abs(angleDiff) > Math.PI/4 && 
				Math.abs(angleDiff) < 3*Math.PI/4
			);
		} catch (e) {
			console.error('Angle calculation error:', e);
		}

		// 3. Обработка фронт-бок с откатом
		if (isFrontToSide && !npc.hasPerformedBackStep) {
			const originalVelocity = npc.body.velocity.clone();
			const originalRotation = npc.rotation;

			npc.hasPerformedBackStep = true;
			npc.setVelocity(0, 0);
			npc.isWaiting = true;

			const backX = npc.x + Math.cos(originalRotation - Math.PI/2) * -BACKSTEP.DISTANCE;
			const backY = npc.y + Math.sin(originalRotation - Math.PI/2) * -BACKSTEP.DISTANCE;

			npc.scene.tweens.add({
				targets: npc,
				x: backX,
				y: backY,
				duration: BACKSTEP.DURATION,
				ease: BACKSTEP.EASE,
				onComplete: () => {
					if (!npc.active || !npc.body) return;

					// Безопасное восстановление движения
					const target = npc.route && npc.route[npc.routeIndex] ? 
						npc.route[npc.routeIndex] : 
						currentTarget;

					const angle = Phaser.Math.Angle.Between(npc.x, npc.y, target.x, target.y);
					const speed = originalVelocity.length();

					npc.setVelocity(
						Math.cos(angle) * speed,
						Math.sin(angle) * speed
					);
					npc.rotation = angle + Math.PI/2;
					npc.isWaiting = false;

					npc.scene.time.delayedCall(BACKSTEP.COOLDOWN, () => {
						npc.hasPerformedBackStep = false;
					});
				}
			});
			return;
		}

		// 4. Стандартная обработка
		npc.preCollisionSpeed = npc.body.velocity ? npc.body.velocity.clone() : new Phaser.Math.Vector2();
		npc.setVelocity(0, 0);
		npc.isWaiting = true;
		npc.collisionCheckAttempts = 0;
		npc.otherNpc = otherNpc;

		const recheck = () => {
			if (!npc.active || !npc.body || !npc.route) return;

			npc.collisionCheckAttempts++;
			const stillBlocked = checkSensors(npc).some(c => c.npc === npc.otherNpc);

			if (!stillBlocked) {
				npc.isWaiting = false;
				if (npc.preCollisionSpeed) {
					npc.setVelocity(npc.preCollisionSpeed.x, npc.preCollisionSpeed.y);
				} else {
					const target = npc.route[npc.routeIndex];
					if (target) {
						const angle = Phaser.Math.Angle.Between(npc.x, npc.y, target.x, target.y);
						npc.setVelocity(Math.cos(angle) * npcSpeed, Math.sin(angle) * npcSpeed);
					}
				}
			}
			else if (npc.collisionCheckAttempts >= MAX_COLLISION_CHECKS) {
				resolveDeadlock(npc, npc.otherNpc);
			}
			else {
				npc.scene.time.delayedCall(COLLISION_WAIT_TIME, recheck);
			}
		};
		
		npc.scene.time.delayedCall(COLLISION_WAIT_TIME, recheck);
	}
	// Проверка на парковочном месте
	function checkIfOnParkingSpot(npc) {
		const spot = scaleCoords(npc.originalSpot.x, npc.originalSpot.y);
		const distance = Phaser.Math.Distance.Between(npc.x, npc.y, spot.x, spot.y);
		return distance < 10; // 10 пикселей - радиус "на месте"
	}

	// Стандартная обработка столкновений (без изменений)
	function startStandardHandling(npc, otherNpc) {
		if (!npc.body || !npc.active) return;
		
		npc.preCollisionSpeed = npc.body.velocity.clone();
		npc.setVelocity(0, 0);
		npc.isWaiting = true;
		npc.collisionCheckAttempts = 0;
		npc.otherNpc = otherNpc;

		const recheck = () => {
			if (!npc.active || !npc.body) return;
			
			npc.collisionCheckAttempts++;
			const stillBlocked = checkSensors(npc).some(c => c.npc === npc.otherNpc);
			
			if (!stillBlocked) {
				npc.isWaiting = false;
				if (npc.preCollisionSpeed) {
					npc.setVelocity(npc.preCollisionSpeed.x, npc.preCollisionSpeed.y);
				} else {
					moveNPCToNextPoint(npc);
				}
			}
			else if (npc.collisionCheckAttempts >= MAX_COLLISION_CHECKS) {
				resolveDeadlock(npc, npc.otherNpc); // Аннигиляция
			}
			else {
				npc.scene.time.delayedCall(COLLISION_WAIT_TIME, recheck);
			}
		};
		
		npc.scene.time.delayedCall(COLLISION_WAIT_TIME, recheck);
	}
		
    function resolveDeadlock(npc1, npc2) {
      const npcToRemove = Math.random() > 0.5 ? npc1 : npc2;
      const survivingNpc = npcToRemove === npc1 ? npc2 : npc1;

      createAnnihilationEffect(npcToRemove.scene, npcToRemove);
      npcToRemove.destroy();

      npcs = npcs.filter(n => n !== npcToRemove);
      exitQueue = exitQueue.filter(n => n !== npcToRemove);

      if (survivingNpc.active && survivingNpc.preCollisionSpeed) {
        survivingNpc.isWaiting = false;
        survivingNpc.setVelocity(
          survivingNpc.preCollisionSpeed.x,
          survivingNpc.preCollisionSpeed.y
        );
        survivingNpc.preCollisionSpeed = null;
      }
    }

    function createAnnihilationEffect(scene, npc) {
      const explosion = scene.add.graphics()
        .fillStyle(0xFF4500, 1)
        .fillCircle(0, 0, 25)
        .setPosition(npc.x, npc.y)
        .setDepth(25);

      scene.tweens.add({
        targets: explosion,
        scaleX: 3,
        scaleY: 3,
        alpha: 0,
        duration: 500,
        ease: 'Back.easeOut',
        onComplete: () => explosion.destroy()
      });

      if (scene.textures.exists('flares')) {
        const frames = scene.textures.get('flares').getFrameNames();
        const availableFrames = frames.filter(frame => 
          frame.includes('blue') || 
          frame.includes('green') || 
          frame.includes('red') ||
          frame.includes('white') ||
          frame.includes('yellow') ||
          frame.includes('fire')
        );
        
        if (availableFrames.length > 0) {
          const emitter = scene.add.particles(
            npc.x, 
            npc.y,
            'flares',
            {
              frame: availableFrames,
              speed: { min: -200, max: 200 },
              scale: { start: 0.6, end: 0 },
              blendMode: 'ADD',
              lifespan: 900,
              quantity: 25,
              rotate: { start: 0, end: 360 },
              emitting: false
            }
          );
          
          emitter.explode(25);
          scene.time.delayedCall(700, () => emitter.destroy());
        }
      }

      if (scene.cameras && scene.cameras.main) {
        scene.cameras.main.shake(85, 0.005);
      }

      createSmokeEffect(scene, npc.x, npc.y);
    }

    function createSmokeEffect(scene, x, y) {
      if (!scene || typeof x !== 'number' || typeof y !== 'number') return;

      const smokeConfig = {
        texture: scene.textures.exists('smoke4') ? 'smoke4' : null,
        scaleStart: 0.6,
        scaleEnd: 1.1,
        alphaStart: 0.7,
        alphaEnd: 0,
        riseDistance: 80,
        duration: 800,
        xOffset: 0,
        yOffset: 22,
        originX: 0.5,
        originY: 0.5,
        rotation: 0,
        rotationEnd: 0,
        ease: 'Sine.easeOut',
        randomX: 0,
        useAnimation: scene.anims.exists('smoke_anim')
      };

      if (!smokeConfig.texture) {
        if (scene.textures.exists('flares')) {
          createFallbackSmoke(scene, x, y);
        }
        return;
      }

      const smoke = scene.add.sprite(
        x + smokeConfig.xOffset + Phaser.Math.Between(-smokeConfig.randomX, smokeConfig.randomX),
        y + smokeConfig.yOffset,
        smokeConfig.texture
      )
      .setDepth(30)
      .setScale(smokeConfig.scaleStart)
      .setAlpha(smokeConfig.alphaStart)
      .setOrigin(smokeConfig.originX, smokeConfig.originY)
      .setRotation(smokeConfig.rotation);

      if (smokeConfig.useAnimation) {
        smoke.play('smoke_anim');
      }

      scene.tweens.add({
        targets: smoke,
        y: smoke.y - smokeConfig.riseDistance,
        scaleX: smokeConfig.scaleEnd,
        scaleY: smokeConfig.scaleEnd,
        alpha: smokeConfig.alphaEnd,
        rotation: smokeConfig.rotationEnd,
        duration: smokeConfig.duration,
        ease: smokeConfig.ease,
        onComplete: () => smoke.destroy()
      });
    }

    function createFallbackSmoke(scene, x, y) {
      const particles = scene.add.particles(x, y, 'flares', {
        frame: ['white', 'yellow'],
        scale: { start: 0.3, end: 0.8 },
        alpha: { start: 0.6, end: 0 },
        speed: { min: -20, max: 20 },
        lifespan: 1000,
        quantity: 5,
        gravityY: -40,
        emitting: false
      });
      particles.explode(5);
      scene.time.delayedCall(1000, () => particles.destroy());
    }

    function avoidObstacle(npc, obstacle) {
      if (npc.isAvoiding || npc.isReversing || !npc.route || !npc.route[npc.routeIndex]) return;
      
      npc.isAvoiding = true;
      npc.preAvoidState = {
        velocity: npc.body.velocity.clone(),
        routeIndex: npc.routeIndex,
        target: {...npc.route[npc.routeIndex]}
      };
      
      let avoidAngle;
      if (obstacle.sensor === 'left') {
        avoidAngle = npc.rotation - Math.PI/4;
      } else if (obstacle.sensor === 'right') {
        avoidAngle = npc.rotation + Math.PI/4;
      } else {
        avoidAngle = npc.rotation + (Math.random() > 0.5 ? Math.PI/4 : -Math.PI/4);
      }
      
      const avoidSpeed = npcSpeed * 0.7;
      npc.setVelocity(
        Math.cos(avoidAngle - Math.PI/2) * avoidSpeed,
        Math.sin(avoidAngle - Math.PI/2) * avoidSpeed
      );
      
      const boundsCheck = () => {
        if (!npc.active) return;
        
        if (isOutOfBounds(npc)) {
          npc.isAvoiding = false;
          returnToSafePosition(npc);
          return;
        }
        
        if (npc.isAvoiding) {
          npc.scene.time.delayedCall(100, boundsCheck, [], npc.scene);
        }
      };
      
      boundsCheck();
      
      npc.scene.time.delayedCall(500, () => {
        if (npc.active && npc.isAvoiding) {
          npc.isAvoiding = false;
          
          if (npc.preAvoidState && npc.route && npc.route[npc.routeIndex]) {
            const target = npc.route[npc.routeIndex];
            const angle = Phaser.Math.Angle.Between(npc.x, npc.y, target.x, target.y);
            
            let speed;
            const isExitPhase = npc.isExiting && npc.routeIndex < EXIT_PHASE_POINTS;
            const isApproachPhase = npc.routeIndex >= npc.route.length - FINAL_APPROACH_POINTS;
            
            if (isExitPhase) {
              speed = npcExitSpeed;
            } else if (isApproachPhase) {
              speed = npcFinalApproachSpeed;
            } else {
              speed = npcSpeed;
            }
            
            npc.setVelocity(
              Math.cos(angle) * speed,
              Math.sin(angle) * speed
            );
            npc.rotation = angle + Math.PI/2;
          }
        }
      });
    }

    function moveNPCToNextPoint(npc) {
      const isParkingPhase = (
        npc.routeIndex < PARKING_START_POINTS || 
        npc.routeIndex > npc.route.length - (PARKING_END_POINTS + 1)
      );

      if (npc.sensors) {
        Object.values(npc.sensors).forEach(s => {
          s.visible = showDebug && !isParkingPhase && !npc.isReversing;
        });
      }

      const target = npc.route[npc.routeIndex];
      const angle = Phaser.Math.Angle.Between(npc.x, npc.y, target.x, target.y);
      
      let speed;
      if (npc.isExiting && npc.routeIndex < EXIT_PHASE_POINTS) {
        speed = npcExitSpeed;
      } else if (npc.routeIndex >= npc.route.length - FINAL_APPROACH_POINTS) {
        speed = npcFinalApproachSpeed;
      } else if (npc.isReversing) {
        speed = REVERSE_SPEED;
      } else {
        speed = npcSpeed;
      }

      npc.setVelocity(
        Math.cos(angle) * speed,
        Math.sin(angle) * speed
      );
      npc.rotation = angle + Math.PI/2;
    }

	function handleRouteCompletion(npc) {
	  if (!npc || !npc.active || !npc.originalSpot || !npc.scene || !npc.body) {
		console.warn('[NPC] Неверные параметры для завершения маршрута');
		return;
	  }

	  const originalPos = scaleCoords(npc.originalSpot.x, npc.originalSpot.y);
	  
	  const finalApproach = () => {
		if (!npc.active || !npc.body) {
		  console.warn('[NPC] Объект NPC неактивен во время завершения маршрута');
		  return;
		}

		const distance = Phaser.Math.Distance.Between(
		  npc.x, npc.y, 
		  originalPos.x, originalPos.y
		);
		
		if (distance > 2) {
		  const angle = Phaser.Math.Angle.Between(npc.x, npc.y, originalPos.x, originalPos.y);
		  npc.setVelocity(
			Math.cos(angle) * npcFinalApproachSpeed,
			Math.sin(angle) * npcFinalApproachSpeed
		  );
		  npc.rotation = angle + Math.PI/2;
		  
		  npc.scene.time.delayedCall(50, finalApproach);
		} else {
		  // Финализация парковки
		  npc.setVelocity(0, 0);
		  npc.x = originalPos.x;
		  npc.y = originalPos.y;
		  
		  npc.isExiting = false;
		  npc.isInExitQueue = true;
		  exitQueue.push(npc);

		  // Обновляем статус места в системе парковки
		  if (npc.scene.parkingTargetSystem) {
			const scaled = scaleCoords(npc.originalSpot.x, npc.originalSpot.y);
			const isOccupied = npc.scene.parkingTargetSystem.isSpotOccupied(scaled);
			npc.scene.parkingTargetSystem.spotOccupationMap.set(npc.originalSpot, isOccupied);
			
			// Удаляем из списка недавно освободившихся, если нужно
			if (npc.scene.parkingTargetSystem.recentlyFreedSpots) {
			  npc.scene.parkingTargetSystem.recentlyFreedSpots = 
				npc.scene.parkingTargetSystem.recentlyFreedSpots.filter(
				  spot => !(spot.x === npc.originalSpot.x && spot.y === npc.originalSpot.y)
				);
			}
		  }

		  // console.log(`[NPC] Успешно припарковался на месте (${npc.originalSpot.x}, ${npc.originalSpot.y})`);
		}
	  };

	  finalApproach();
	}

	function processExitQueue() {
	  if (exitQueue.length === 0 || Date.now() - lastExitTime < PARKING_EXIT_DELAY) {
		game.scene.scenes[0].time.delayedCall(300, processExitQueue, [], game.scene.scenes[0]);
		return;
	  }

	  // Группируем NPC по зонам парковки (левая/правая сторона)
	  const zones = {
		left: exitQueue.filter(npc => npc.originalSpot.x < 350),  // Левая половина карты (x < 800)
		right: exitQueue.filter(npc => npc.originalSpot.x >= 350), // Правая половина (x >= 800)
	  };

	  // Выбираем зону, где больше NPC (если зоны равны — случайный выбор)
	  let targetZone;
	  if (zones.left.length > zones.right.length) {
		targetZone = 'left';
	  } else if (zones.right.length > zones.left.length) {
		targetZone = 'right';
	  } else {
		targetZone = Phaser.Math.RND.pick(['left', 'right']); // Случайный выбор при равенстве
	  }

	  // Выбираем случайного NPC из выбранной зоны
	  const candidates = zones[targetZone];
	  if (candidates.length === 0) {
		// Если в зоне нет кандидатов, пробуем снова через 100 мс
		game.scene.scenes[0].time.delayedCall(100, processExitQueue, [], game.scene.scenes[0]);
		return;
	  }

	  const nextNpc = Phaser.Math.RND.pick(candidates);
	  exitQueue = exitQueue.filter(n => n !== nextNpc); // Удаляем NPC из очереди

	  // Проверка, что NPC активен и не движется
	  if (!nextNpc.active || nextNpc.isDestroyed || nextNpc.body.velocity.length() > 5) {
		if (nextNpc.active) exitQueue.push(nextNpc); // Возвращаем в очередь, если проблема временная
		game.scene.scenes[0].time.delayedCall(300, processExitQueue, [], game.scene.scenes[0]);
		return;
	  }

	  // Запуск выезда
	  lastExitTime = Date.now();
	  nextNpc.isInExitQueue = false;
	  
	  // Небольшая случайная задержка перед стартом (100-500 мс)
	  const delay = Phaser.Math.Between(100, 500);
	  nextNpc.scene.time.delayedCall(delay, () => {
		if (nextNpc.active) startNpcExit(nextNpc);
	  });

	  // Следующая проверка очереди через 300 мс
	  game.scene.scenes[0].time.delayedCall(300, processExitQueue, [], game.scene.scenes[0]);
	}

	function startNpcExit(npc) {
	  if (!npc || !npc.active || npc.isDestroyed || !npc.scene) return;

	  npc.isExiting = true;
	  npc.isInExitQueue = false;
	  npc.isWaiting = false;
	  
	  // Выбираем случайный маршрут из доступных
	  const randomRouteIndex = Math.floor(Math.random() * allPossibleRoutes.length);
	  const routeType = allPossibleRoutes[randomRouteIndex];
	  
	  npc.route = routeType(npc.originalSpot); // Генерируем новый маршрут
	  npc.isCounterClockwise = routeType.toString().includes('Counter'); // Определяем направление
	  npc.routeIndex = 0; // Сбрасываем индекс точки маршрута
	  npc.lastExitTime = Date.now();
	  
	  moveNPCToNextPoint(npc); // Запускаем движение
	}

    function createEntranceAndPavilion(scene) {
      const { x: entranceX, y: entranceY } = scaleCoords(3 + 252/2, 893 + 216/2, true);
      const entrance = scene.add.image(entranceX, entranceY, 'entrance').setScale(0.5);
      entrance.setDepth(0);

      const { x: pavilionX, y: pavilionY } = scaleCoords(700, 100);
      const pavilion = scene.add.image(pavilionX, pavilionY, 'pavilion').setScale(0.5);
      pavilion.setDepth(0);
    }

    function createDecorativeLayer(scene) {
      const grassOffsetX = 0, grassOffsetY = 20;
      const treeOffsetX = 45, treeOffsetY = 35;
      const bushOffsetX = 35, bushOffsetY = 25;
      const oilOffsetX = 15, oilOffsetY = 23;
      const houseOffsetX = 40, houseOffsetY = 30;

      const lampTopCoords = scaleCoords(850+90, 223+170);
      const lampBottomCoords = scaleCoords(854+90, 1650-140);
      const grass1Coords = scaleCoords(661 + grassOffsetX, 89 + grassOffsetY);
      const tree1Coords = scaleCoords(1635 + treeOffsetX, 127 + treeOffsetY);
      const tree2Coords = scaleCoords(100 + 10, 900 - 300);
      const bush1Coords = scaleCoords(1716 + bushOffsetX, 298 + bushOffsetY);
      const oilCoords = scaleCoords(25 + oilOffsetX, 938 + oilOffsetY);
      
      const bush2Coords = scaleCoords(1510 + bushOffsetX, 100 + bushOffsetY);
      const bush3Coords = scaleCoords(40 + bushOffsetX, 1155 + bushOffsetY); 
      const bush4Coords = scaleCoords(83 + bushOffsetX, 1260 + bushOffsetY);
      const bush5Coords = scaleCoords(90 + bushOffsetX, 1550 + bushOffsetY);
      const house1Coords = scaleCoords(1815 + houseOffsetX, 930 + houseOffsetY);  

      const lampTop = scene.add.image(lampTopCoords.x, lampTopCoords.y, 'lamp_top').setScale(0.5);
      const lampBottom = scene.add.image(lampBottomCoords.x, lampBottomCoords.y, 'lamp_bottom').setScale(0.5);
      const grass1 = scene.add.image(grass1Coords.x, grass1Coords.y, 'grass1').setScale(0.5);
      const tree1 = scene.add.image(tree1Coords.x, tree1Coords.y, 'tree1').setScale(0.5);
      const tree2 = scene.add.image(tree2Coords.x, tree2Coords.y, 'tree2').setScale(0.4);
      const bush1 = scene.add.image(bush1Coords.x, bush1Coords.y, 'bush1').setScale(0.5);
      const oil = scene.add.image(oilCoords.x, oilCoords.y, 'oil').setScale(0.5);
      
      const bush2 = scene.add.image(bush2Coords.x, bush2Coords.y, 'bush2').setScale(0.45);
      const bush3 = scene.add.image(bush3Coords.x, bush3Coords.y, 'bush3').setScale(0.43);
      const bush4 = scene.add.image(bush4Coords.x, bush4Coords.y, 'bush4').setScale(0.40); 
      const bush5 = scene.add.image(bush5Coords.x, bush5Coords.y, 'bush5').setScale(0.44);    
      const house1 = scene.add.image(house1Coords.x, house1Coords.y, 'house1').setScale(0.41);      
      
      lampTop.setDepth(11);
      lampBottom.setDepth(11);
      grass1.setDepth(0);
      tree1.setDepth(11);
      tree2.setDepth(10);
      bush1.setDepth(10);
      oil.setDepth(0);
      bush2.setDepth(10);
      bush3.setDepth(11);
      bush4.setDepth(10);
      bush5.setDepth(10);
      house1.setDepth(10);      
    }
	
	class ParkingTargetSystem {
		constructor(scene, npcs, allParkingSpots) {
			this.scene = scene;
			this.npcs = npcs;
			this.allParkingSpots = allParkingSpots;
			
			this.config = {
				changeDelay: 20000,
				checkDelay: 1000,
				highlightColor: 0xFFA500,
				spotSize: { width: 59 * 0.4, height: 85 * 0.4 },
				occupiedRadius: 20,
				highlightAlpha: { min: 0.3, max: 0.8 },
				minTargetDistance: 300,
				minAdjacentSpots: 12,
				mapCenter: { x: 800, y: 800 },
				spotsPerRow: 6,
				parkingTolerance: 15,
				maxAngleDeviation: Math.PI/2,
				highlightFadeDuration: 400,
				spotCooldownTime: 3000,
				recentlyFreedDelay: 1000
			};
			
			this.currentTarget = null;
			this.highlight = null;
			this.changeTimer = null;
			this.isPlayerParked = false;
			this.testKey = null;
			this.spotOccupationMap = new Map();
			this.recentlyFreedSpots = [];
			this.cooldownSpots = new Map();
			this.playerVisitedSpots = new Set();
			this.playerRef = null;
			this.progressText = null;
			this.waitingText = null;
			this.checkInterval = null;

			this.init();
			this.scene.time.delayedCall(100, () => this.setNewTarget());
		}

		init() {
			this.createHighlight();
			this.createProgressText();
			this.setupTestKey();
			this.initOccupationMap();
		}

		createHighlight() {
			this.highlight = this.scene.add.rectangle(
				0, 0, 
				this.config.spotSize.width, 
				this.config.spotSize.height, 
				this.config.highlightColor, 
				this.config.highlightAlpha.max
			)
			.setOrigin(0.5)
			.setDepth(4)
			.setVisible(false);
			
			this.scene.tweens.add({
				targets: this.highlight,
				alpha: { 
					from: this.config.highlightAlpha.min, 
					to: this.config.highlightAlpha.max 
				},
				duration: 1000,
				yoyo: true,
				repeat: -1
			});
		}

		createProgressText() {
			this.progressText = this.scene.add.text(
				20, 20, 
				'Парковки: 0/' + this.allParkingSpots.length, 
				{ 
					font: '24px Arial', 
					fill: '#ffffff',
					backgroundColor: '#000000',
					padding: { x: 10, y: 5 }
				}
			).setDepth(-1);
		}

		setupTestKey() {
			this.testKey = this.scene.input.keyboard.addKey('R');
			this.testKey.on('down', () => {
				this.setNewTarget();
			});
		}

		initOccupationMap() {
			this.allParkingSpots.forEach(spot => {
				const scaled = this.scaleCoords(spot);
				const isOccupied = this.isSpotOccupied(scaled);
				this.spotOccupationMap.set(spot, isOccupied);
			});
		}

		markSpotAsWillBeFree(spot) {
			if (!spot) return;
			
			const spotKey = `${spot.x}-${spot.y}`;
			this.cooldownSpots.set(spotKey, this.scene.time.now + this.config.spotCooldownTime);
			this.spotOccupationMap.set(spot, false);
			
			this.scene.time.delayedCall(this.config.recentlyFreedDelay, () => {
				if (!this.recentlyFreedSpots.some(s => s.x === spot.x && s.y === spot.y)) {
					this.recentlyFreedSpots.push(spot);
				}
			});
		}

		markSpotAsVisited(spot) {
			if (!spot) return;
			
			const spotKey = `${spot.x}-${spot.y}`;
			this.playerVisitedSpots.add(spotKey);
			this.updateProgressText();
			
			// Визуальное подтверждение парковки
			const graphics = this.scene.add.graphics();
			graphics.fillStyle(0x00FF00, 0.7);
			graphics.fillCircle(
				this.scaleCoords(spot).x,
				this.scaleCoords(spot).y,
				20
			);
			
			this.scene.tweens.add({
				targets: graphics,
				scaleX: 2,
				scaleY: 2,
				alpha: 0,
				duration: 500,
				onComplete: () => graphics.destroy()
			});

			this.setNewTarget();
		}

		getFreeSpots() {
			const now = this.scene.time.now;
			
			// Очищаем устаревшие cooldown-споты
			this.cooldownSpots.forEach((time, key) => {
				if (time < now) this.cooldownSpots.delete(key);
			});

			// Получаем все места, которые физически свободны
			const allFreeSpots = this.allParkingSpots.filter(spot => {
				const scaled = this.scaleCoords(spot);
				return !this.isPhysicallyOccupied(scaled);
			});

			// Фильтруем посещенные и находящиеся в cooldown
			return allFreeSpots.filter(spot => {
				const spotKey = `${spot.x}-${spot.y}`;
				return !this.playerVisitedSpots.has(spotKey) && 
					   !this.cooldownSpots.has(spotKey);
			});
		}

		isSpotOccupied(scaledSpot) {
			if (!scaledSpot) return true;
			return this.npcs.some(npc => {
				if (!npc?.body || !npc.active) return false;
				return Phaser.Math.Distance.Between(
					npc.x, npc.y, 
					scaledSpot.x, scaledSpot.y
				) < this.config.occupiedRadius;
			});
		}

		isPhysicallyOccupied(scaledSpot) {
			if (!scaledSpot) return true;
			return this.npcs.some(npc => {
				if (!npc?.body || !npc.active) return false;
				return Phaser.Math.Distance.Between(
					npc.x, npc.y,
					scaledSpot.x, scaledSpot.y
				) < (this.config.occupiedRadius * 1.5);
			});
		}

		scaleCoords(spot) {
			if (!spot) return { x: 0, y: 0, angle: 0 };
			
			const angle = spot.x < this.config.mapCenter.x 
				? Math.PI / 2 
				: -Math.PI / 2;
			
			return {
				x: (spot.x / 2000) * 800 + (this.config.spotSize.width / 2),
				y: (spot.y / 2000) * 800 + (this.config.spotSize.height / 2),
				angle: angle
			};
		}

		setNewTarget() {
			if (!this.scene) return;

			this.clearTimers();
			this.highlight.setVisible(false);

			const freeSpots = this.getFreeSpots();
			
			if (freeSpots.length === 0) {
				this.showWaitingMessage();
				return;
			}

			// Выбираем самое дальнее от игрока место
			freeSpots.sort((a, b) => {
				const distA = Phaser.Math.Distance.Between(
					this.playerRef.x, this.playerRef.y,
					this.scaleCoords(a).x, this.scaleCoords(a).y
				);
				const distB = Phaser.Math.Distance.Between(
					this.playerRef.x, this.playerRef.y,
					this.scaleCoords(b).x, this.scaleCoords(b).y
				);
				return distB - distA;
			});

			this.currentTarget = freeSpots[0];
			const targetPos = this.scaleCoords(this.currentTarget);
			this.highlight.setPosition(targetPos.x, targetPos.y);
			this.highlight.setVisible(true);

			// Устанавливаем таймер автоматической смены цели
			this.changeTimer = this.scene.time.delayedCall(
				this.config.changeDelay,
				() => this.setNewTarget()
			);
		}

		showWaitingMessage() {
			this.clearWaitingState();
			
			// Показываем сообщение только если есть NPC на парковках
			const hasNPCs = this.npcs.some(npc => npc.active);
			
			if (hasNPCs) {
				this.waitingText = this.scene.add.text(
					this.scene.cameras.main.centerX,
					this.scene.cameras.main.centerY - 50,
					'Ждем свободное место...',
					{ 
						font: '24px Arial', 
						fill: '#ffffff', 
						backgroundColor: '#000000',
						padding: { x: 10, y: 5 }
					}
				).setOrigin(0.5).setDepth(50);
			}

			// Устанавливаем периодическую проверку
			this.checkInterval = this.scene.time.addEvent({
				delay: this.config.checkDelay,
				callback: () => {
					const freeSpots = this.getFreeSpots();
					if (freeSpots.length > 0) {
						this.clearWaitingState();
						this.setNewTarget();
					}
				},
				loop: true
			});
		}

		clearTimers() {
			if (this.changeTimer) {
				this.scene.time.removeEvent(this.changeTimer);
				this.changeTimer = null;
			}
		}

		clearWaitingState() {
			if (this.waitingText) {
				this.waitingText.destroy();
				this.waitingText = null;
			}
			
			if (this.checkInterval) {
				this.scene.time.removeEvent(this.checkInterval);
				this.checkInterval = null;
			}
		}

		checkPlayerParking(player) {
			if (!player?.body || !this.currentTarget || this.isPlayerParked) return false;
			
			const targetCenter = this.scaleCoords(this.currentTarget);
			const distance = Phaser.Math.Distance.Between(
				player.x, player.y,
				targetCenter.x, targetCenter.y
			);
			
			if (distance <= this.config.parkingTolerance) {
				const angleDiff = Math.abs(Phaser.Math.Angle.Wrap(player.rotation - targetCenter.angle));
				if (angleDiff <= this.config.maxAngleDeviation) {
					this.markSpotAsVisited(this.currentTarget);
					return true;
				}
			}
			return false;
		}

		updateProgressText() {
		  const total = this.allParkingSpots.length;
		  const visited = this.playerVisitedSpots.size;
		  const progressText = `Парковки: ${visited}/${total}`;
		  
		  this.progressText.setText(progressText);
		  
		  // Обновляем DOM элемент
		  const progressElement = document.getElementById('parking-progress');
		  if (progressElement) {
			progressElement.textContent = `${visited}/${total}`;
		  }
		  
		  if (visited >= total) {
			this.showWinMessage();
		  }
		}

		showWinMessage() {
			const winText = this.scene.add.text(
				this.scene.cameras.main.centerX,
				this.scene.cameras.main.centerY,
				'ВСЕ ПАРКОВКИ ЗАКОНЧИЛИСЬ!\nПОБЕДА!',
				{ 
					font: '48px Arial', 
					fill: '#ff0000', 
					align: 'center',
					backgroundColor: '#000000',
					padding: { x: 20, y: 15 }
				}
			).setOrigin(0.5).setDepth(100);
			
			const winGraphics = this.scene.add.graphics();
			winGraphics.fillStyle(0xFFFFFF, 0.3);
			winGraphics.fillRect(
				winText.x - winText.width/2 - 20,
				winText.y - winText.height/2 - 20,
				winText.width + 40,
				winText.height + 40
			);
			winText.setDepth(101);
			
			this.scene.physics.pause();
			this.scene.time.removeAllEvents();
		}

		update() {
			if (!this.scene) return;

			// Обновляем информацию о занятости мест
			this.allParkingSpots.forEach(spot => {
				const scaled = this.scaleCoords(spot);
				this.spotOccupationMap.set(spot, this.isSpotOccupied(scaled));
			});

			// Если текущая цель занята - меняем
			if (this.currentTarget && this.isSpotOccupied(this.scaleCoords(this.currentTarget))) {
				this.setNewTarget();
			}
		}

		destroy() {
			this.clearTimers();
			this.clearWaitingState();

			if (this.highlight) {
				this.highlight.destroy();
				this.highlight = null;
			}
			
			if (this.testKey) {
				this.testKey.off('down');
				this.scene.input.keyboard.removeKey(this.testKey);
				this.testKey = null;
			}
			
			if (this.progressText) {
				this.progressText.destroy();
				this.progressText = null;
			}
			
			this.spotOccupationMap.clear();
			this.recentlyFreedSpots = [];
			this.cooldownSpots.clear();
			this.playerVisitedSpots.clear();
			
			this.scene = null;
			this.npcs = null;
			this.allParkingSpots = null;
			this.playerRef = null;
		}
	}

    function preload() {
      this.load.image('background', 'assets/parking_map.png');
      this.load.image('entrance', 'assets/entrance.png');
      this.load.image('pavilion', 'assets/pavilion.png');
      this.load.image('grass1', 'assets/grass1.png');
      this.load.image('tree1', 'assets/tree1.png');
      this.load.image('tree2', 'assets/tree2.png');
      this.load.image('bush1', 'assets/bush1.png');
      this.load.image('oil', 'assets/oil.png');
      this.load.image('lamp_top', 'assets/lamp_top.png');
      this.load.image('lamp_bottom', 'assets/lamp_bottom.png');
      this.load.atlas('flares', 'assets/particles/flares.png', 'assets/particles/flares.json');
      this.load.image('bush2', 'assets/bush1.png');
      this.load.image('bush3', 'assets/bush1.png');
      this.load.image('bush4', 'assets/bush1.png');
      this.load.image('bush5', 'assets/bush1.png');
      this.load.image('house1', 'assets/house1.png');    
      this.load.image('smoke4', 'assets/smoke/smoke4.png');
      this.load.image('smoke5', 'assets/smoke/smoke5.png');

      const models = ['sedan', 'suv', 'hatchback', 'coupe', 'van'];
      const colors = ['red', 'blue', 'green', 'yellow', 'black'];
      
      models.forEach(model => {
        colors.forEach(color => {
          this.load.image(`car_${model}_${color}`, `assets/cars/${model}_${color}.png`);
        });
      });
    }

	function drawWorldBoundsDebug(graphics) {
	  if (!showDebug) return;
	  
	  graphics.lineStyle(2, 0xff0000, 0.8); // Красная линия толщиной 2px
	  
	  // Основные границы мира
	  graphics.strokeRect(
		WORLD_BOUNDS.left,
		WORLD_BOUNDS.top,
		WORLD_BOUNDS.right - WORLD_BOUNDS.left,
		WORLD_BOUNDS.bottom - WORLD_BOUNDS.top
	  );
	  
	  // Зона padding (торможения)
	  graphics.lineStyle(1, 0xff0000, 0.5); // Полупрозрачная красная линия
	  graphics.strokeRect(
		WORLD_BOUNDS.left + WORLD_BOUNDS.padding,
		WORLD_BOUNDS.top + WORLD_BOUNDS.padding,
		WORLD_BOUNDS.right - WORLD_BOUNDS.left - WORLD_BOUNDS.padding * 2,
		WORLD_BOUNDS.bottom - WORLD_BOUNDS.top - WORLD_BOUNDS.padding * 2
	  );
	}


	function create() {
		const scene = this;
		
		// Создаем фон
		background = scene.add.image(400, 400, 'background').setDepth(1);
		background.setDisplaySize(800, 800);

		// Создаем игровую зону
		gameArea = createGameArea(scene);

		// Настройка отладки
		debugGraphics = scene.add.graphics();
		debugGraphics.setDepth(20);

		// Физика
		this.physics.world.setBounds(
			WORLD_BOUNDS.left, 
			WORLD_BOUNDS.top, 
			WORLD_BOUNDS.right, 
			WORLD_BOUNDS.bottom
		);

		// Инициализация рядов парковочных мест
		const leftRows = [
			upperLeftParkingSpots.slice(0, 6),
			upperLeftParkingSpots.slice(6, 12),
			upperLeftParkingSpots.slice(12, 18),
			upperLeftParkingSpots.slice(18, 24)
		];

		const rightRows = [
			upperRightParkingSpots.slice(0, 6),
			upperRightParkingSpots.slice(6, 12),
			upperRightParkingSpots.slice(12, 18),
			upperRightParkingSpots.slice(18, 24)
		];

		// Очищаем массивы
		npcs = [];
		exitQueue = [];
		lastExitTime = 0;

		// Создаем NPC
		const allRows = [...leftRows, ...rightRows];
		allRows.forEach(row => {
			const selectedSpots = getRandomSpotsInRow(row, NPC_PER_ROW);
			selectedSpots.forEach(spot => {
				const npc = scene.physics.add.sprite(
					scaleCoords(spot.x, spot.y).x,
					scaleCoords(spot.x, spot.y).y,
					getRandomCarTexture()
				)
				.setScale(0.47)
				.setDepth(5)
				.setCollideWorldBounds(false);

				npc.body.setSize(13, 20);
				npc.body.setOffset(0, 7);

				createSensors(scene, npc);

				npc.originalSpot = spot;
				npc.routeSequence = createShuffledRouteSequence();
				npc.currentRouteIndex = 0;
				npc.route = npc.routeSequence[0](npc.originalSpot);
				npc.isCounterClockwise = npc.routeSequence[0].toString().includes('Counter');
				npc.routeIndex = 0;
				npc.isWaiting = true;
				npc.isInExitQueue = true;
				npc.isExiting = false;
				npc.isReversing = false;
				npc.isAvoiding = false;
				npc.reverseAttempts = 0;
				npc.lastExitTime = 0;
				npc.collisionCheckAttempts = 0;

				npcs.push(npc);
				exitQueue.push(npc);
			});
		});

		// Система целей парковки
		scene.parkingTargetSystem = new ParkingTargetSystem(
			scene, 
			npcs, 
			[...upperLeftParkingSpots, ...upperRightParkingSpots]
		);

		// Создаем игрока
		this.player = this.physics.add.sprite(50, 400, 'car_sedan_red')
			.setScale(0.47)
			.setDepth(10);
		this.player.body.setSize(13, 20);
		this.player.body.setOffset(0, 7);
		scene.parkingTargetSystem.playerRef = this.player;

		// Управление игроком
		this.cursors = this.input.keyboard.createCursorKeys();

		// Система overlap для NPC
		scene.physics.add.overlap(
			npcs,
			npcs,
			(npc1, npc2) => {
				if (npc1 === npc2 || !npc1.active || !npc2.active) return;

				const angle = Phaser.Math.Angle.Between(npc1.x, npc1.y, npc2.x, npc2.y);
				const distance = Phaser.Math.Distance.Between(npc1.x, npc1.y, npc2.x, npc2.y);
				const minDistance = 3;
				
				if (distance < minDistance) {
					const pushForce = 1.0 * (minDistance - distance);
					const pushX = Math.cos(angle) * pushForce;
					const pushY = Math.sin(angle) * pushForce;
					
					npc1.body.velocity.x += pushX;
					npc1.body.velocity.y += pushY;
					npc2.body.velocity.x -= pushX;
					npc2.body.velocity.y -= pushY;
				}

				if (npc1.isAvoiding || npc2.isAvoiding) return;

				const avoidingNpc = Math.random() > 0.5 ? npc1 : npc2;
				const otherNpc = avoidingNpc === npc1 ? npc2 : npc1;
				
				const sensorCollisions = checkSensors(avoidingNpc);
				const leftCollision = sensorCollisions.find(c => c.sensor === 'left' && c.npc === otherNpc);
				const rightCollision = sensorCollisions.find(c => c.sensor === 'right' && c.npc === otherNpc);
				
				if (leftCollision) {
					avoidObstacle(avoidingNpc, leftCollision);
				} else if (rightCollision) {
					avoidObstacle(avoidingNpc, rightCollision);
				} else if (sensorCollisions.some(c => c.sensor === 'front')) {
					avoidObstacle(avoidingNpc, { sensor: 'front' });
				}
			},
			null,
			this
		);

		scene.physics.add.collider(npcs, gameArea);

		// Система камеры для мобильных
		if (isMobile) {
			cameraTarget = scene.add.rectangle(400, 400, 10, 10).setAlpha(0);
			
			function updateCameraTarget() {
				if (npcs.length > 0) {
					currentTarget = Phaser.Math.RND.pick(npcs);
				}
			}
			
			scene.cameras.main.setZoom(1.8);
			scene.cameras.main.startFollow(cameraTarget);
			scene.cameras.main.setBounds(0, 0, mapWidth, mapHeight);
			
			scene.time.addEvent({ 
				delay: 3000, 
				callback: updateCameraTarget, 
				loop: true 
			});
			
			updateCameraTarget();
			
			scene.input.on('pointerdown', () => {
				updateCameraTarget();
			});
		} else {
			scene.cameras.main.setBounds(0, 0, mapWidth, mapHeight);
		}

		// Запуск обработчика очереди выезда
		processExitQueue();

		// Создаем декорации
		createEntranceAndPavilion(scene);
		createDecorativeLayer(scene);

		// Кнопки отладки
		scene.input.keyboard.on('keydown-T', () => {
			const testX = Phaser.Math.Between(100, 700);
			const testY = Phaser.Math.Between(100, 700);
			createSmokeEffect(scene, testX, testY);
		});

		scene.input.keyboard.on('keydown-E', () => {
			if (npcs.length > 0) {
				const randomNpc = npcs[Phaser.Math.Between(0, npcs.length - 1)];
				createAnnihilationEffect(scene, randomNpc);
				
				scene.time.delayedCall(500, () => {
					randomNpc.destroy();
					npcs = npcs.filter(n => n !== randomNpc);
				});
			}
		});

		scene.input.keyboard.on('keydown-D', () => {
			showDebug = !showDebug;
			debugGraphics.clear();
			
			if (showDebug) {
				drawWorldBoundsDebug(debugGraphics);
				
				gameArea.each(child => {
					debugGraphics.fillStyle(0x00ff00, 0.3);
					debugGraphics.lineStyle(2, 0x00ff00, 0.6);
					debugGraphics.fillRect(
						child.x - child.width/2,
						child.y - child.height/2,
						child.width,
						child.height
					);
					debugGraphics.strokeRect(
						child.x - child.width/2,
						child.y - child.height/2,
						child.width,
						child.height
					);
				});
			}
		});

		scene.input.keyboard.on('keydown-H', () => {
			if (showDebug) {
				showCollisionHighlights = !showCollisionHighlights;
			}
		});
	}


	function handleWorldBounds(npc) {
		if (!npc.active) return true;

		// Жёсткая проверка выхода за границы
		const isOut = 
			npc.x < WORLD_BOUNDS.left - 15 || 
			npc.x > WORLD_BOUNDS.right + 15 ||
			npc.y < WORLD_BOUNDS.top - 15 || 
			npc.y > WORLD_BOUNDS.bottom + 15;

		if (isOut) {
			if (showDebug) {
				debugGraphics.fillStyle(0xff0000, 0.5);
				debugGraphics.fillCircle(npc.x, npc.y, 25);
				console.error(`NPC out of bounds at (${npc.x},${npc.y})`);
			}
			
			// 1. Полная остановка
			npc.body.stop();
			npc.setVelocity(0, 0);
			npc.body.enable = false;
			
			// 2. Попытка возврата
			returnToSafePosition(npc);
			
			// 3. Если всё ещё за границами - деактивация
			if (isOutOfBounds(npc)) {
				// Оставляем видимым, но неактивным
				npc.active = false;
				npc.setVisible(true); // Явно сохраняем видимость
				
				// Удаляем из рабочих массивов
				npcs = npcs.filter(n => n !== npc);
				exitQueue = exitQueue.filter(n => n !== npc);
				
				// Визуальная индикация (только в debug)
				if (showDebug) {
					npc.setTint(0xff0000); // Красный оттенок
					console.warn(`NPC deactivated at (${npc.x},${npc.y})`);
				}
				
				return true; // Сигнализируем об удалении
			}
			return false;
		}
		
		// Мягкое торможение у границ
		const nearBounds = 
			npc.x < WORLD_BOUNDS.left + WORLD_BOUNDS.padding ||
			npc.x > WORLD_BOUNDS.right - WORLD_BOUNDS.padding ||
			npc.y < WORLD_BOUNDS.top + WORLD_BOUNDS.padding ||
			npc.y > WORLD_BOUNDS.bottom - WORLD_BOUNDS.padding;

		if (nearBounds) {
			npc.setVelocity(
				npc.body.velocity.x * 0.7,
				npc.body.velocity.y * 0.7
			);
		}
		
		return false;
	}
	
	function clampToWorldBounds(npc) {
		const prevX = npc.x;
		const prevY = npc.y;
		
		npc.x = Phaser.Math.Clamp(
			npc.x, 
			WORLD_BOUNDS.left - 10,
			WORLD_BOUNDS.right + 10
		);
		npc.y = Phaser.Math.Clamp(
			npc.y,
			WORLD_BOUNDS.top - 10,
			WORLD_BOUNDS.bottom + 10
		);
		
		// Отладочная информация
		if ((prevX !== npc.x || prevY !== npc.y) && showDebug) {
			debugGraphics.lineStyle(2, 0xff00ff, 0.7);
			debugGraphics.strokeCircle(npc.x, npc.y, 20);
			console.warn(`NPC clamped from (${prevX},${prevY}) to (${npc.x},${npc.y})`);
		}
	}	
    
	function update() {
	  // Обновление камеры для мобильных устройств
	  if (isMobile && cameraTarget && currentTarget) {
		cameraTarget.x = Phaser.Math.Linear(cameraTarget.x, currentTarget.x, 0.1);
		cameraTarget.y = Phaser.Math.Linear(cameraTarget.y, currentTarget.y, 0.1);
	  }
	  
	  // Управление игроком
	  if (this.cursors.left.isDown) {
		this.player.setVelocityX(-100);
		this.player.rotation = -Math.PI/2;
	  } 
	  else if (this.cursors.right.isDown) {
		this.player.setVelocityX(100);
		this.player.rotation = Math.PI/2;
	  } 
	  else if (this.cursors.up.isDown) {
		this.player.setVelocityY(-100);
		this.player.rotation = 0;
	  } 
	  else if (this.cursors.down.isDown) {
		this.player.setVelocityY(100);
		this.player.rotation = Math.PI;
	  } 
	  else {
		this.player.setVelocityX(0);
		this.player.setVelocityY(0);
	  }

	  // Проверка парковки игрока
	  if (this.parkingTargetSystem) {
		this.parkingTargetSystem.checkPlayerParking(this.player);
		this.parkingTargetSystem.update();
	  }

	  // Обработка NPC
	  for (let i = 0; i < npcs.length; i++) {
		const npc = npcs[i];
		
		if (!npc || !npc.active || !npc.body || !npc.route || !npc.route[npc.routeIndex]) {
		  continue;
		}

		// Ограничение позиции в пределах мира
		clampToWorldBounds(npc);

		// Проверка выхода за границы
		if (handleWorldBounds(npc)) {
		  npcs.splice(i, 1);
		  exitQueue = exitQueue.filter(n => n !== npc);
		  i--;
		  continue;
		}
		
		// Обновление сенсоров
		updateSensors(npc);
		
		// Пропуск, если NPC ожидает/разворачивается/избегает
		if (npc.isReversing || npc.isAvoiding || npc.isWaiting) {
		  continue;
		}

		// Проверка коллизий
		const collisions = checkSensors(npc);
		if (collisions.length > 0 && !npc.isReversing) {
		  handleFrontCollision(npc, collisions[0]);
		  continue;
		}

		// Движение к следующей точке
		const target = npc.route[npc.routeIndex];
		const distance = Phaser.Math.Distance.Between(npc.x, npc.y, target.x, target.y);

		if (distance < 5) {
		  npc.routeIndex++;
		  
		  if (npc.routeIndex >= npc.route.length) {
			handleRouteCompletion(npc);
			continue;
		  }
		  
		  moveNPCToNextPoint(npc);
		}
	  }

	  // Отладочная информация
	  if (showDebug) {
		debugGraphics.clear();
		drawWorldBoundsDebug(debugGraphics);
		
		if (showCollisionHighlights) {
		  gameArea.each(child => {
			if (!child.body) return;
			
			debugGraphics.fillStyle(0x00ff00, 0.3);
			debugGraphics.lineStyle(2, 0x00ff00, 0.6);
			debugGraphics.fillRect(
			  child.x - child.width/2,
			  child.y - child.height/2,
			  child.width,
			  child.height
			);
			debugGraphics.strokeRect(
			  child.x - child.width/2,
			  child.y - child.height/2,
			  child.width,
			  child.height
			);
		  });
		}
	  }
	}
  </script>
</head>
<body>
  <div id="game-container"></div>
	<div class="debug-panel">
	  <span style="color: #00ff00">Парковки: <span id="parking-progress">0/48</span></span><br>	
	  Режим: <span id="device-mode">ПК</span><br>
	  <span id="camera-info">Камера: фиксированная</span><br>
	  Нажмите 'P' для паузы или тапните по экрану<br>
	  Нажмите 'E' и 'T' для аннигиляции и дымового эффекта
	</div>
  
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      document.getElementById('device-mode').textContent = isMobile ? 'Мобильный' : 'ПК';
      document.getElementById('camera-info').textContent = isMobile 
        ? 'Камера: слежение за NPC' 
        : 'Камера: фиксированная';
    });
  </script>
</body>
</html>