<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Parking Rush с объездами</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #000;
    }
    #game-container {
      display: block;
      max-width: 100%;
      max-height: 100%;
    }
    .debug-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      font-family: monospace;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>
    // Конфигурация NPC
    const npcSpeed = 60;
    const npcParkingSpeed = 30;
    const npcFinalApproachSpeed = 40;
    const npcExitSpeed = 20;
    const REVERSE_SPEED = 40;
    const MAX_REVERSE_TIME = 1;
    const REVERSE_CHECK_DELAY = 5000;
    const MAX_REVERSE_ATTEMPTS = 3;
    const SCENE_BOUNDS_PADDING = 50;
    const COLLISION_WAIT_TIME = 2250;
    const NO_REVERSE_WAIT_TIME = 2000;
    const PARKING_START_POINTS = 1;
    const PARKING_END_POINTS = 3;
    const FINAL_APPROACH_POINTS = 3;
    const EXIT_PHASE_POINTS = 3;
    const PARKING_EXIT_DELAY = 4000;

    // Конфигурация сенсоров для объездов
    const npcSensors = {
      front: { width: 27, height: 20, offset: 25 },
      left: { width: 20, height: 10, offset: 10 },
      right: { width: 20, height: 10, offset: 10 },
      debugColor: 0xff0000,
      debugAlpha: 0.3
    };

    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 800,
      parent: 'game-container',
      scene: {
        preload: preload,
        create: create,
        update: update
      },
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 },
          debug: false
        }
      },
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
      }
    };

    const game = new Phaser.Game(config);
    let npcs = [];
    let lastExitTime = 0;
    let exitQueue = [];
    let debugGraphics;
    let showDebug = false;
    let showCollisionHighlights = true;

    // ========== ФУНКЦИИ ДЛЯ ОБЪЕЗДА ПРЕПЯТСТВИЙ ==========

    // Создание сенсоров для NPC
    function createSensors(scene, npc) {
      npc.sensors = {
        front: scene.add.rectangle(0, 0, npcSensors.front.width, npcSensors.front.height, npcSensors.debugColor, npcSensors.debugAlpha)
          .setVisible(false),
        left: scene.add.rectangle(0, 0, npcSensors.left.width, npcSensors.left.height, npcSensors.debugColor, npcSensors.debugAlpha)
          .setVisible(false),
        right: scene.add.rectangle(0, 0, npcSensors.right.width, npcSensors.right.height, npcSensors.debugColor, npcSensors.debugAlpha)
          .setVisible(false)
      };
    }

    // Обновление позиций сенсоров
    function updateSensors(npc) {
      if (!npc.sensors || npc.routeIndex < PARKING_START_POINTS || npc.routeIndex > npc.route.length - (PARKING_END_POINTS + 1)) {
        return;
      }

      const rotation = npc.rotation - Math.PI/2;
      
      // Передний сенсор
      npc.sensors.front.x = npc.x + Math.cos(rotation) * npcSensors.front.offset;
      npc.sensors.front.y = npc.y + Math.sin(rotation) * npcSensors.front.offset;
      npc.sensors.front.rotation = rotation;
      
      // Левый сенсор
      npc.sensors.left.x = npc.x + Math.cos(rotation + Math.PI/2) * npcSensors.left.offset;
      npc.sensors.left.y = npc.y + Math.sin(rotation + Math.PI/2) * npcSensors.left.offset;
      npc.sensors.left.rotation = rotation;
      
      // Правый сенсор
      npc.sensors.right.x = npc.x + Math.cos(rotation - Math.PI/2) * npcSensors.right.offset;
      npc.sensors.right.y = npc.y + Math.sin(rotation - Math.PI/2) * npcSensors.right.offset;
      npc.sensors.right.rotation = rotation;

      // Видимость сенсоров в режиме отладки
      const shouldShow = showDebug && !npc.isReversing;
      npc.sensors.front.visible = shouldShow;
      npc.sensors.left.visible = shouldShow;
      npc.sensors.right.visible = shouldShow;
    }

    // Проверка столкновений сенсоров
    function checkSensors(npc) {
      if (!npc.sensors || npc.routeIndex < PARKING_START_POINTS || npc.routeIndex > npc.route.length - (PARKING_END_POINTS + 1)) {
        return [];
      }

      const collisions = [];
      const otherNpcs = npcs.filter(n => n !== npc && n.active);
      
      otherNpcs.forEach(other => {
        Object.entries(npc.sensors).forEach(([sensorName, sensor]) => {
          if (Phaser.Geom.Intersects.RectangleToRectangle(
            sensor.getBounds(),
            other.getBounds()
          )) {
            collisions.push({
              npc: other,
              sensor: sensorName,
              distance: Phaser.Math.Distance.Between(npc.x, npc.y, other.x, other.y)
            });

            if (showDebug && showCollisionHighlights) {
              const debugGraphics = npc.scene.add.graphics();
              debugGraphics.fillStyle(0xffff00, 0.5);
              debugGraphics.fillRect(
                other.x - other.width/2,
                other.y - other.height/2,
                other.width,
                other.height
              );
              npc.scene.time.delayedCall(100, () => debugGraphics.destroy());
            }
          }
        });
      });
      
      return collisions;
    }

    // Объезд препятствия
	function avoidObstacle(npc, obstacle) {
		if (npc.isAvoiding || npc.isReversing || !npc.route || !npc.route[npc.routeIndex]) return;
		
		npc.isAvoiding = true;
		// Сохраняем не только скорость, но и текущую точку маршрута
		npc.preAvoidState = {
			velocity: npc.body.velocity.clone(),
			routeIndex: npc.routeIndex,
			target: {...npc.route[npc.routeIndex]}
		};
		
		// Определяем направление объезда
		let avoidAngle;
		if (obstacle.sensor === 'left') {
			avoidAngle = npc.rotation - Math.PI/4; // Вправо
		} else if (obstacle.sensor === 'right') {
			avoidAngle = npc.rotation + Math.PI/4; // Влево
		} else {
			// Для фронтальных - случайное направление
			avoidAngle = npc.rotation + (Math.random() > 0.5 ? Math.PI/4 : -Math.PI/4);
		}
		
		// Задаем временную скорость для объезда (70% от обычной скорости)
		const avoidSpeed = npcSpeed * 0.7;
		npc.setVelocity(
			Math.cos(avoidAngle - Math.PI/2) * avoidSpeed,
			Math.sin(avoidAngle - Math.PI/2) * avoidSpeed
		);
		
		// Проверка на выход за границы во время объезда
		const boundsCheck = () => {
			if (!npc.active) return;
			
			if (isOutOfBounds(npc)) {
				npc.isAvoiding = false;
				returnToSafePosition(npc);
				return;
			}
			
			if (npc.isAvoiding) {
				npc.scene.time.delayedCall(100, boundsCheck, [], npc.scene);
			}
		};
		
		boundsCheck();
		
		// Возврат к нормальному движению через 500 мс
		npc.scene.time.delayedCall(500, () => {
			if (npc.active && npc.isAvoiding) {
				npc.isAvoiding = false;
				
				// Восстанавливаем движение к текущей точке маршрута, а не просто скорость
				if (npc.preAvoidState && npc.route && npc.route[npc.routeIndex]) {
					const target = npc.route[npc.routeIndex];
					const angle = Phaser.Math.Angle.Between(npc.x, npc.y, target.x, target.y);
					
					// Определяем правильную скорость в зависимости от фазы движения
					let speed;
					const isExitPhase = npc.isExiting && npc.routeIndex < EXIT_PHASE_POINTS;
					const isApproachPhase = npc.routeIndex >= npc.route.length - FINAL_APPROACH_POINTS;
					
					if (isExitPhase) {
						speed = npcExitSpeed;
					} else if (isApproachPhase) {
						speed = npcFinalApproachSpeed;
					} else {
						speed = npcSpeed;
					}
					
					npc.setVelocity(
						Math.cos(angle) * speed,
						Math.sin(angle) * speed
					);
					npc.rotation = angle + Math.PI/2;
				}
			}
		});
	}

    // ========== ОРИГИНАЛЬНЫЕ ФУНКЦИИ С ДОПОЛНЕНИЯМИ ==========

    function scaleCoords(x, y, isRoad = false) {
      const parkingSpotWidth = 59;
      const parkingSpotHeight = 85;
      const scaleFactor = 0.4;
      const offsetX = (parkingSpotWidth / 2) * scaleFactor;
      const offsetY = (parkingSpotHeight / 2) * scaleFactor;
      const roadOffsetX = -12;
      const roadOffsetY = -16;
      
      const scaledX = (x / 2000) * 800 + offsetX;
      const scaledY = (y / 2000) * 800 + offsetY;
      if (isRoad) return { x: scaledX + roadOffsetX, y: scaledY + roadOffsetY };
      return { x: scaledX, y: scaledY };
    }

    function createShuffledRouteSequence() {
      const routes = [...allPossibleRoutes];
      for (let i = routes.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [routes[i], routes[j]] = [routes[j], routes[i]];
      }
      return routes;
    }

    function processExitQueue() {
      if (exitQueue.length === 0 || Date.now() - lastExitTime < PARKING_EXIT_DELAY) {
        game.scene.scenes[0].time.delayedCall(300, processExitQueue, [], game.scene.scenes[0]);
        return;
      }

      const nextNpc = exitQueue.shift();
      if (!nextNpc.active || nextNpc.isDestroyed) {
        game.scene.scenes[0].time.delayedCall(100, processExitQueue, [], game.scene.scenes[0]);
        return;
      }

      if (nextNpc.body.velocity.length() > 5) {
        exitQueue.push(nextNpc);
        game.scene.scenes[0].time.delayedCall(300, processExitQueue, [], game.scene.scenes[0]);
        return;
      }

      lastExitTime = Date.now();
      nextNpc.isInExitQueue = false;
      
      const delay = Phaser.Math.Between(100, 500);
      nextNpc.scene.time.delayedCall(delay, () => {
        if (nextNpc.active) {
          startNpcExit(nextNpc);
        }
      });

      game.scene.scenes[0].time.delayedCall(300, processExitQueue, [], game.scene.scenes[0]);
    }

    function startNpcExit(npc) {
      if (!npc.active || npc.isDestroyed) return;

      npc.isExiting = true;
      npc.isInExitQueue = false;
      npc.isWaiting = false;
      
      const randomRouteIndex = Math.floor(Math.random() * allPossibleRoutes.length);
      const routeType = allPossibleRoutes[randomRouteIndex];
      npc.route = routeType(npc.originalSpot);
      npc.isCounterClockwise = routeType.toString().includes('Counter');
      npc.routeIndex = 0;
      npc.lastExitTime = Date.now();
      
      moveNPCToNextPoint(npc);
    }

    function isOutOfBounds(npc) {
      return npc.x < SCENE_BOUNDS_PADDING || 
             npc.x > config.width - SCENE_BOUNDS_PADDING ||
             npc.y < SCENE_BOUNDS_PADDING || 
             npc.y > config.height - SCENE_BOUNDS_PADDING;
    }

    function returnToSafePosition(npc) {
      let safeIndex = npc.routeIndex;
      while (safeIndex >= 0) {
        const point = npc.route[safeIndex];
        if (point.x > SCENE_BOUNDS_PADDING && 
            point.x < config.width - SCENE_BOUNDS_PADDING &&
            point.y > SCENE_BOUNDS_PADDING && 
            point.y < config.height - SCENE_BOUNDS_PADDING) {
          break;
        }
        safeIndex--;
      }
      
      if (safeIndex >= 0) {
        npc.routeIndex = safeIndex;
        npc.x = npc.route[safeIndex].x;
        npc.y = npc.route[safeIndex].y;
        npc.setVelocity(0, 0);
        npc.isReversing = false;
        npc.isWaiting = false;
        moveNPCToNextPoint(npc);
      } else {
        const {x, y} = scaleCoords(npc.originalSpot.x, npc.originalSpot.y);
        npc.x = x;
        npc.y = y;
        npc.routeIndex = 0;
        npc.setVelocity(0, 0);
        npc.isReversing = false;
        npc.isWaiting = true;
        npc.scene.time.delayedCall(2000, () => {
          npc.isWaiting = false;
          moveNPCToNextPoint(npc);
        });
      }
    }

    function moveNPCBackward(npc) {
      if (!npc.isReversing || npc.routeIndex <= 0) {
        npc.isReversing = false;
        return;
      }

      const currentPoint = npc.route[npc.routeIndex];
      const prevPoint = npc.route[npc.routeIndex - 1];
      
      const angle = Phaser.Math.Angle.Between(currentPoint.x, currentPoint.y, prevPoint.x, prevPoint.y);
      
      npc.setVelocity(
        Math.cos(angle) * REVERSE_SPEED,
        Math.sin(angle) * REVERSE_SPEED
      );
      npc.rotation = angle + Math.PI/2;

      const distance = Phaser.Math.Distance.Between(npc.x, npc.y, prevPoint.x, prevPoint.y);
      if (distance < 5) {
        npc.routeIndex--;
        npc.x = prevPoint.x;
        npc.y = prevPoint.y;
        npc.setVelocity(0, 0);
        
        if (npc.routeIndex > 0) {
          npc.scene.time.delayedCall(100, () => moveNPCBackward(npc), [], npc.scene);
        } else {
          finishReversing(npc);
        }
      } else {
        npc.scene.time.delayedCall(100, () => moveNPCBackward(npc), [], npc.scene);
      }
    }

    function finishReversing(npc) {
      npc.isReversing = false;
      npc.setVelocity(0, 0);
      
      npc.scene.time.delayedCall(REVERSE_CHECK_DELAY, () => {
        if (!npc.scene) return;
        
        const collisions = checkSensors(npc);
        if (collisions.some(c => c.sensor === 'front')) {
          tryOvertake(npc, collisions.find(c => c.sensor === 'front').npc);
        } else {
          npc.isWaiting = false;
          moveNPCToNextPoint(npc);
        }
      });
    }

    function tryOvertake(npc, obstacle) {
      npc.reverseAttempts = (npc.reverseAttempts || 0) + 1;
      
      if (npc.reverseAttempts > MAX_REVERSE_ATTEMPTS) {
        forceChangeRoute(npc);
        return;
      }

      if (isOutOfBounds(npc)) {
        returnToSafePosition(npc);
        return;
      }

      if (npc.routeIndex > 0) {
        npc.setVelocity(0, 0);
        npc.isReversing = true;
        npc.reversingStartTime = Date.now();
        
        if (showDebug) {
          const debugGraphics = npc.scene.add.graphics();
          debugGraphics.fillStyle(0xff00ff, 0.5);
          debugGraphics.fillRect(
            npc.x - npc.width/2,
            npc.y - npc.height/2,
            npc.width,
            npc.height
          );
          npc.scene.time.delayedCall(NO_REVERSE_WAIT_TIME, () => debugGraphics.destroy());
        }
        
        moveNPCBackward(npc);
      } else {
        npc.isWaiting = true;
        npc.scene.time.delayedCall(NO_REVERSE_WAIT_TIME, () => {
          npc.isWaiting = false;
          moveNPCToNextPoint(npc);
        });
      }
    }

    function forceChangeRoute(npc) {
      const parkingSpot = scaleCoords(npc.originalSpot.x, npc.originalSpot.y);
      const distanceToSpot = Phaser.Math.Distance.Between(npc.x, npc.y, parkingSpot.x, parkingSpot.y);
      
      if (distanceToSpot < 10) {
        npc.x = parkingSpot.x;
        npc.y = parkingSpot.y;
        changeRouteImmediately(npc);
      } else {
        returnToParkingSpot(npc, () => {
          changeRouteImmediately(npc);
        });
      }
    }
    
    function returnToParkingSpot(npc, callback) {
      const parkingSpot = scaleCoords(npc.originalSpot.x, npc.originalSpot.y);
      const angle = Phaser.Math.Angle.Between(npc.x, npc.y, parkingSpot.x, parkingSpot.y);
      
      npc.setVelocity(
        Math.cos(angle) * REVERSE_SPEED,
        Math.sin(angle) * REVERSE_SPEED
      );
      npc.rotation = angle + Math.PI/2;
      
      const checkDistance = () => {
        const currentDistance = Phaser.Math.Distance.Between(npc.x, npc.y, parkingSpot.x, parkingSpot.y);
        if (currentDistance < 5) {
          npc.setVelocity(0, 0);
          npc.x = parkingSpot.x;
          npc.y = parkingSpot.y;
          callback();
        } else {
          npc.scene.time.delayedCall(100, checkDistance, [], npc.scene);
        }
      };
      
      checkDistance();
    }

    function changeRouteImmediately(npc) {
      npc.reverseAttempts = 0;
      npc.isReversing = false;
      npc.setVelocity(0, 0);
      
      npc.currentRouteIndex = (npc.currentRouteIndex + 1) % npc.routeSequence.length;
      const nextRouteType = npc.routeSequence[npc.currentRouteIndex];
      npc.route = nextRouteType(npc.originalSpot);
      npc.isCounterClockwise = nextRouteType.toString().includes('Counter');
      npc.routeIndex = 0;
      
      npc.isWaiting = true;
      npc.scene.time.delayedCall(2000, () => {
        npc.isWaiting = false;
        moveNPCToNextPoint(npc);
      });
    }

    function preload() {
      this.load.image('lamp_top', 'assets/lamp_top.png');
      this.load.image('lamp_bottom', 'assets/lamp_bottom.png');  
      this.load.image('background', 'assets/parking_map.png');
      this.load.image('entrance', 'assets/entrance.png');
      this.load.image('pavilion', 'assets/pavilion.png');
      this.load.image('grass1', 'assets/grass1.png');
      this.load.image('tree1', 'assets/tree1.png');
      this.load.image('tree2', 'assets/tree2.png');
      this.load.image('bush1', 'assets/bush1.png');
      this.load.image('oil', 'assets/oil.png');
      this.load.image('npcCar', 'assets/npc_car.png');
    }

    function create() {
      const background = this.add.image(400, 400, 'background');
      background.setDisplaySize(800, 800);

      createCombinedCollider(this);

      debugGraphics = this.add.graphics();
      debugGraphics.setDepth(20);
      if (showDebug) {
        drawDebugColliders(this);
      }

      const createInvisibleParkingSpots = (scene) => {
        allParkingSpots.forEach(spot => {
          const { x, y } = scaleCoords(spot.x, spot.y);
          const parkingSpot = scene.add.rectangle(
            x, y,
            59 * 0.4,
            85 * 0.4,
            0x000000,
            0
          ).setOrigin(0.5);
          scene.physics.add.existing(parkingSpot, true);
        });
      };

      const createInvisibleRoads = (scene) => {
        const roads = [
          { x: 3 + 252/2, y: 893 + 216/2, width: 252, height: 216 },
          { x: 237 + 104/2, y: 236 + 1529/2, width: 140, height: 1529 },
          { x: 1618 + 32 + 120/2, y: 237 + 1526/2, width: 120 + 64, height: 1526 },
          { x: 257 + 1485/2, y: 234 + 143/2, width: 1485, height: 143 },
          { x: 259 + 1479/2, y: 1622 - 40 + 141/2, width: 1479, height: 221 },
          { x: 257 + 1482/2, y: 872 - 40 + 252/2, width: 1482, height: 332 },
          { x: 887 + 203/2, y: 236 + 1528/2, width: 203, height: 1528 },
          { x: 259 + 1477/2, y: 579 - 42 + 94/2, width: 1477, height: 94 + 84 },
          { x: 259 + 1477/2, y: 1326 - 42 + 94/2, width: 1477, height: 94 + 84 }
        ];

        roads.forEach(road => {
          const { x, y } = scaleCoords(road.x, road.y, true);
          const roadRect = scene.add.rectangle(
            x, y,
            road.width * 0.4,
            road.height * 0.4,
            0x000000,
            0
          ).setOrigin(0.5);
          scene.physics.add.existing(roadRect, true);
        });
      };

      createInvisibleParkingSpots(this);
      createInvisibleRoads(this);

      const createEntranceAndPavilion = (scene) => {
        const { x: entranceX, y: entranceY } = scaleCoords(3 + 252/2, 893 + 216/2, true);
        scene.add.image(entranceX, entranceY, 'entrance').setScale(0.5);

        const { x: pavilionX, y: pavilionY } = scaleCoords(700, 100);
        scene.add.image(pavilionX, pavilionY, 'pavilion').setScale(0.5);
      };

      const createDecorativeLayer = (scene) => {
        const grassOffsetX = 0, grassOffsetY = 20;
        const treeOffsetX = 45, treeOffsetY = 35;
        const bushOffsetX = 35, bushOffsetY = 25;
        const oilOffsetX = 15, oilOffsetY = 23;

        const lampTopCoords = scaleCoords(850+90, 223+170);
        const lampBottomCoords = scaleCoords(854+90, 1650-140);
        const grass1Coords = scaleCoords(661 + grassOffsetX, 89 + grassOffsetY);
        const tree1Coords = scaleCoords(1635 + treeOffsetX, 127 + treeOffsetY);
        const tree2Coords = scaleCoords(100 + 10, 900 - 300);
        const bush1Coords = scaleCoords(1716 + bushOffsetX, 298 + bushOffsetY);
        const oilCoords = scaleCoords(25 + oilOffsetX, 938 + oilOffsetY);

        const lampTop = scene.add.image(lampTopCoords.x, lampTopCoords.y, 'lamp_top').setScale(0.5);
        const lampBottom = scene.add.image(lampBottomCoords.x, lampBottomCoords.y, 'lamp_bottom').setScale(0.5);
        const grass1 = scene.add.image(grass1Coords.x, grass1Coords.y, 'grass1').setScale(0.5);
        const tree1 = scene.add.image(tree1Coords.x, tree1Coords.y, 'tree1').setScale(0.5);
        const tree2 = scene.add.image(tree2Coords.x, tree2Coords.y, 'tree2').setScale(0.4);
        const bush1 = scene.add.image(bush1Coords.x, bush1Coords.y, 'bush1').setScale(0.5);
        const oil = scene.add.image(oilCoords.x, oilCoords.y, 'oil').setScale(0.5);

        lampTop.setDepth(11);
        lampBottom.setDepth(11);
        grass1.setDepth(2);
        tree1.setDepth(10);
        tree2.setDepth(10);
        bush1.setDepth(10);
        oil.setDepth(2);
      };

      createEntranceAndPavilion(this);
      createDecorativeLayer(this);

      const shuffledSpots = Phaser.Utils.Array.Shuffle([...allParkingSpots]);
      npcs = shuffledSpots.map((spot) => {
        const { x, y } = scaleCoords(spot.x, spot.y);
        const npc = this.physics.add.sprite(x, y, 'npcCar')
          .setScale(0.5)
          .setDepth(3)
          .setCollideWorldBounds(true);
        
        createSensors(this, npc);
        
        npc.originalSpot = spot;
        npc.routeSequence = createShuffledRouteSequence();
        npc.currentRouteIndex = 0;
        
        const firstRouteType = npc.routeSequence[npc.currentRouteIndex];
        npc.route = firstRouteType(npc.originalSpot);
        npc.isCounterClockwise = firstRouteType.toString().includes('Counter');
        
        npc.routeIndex = 0;
        npc.isWaiting = true;
        npc.isInExitQueue = true;
        npc.isExiting = false;
        npc.isReversing = false;
        npc.isAvoiding = false;
        npc.reverseAttempts = 0;
        npc.lastExitTime = 0;

        exitQueue.push(npc);

        this.time.delayedCall(Phaser.Math.Between(3000, 5000), () => {
          if (!npc.isInExitQueue) {
            npc.isWaiting = false;
            moveNPCToNextPoint(npc);
          }
        });
        
        return npc;
      });
      
      this.events.on('shutdown', () => {
        exitQueue = [];
      });  

      processExitQueue();
      
      this.input.keyboard.on('keydown-D', () => {
        showDebug = !showDebug;
        debugGraphics.clear();
        
        if (showDebug) {
          drawDebugColliders(this);
        }
        
        npcs.forEach(npc => {
          if (!npc.sensors) return;
          
          const isParkingPhase = (
            npc.routeIndex < PARKING_START_POINTS || 
            npc.routeIndex > npc.route.length - (PARKING_END_POINTS + 1)
          );
          
          Object.values(npc.sensors).forEach(sensor => {
            sensor.visible = showDebug && !isParkingPhase && !npc.isReversing;
          });
        });
      });
      
      this.input.keyboard.on('keydown-H', () => {
        if (showDebug) {
          showCollisionHighlights = !showCollisionHighlights;
          console.log(`Подсветка препятствий: ${showCollisionHighlights ? 'ВКЛ' : 'ВЫКЛ'}`);
        }
      });

      // Коллайдер для обработки столкновений между NPC
      this.physics.add.collider(
        npcs,
        npcs,
        (npc1, npc2) => {
          // Проверяем, кто из NPC должен объехать
          if (npc1.isAvoiding || npc2.isAvoiding) return;
          
          const avoidingNpc = Math.random() > 0.5 ? npc1 : npc2;
          const otherNpc = avoidingNpc === npc1 ? npc2 : npc1;
          
          // Проверяем сенсоры для определения направления объезда
          const sensorCollisions = checkSensors(avoidingNpc);
          const leftCollision = sensorCollisions.find(c => c.sensor === 'left' && c.npc === otherNpc);
          const rightCollision = sensorCollisions.find(c => c.sensor === 'right' && c.npc === otherNpc);
          
          if (leftCollision) {
            avoidObstacle(avoidingNpc, leftCollision);
          } else if (rightCollision) {
            avoidObstacle(avoidingNpc, rightCollision);
          } else {
            // Если нет данных с сенсоров - случайное направление
            avoidObstacle(avoidingNpc, { sensor: 'front' });
          }
        }
      );
    }

    function createCombinedCollider(scene) {
      combinedCollider = scene.add.container();
      
      const roads = [
        { x: 3 + 252/2, y: 893 + 216/2, width: 252, height: 216 },
        { x: 237 + 104/2, y: 236 + 1529/2, width: 140, height: 1529 },
        { x: 1618 + 32 + 120/2, y: 237 + 1526/2, width: 120 + 64, height: 1526 },
        { x: 257 + 1485/2, y: 234 + 143/2, width: 1485, height: 143 },
        { x: 259 + 1479/2, y: 1622 - 40 + 141/2, width: 1479, height: 221 },
        { x: 257 + 1482/2, y: 872 - 40 + 252/2, width: 1482, height: 332 },
        { x: 887 + 203/2, y: 236 + 1528/2, width: 203, height: 1528 },
        { x: 259 + 1477/2, y: 579 - 42 + 94/2, width: 1477, height: 94 + 84 },
        { x: 259 + 1477/2, y: 1326 - 42 + 94/2, width: 1477, height: 94 + 84 }
      ];

      roads.forEach(road => {
        const { x, y } = scaleCoords(road.x, road.y, true);
        const roadRect = scene.add.rectangle(
          x, y,
          road.width * 0.4,
          road.height * 0.4,
          0x000000,
          0
        ).setOrigin(0.5);
        scene.physics.add.existing(roadRect, true);
        combinedCollider.add(roadRect);
      });

      allParkingSpots.forEach(spot => {
        const { x, y } = scaleCoords(spot.x, spot.y);
        const parkingSpot = scene.add.rectangle(
          x, y,
          59 * 0.4,
          85 * 0.4,
          0x000000,
          0
        ).setOrigin(0.5);
        scene.physics.add.existing(parkingSpot, true);
        combinedCollider.add(parkingSpot);
      });

      return combinedCollider;
    }

    function drawDebugColliders(scene) {
      debugGraphics.clear();
      
      debugGraphics.fillStyle(0x00ff00, 0.3);
      debugGraphics.lineStyle(2, 0x00ff00, 0.6);

      combinedCollider.each(collider => {
        if (collider.width > 100 || collider.height > 100) { 
          debugGraphics.fillStyle(0x00ff00, 0.3);
          debugGraphics.lineStyle(2, 0x00ff00, 0.6);
        } 
        else { 
          debugGraphics.fillStyle(0x0000ff, 0.3);
          debugGraphics.lineStyle(2, 0x0000ff, 0.6);
        }
        
        debugGraphics.fillRect(
          collider.x - collider.width / 2,
          collider.y - collider.height / 2,
          collider.width,
          collider.height
        );
        debugGraphics.strokeRect(
          collider.x - collider.width / 2,
          collider.y - collider.height / 2,
          collider.width,
          collider.height
        );
      });
    }

	function update() {
		const scene = this;

		npcs.forEach(npc => {
			if (!npc || !npc.route || !npc.route[npc.routeIndex]) return;

			// Обновляем сенсоры
			updateSensors(npc);
			
			// Пропускаем обработку для NPC в режиме отката или объезда
			if (npc.isReversing || npc.isAvoiding) {
				return;
			}

			// Проверка столкновений сенсоров
			const sensorCollisions = checkSensors(npc);
			if (sensorCollisions.length > 0 && !npc.isWaiting && !npc.isInExitQueue) {
				const frontCollision = sensorCollisions.find(c => c.sensor === 'front');
				if (frontCollision && !npc.isAvoiding) {
					avoidObstacle(npc, frontCollision);
				}
			}

			// Логика движения
			if ((!npc.isWaiting && !npc.isInExitQueue) || npc.isExiting) {
				const target = npc.route[npc.routeIndex];
				if (!target || target.x === undefined || target.y === undefined) return;

				const distance = Phaser.Math.Distance.Between(npc.x, npc.y, target.x, target.y);

				if (distance < 5) {
					npc.routeIndex++;

					if (npc.routeIndex >= npc.route.length) {
						handleRouteCompletion(npc);
						return;
					}
					
					// Обновляем движение к следующей точке
					moveNPCToNextPoint(npc);
				}
			}
		});
	}
	
	function handleRouteCompletion(npc) {
		const originalPos = scaleCoords(npc.originalSpot.x, npc.originalSpot.y);
		const finalApproach = () => {
			const remainingDist = Phaser.Math.Distance.Between(npc.x, npc.y, originalPos.x, originalPos.y);
			
			if (remainingDist > 2) {
				const angle = Phaser.Math.Angle.Between(npc.x, npc.y, originalPos.x, originalPos.y);
				npc.setVelocity(
					Math.cos(angle) * npcFinalApproachSpeed,
					Math.sin(angle) * npcFinalApproachSpeed
				);
				npc.rotation = angle + Math.PI/2;
				
				npc.scene.time.delayedCall(50, finalApproach, [], npc.scene);
			} else {
				npc.x = originalPos.x;
				npc.y = originalPos.y;
				npc.setVelocity(0, 0);
				npc.isExiting = false;
				
				if (npc.isExiting) {
					handleNpcExit.call(npc.scene, npc);
				} else {
					handleNpcParking.call(npc.scene, npc);
				}
			}
		};
		
		finalApproach();
	}	

    function handleNpcExit(npc) {
      const scene = this;
      npc.isExiting = true;
      npc.lastExitTime = Date.now();
      
      const delay = Phaser.Math.Between(2000, 5000);
      scene.time.delayedCall(delay, () => {
        if (!npc.scene || !npc.active) return;
        
        npc.currentRouteIndex = (npc.currentRouteIndex + 1) % npc.routeSequence.length;
        const nextRouteType = npc.routeSequence[npc.currentRouteIndex];
        npc.route = nextRouteType(npc.originalSpot);
        npc.isCounterClockwise = nextRouteType.toString().includes('Counter');
        npc.routeIndex = 0;
        npc.isWaiting = false;
        
        moveNPCToNextPoint(npc);
      });
    }
    
    function handleNpcParking(npc) {
      const scene = this;
      
      npc.setVelocity(0, 0);
      npc.isWaiting = true;
      npc.isExiting = false;
      npc.isReversing = false;
      npc.reverseAttempts = 0;

      const delay = Phaser.Math.Between(2000, 5000);
      
      scene.time.delayedCall(delay, () => {
        if (!npc.active || npc.isInExitQueue || npc.isExiting) return;
        
        npc.isInExitQueue = true;
        exitQueue.push(npc);
      });
    }
    
    function moveNPCToNextPoint(npc) {
      const isParkingPhase = (
        npc.routeIndex < PARKING_START_POINTS || 
        npc.routeIndex > npc.route.length - (PARKING_END_POINTS + 1)
      );
      
      if (npc.sensors) {
        Object.values(npc.sensors).forEach(s => {
          s.visible = showDebug && !isParkingPhase && !npc.isReversing;
        });
      }

      if (!npc.route || !npc.route[npc.routeIndex]) return;
      
      if (npc.isExiting && npc.routeIndex === 0) {
        npc.lastExitTime = Date.now();
      }  

      const target = npc.route[npc.routeIndex];
      const angle = Phaser.Math.Angle.Between(npc.x, npc.y, target.x, target.y);
      
      let speed;
      const isExitPhase = npc.isExiting && npc.routeIndex < EXIT_PHASE_POINTS;
      const isApproachPhase = npc.routeIndex >= npc.route.length - FINAL_APPROACH_POINTS;

      if (isExitPhase) {
        speed = npcExitSpeed;
      } else if (isApproachPhase) {
        speed = npcFinalApproachSpeed;
      } else if (npc.isReversing) {
        speed = REVERSE_SPEED;
      } else {
        speed = npcSpeed;
      }

      npc.setVelocity(
        Math.cos(angle) * speed,
        Math.sin(angle) * speed
      );
      npc.rotation = angle + Math.PI/2;
    }

    // Парковочные места
    const upperLeftParkingSpots = [
      { x: 361, y: 380 }, { x: 454, y: 380 }, { x: 546, y: 380 }, //{ x: 641, y: 380 }, { x: 729, y: 380 }, { x: 823, y: 380 },
    //  { x: 361, y: 674 }, { x: 454, y: 674 }, { x: 546, y: 674 }, { x: 641, y: 674 }, { x: 729, y: 674 }, { x: 823, y: 674 },
    //  { x: 361, y: 1130 }, { x: 454, y: 1130 }, { x: 546, y: 1130 }, { x: 641, y: 1130 }, { x: 729, y: 1130 }, { x: 823, y: 1130 },
    //  { x: 361, y: 1420 }, { x: 454, y: 1420 }, { x: 546, y: 1420 }, { x: 641, y: 1420 }, { x: 729, y: 1420 }, { x: 823, y: 1420 }  
    ];
    
    const upperRightParkingSpots = [
      { x: 1094, y: 380 }, //{ x: 1189, y: 380 }, { x: 1279, y: 380 }, { x: 1371, y: 380 }, { x: 1462, y: 380 }, { x: 1555, y: 380 },
      { x: 1094, y: 674 }, //{ x: 1189, y: 674 }, { x: 1279, y: 674 }, { x: 1371, y: 674 }, { x: 1462, y: 674 }, { x: 1555, y: 674 },
      { x: 1094, y: 1130 }, //{ x: 1189, y: 1130 }, { x: 1279, y: 1130 }, { x: 1371, y: 1130 }, { x: 1462, y: 1130 }, { x: 1555, y: 1130 },
      { x: 1094, y: 1420 }, //{ x: 1189, y: 1420 }, { x: 1279, y: 1420 }, { x: 1371, y: 1420 }, { x: 1462, y: 1420 }, { x: 1555, y: 1420 }
    ];
    
    const allParkingSpots = [...upperLeftParkingSpots, ...upperRightParkingSpots];

    // Все возможные маршруты
    const allPossibleRoutes = [
      // 1. Полный круг по часовой стрелке
      function clockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 690 - 20, y: y - 37 }, { x: 690 - 20, y: 665 - 20 },
          { x: 110 + 20, y: 665 - 20 }, { x: 110 + 20, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      // 2. Полный круг против часовой стрелки
      function counterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 82 + 20, y: y - 62 }, { x: 82 + 20, y: 710 - 20 },
          { x: 725 - 20, y: 710 - 20 }, { x: 725 - 20, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      // 4. Верхняя половина против часовой стрелки
      function upperHalfCounterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 82 + 20, y: y - 62 }, { x: 82 + 20, y: 405 },
          { x: 725 - 20, y: 405 }, { x: 725 - 20, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },      
      // 5. Левая верхняя четверть по часовой стрелке
      function leftHalfClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 390 - 20, y: y - 37 }, { x: 390 - 20, y: 360 },
          { x: 110 + 20, y: 360 }, { x: 110 + 20, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      // 6. Левая верхняя четверть против часовой стрелки
      function leftHalfCounterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 62 }, { x, y: y - 62 },
          { x: 82 + 20, y: y - 62 }, { x: 82 + 20, y: 390 },
          { x: 395, y: 390 }, { x: 395, y: y - 62 },
          { x, y: y - 62 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      // 9. Правая верхняя четверть по часовой стрелке
      function rightUpperQuarterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 37 }, { x, y: y - 37 },
          { x: 690 - 20, y: y - 37 }, { x: 690 - 20, y: 370 },
          { x: 420, y: 370 }, { x: 420, y: y - 37 },
          { x, y: y - 37 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
    ];
  </script>
</head>
<body>
  <div id="game-container"></div>
  <div class="debug-panel">
    Debug: Нажмите 'D' для отображения коллайдеров<br>
    Нажмите 'H' для переключения подсветки столкновений (когда debug включен)<br>
    Зеленый - дороги, Синий - парковочные места<br>
    Красный - сенсоры NPC (передние/левые/правые)<br>
    Фиолетовый - NPC в режиме отката
  </div>
</body>
</html>