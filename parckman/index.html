<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Parking Rush</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #000;
    }
    #game-container {
      display: block;
      max-width: 100%;
      max-height: 100%;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>
    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 800,
      parent: 'game-container',
      scene: {
        preload: preload,
        create: create,
        update: update
      },
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 },
          debug: false
        }
      },
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
      }
    };

    const game = new Phaser.Game(config);

    // Конфигурация
    const parkingSpotWidth = 59;
    const parkingSpotHeight = 85;
    const scaleFactor = 0.4;
    const offsetX = (parkingSpotWidth / 2) * scaleFactor;
    const offsetY = (parkingSpotHeight / 2) * scaleFactor;
    const roadOffsetX = -12;
    const roadOffsetY = -16;
    const npcWidth = 40;
    const npcOffset = npcWidth / 2;

    // Парковочные места
    const upperLeftParkingSpots = [
      { x: 361, y: 674 }
    ];
    
    const upperRightParkingSpots = [
      { x: 1094, y: 674 }
    ];
    
    const allParkingSpots = [...upperLeftParkingSpots, ...upperRightParkingSpots];

    // Все маршруты
    const allPossibleRoutes = [
      function clockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 35 }, { x, y: y - 35 },
          { x: 677 - npcOffset, y: y - 35 }, { x: 677 - npcOffset, y: 675 - npcOffset },
          { x: 115 + npcOffset, y: 675 - npcOffset }, { x: 115 + npcOffset, y: y - 35 },
          { x, y: y - 35 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      },
      function counterClockwiseRoute(spot) {
        const { x, y } = scaleCoords(spot.x, spot.y);
        return [
          { x, y }, { x, y: y - 55 }, { x, y: y - 55 },
          { x: 85 + npcOffset, y: y - 55 }, { x: 85 + npcOffset, y: 700 - npcOffset },
          { x: 703 - npcOffset, y: 700 - npcOffset }, { x: 703 - npcOffset, y: y - 55 },
          { x, y: y - 55 }, { x, y: y - 20 }, { x, y: y - 10 }, { x, y }
        ];
      }
    ];

    // Глобальные переменные
    let npcs = [];
    const npcSpeed = 100;
    const npcParkingSpeed = 30;
    const npcFinalApproachSpeed = 40;

    function scaleCoords(x, y, isRoad = false) {
      const scaledX = (x / 2000) * 800 + offsetX;
      const scaledY = (y / 2000) * 800 + offsetY;
      if (isRoad) return { x: scaledX + roadOffsetX, y: scaledY + roadOffsetY };
      return { x: scaledX, y: scaledY };
    }

    function createShuffledRouteSequence() {
      const routes = [...allPossibleRoutes];
      for (let i = routes.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [routes[i], routes[j]] = [routes[j], routes[i]];
      }
      return routes;
    }

    function preload() {
      this.load.image('background', 'assets/parking_map.png');
      this.load.image('npcCar', 'assets/npc_car.png');
    }

    function create() {
      // Фон
      const background = this.add.image(400, 400, 'background');
      background.setDisplaySize(800, 800);

      // Невидимые парковочные места
      allParkingSpots.forEach(spot => {
        const { x, y } = scaleCoords(spot.x, spot.y);
        const parkingSpot = this.add.rectangle(
          x, y,
          parkingSpotWidth * scaleFactor,
          parkingSpotHeight * scaleFactor,
          0x000000,
          0
        ).setOrigin(0.5);
        this.physics.add.existing(parkingSpot, true);
      });

      // Создание NPC
      npcs = allParkingSpots.map((spot, index) => {
        const { x, y } = scaleCoords(spot.x, spot.y);
        const npc = this.physics.add.sprite(x, y, 'npcCar').setScale(0.5);
        npc.setCollideWorldBounds(true);
        
        // Система маршрутов
        npc.originalSpot = spot;
        npc.routeSequence = createShuffledRouteSequence();
        npc.currentRouteIndex = 0;
        
        const firstRouteType = npc.routeSequence[npc.currentRouteIndex];
        npc.route = firstRouteType(npc.originalSpot);
        npc.isClockwise = firstRouteType.toString().includes('Clockwise');
        npc.priority = 0;
        npc.routeIndex = 0;
        npc.isWaiting = true;

        // Исправленная строка - добавлена стрелочная функция
        this.time.delayedCall(Phaser.Math.Between(1000, 3000), () => {
          npc.isWaiting = false;
          moveNPCToNextPoint(npc);
        });
        
        return npc;
      });
    }

    function update() {
      npcs.forEach(npc => {
        if (!npc.isWaiting) {
          const isExiting = npc.routeIndex >= npc.route.length - 3;
          npc.priority = isExiting ? 2 : (npc.isClockwise ? 1 : 0);

          const carsAhead = npcs.filter(otherNpc => {
            if (otherNpc === npc) return false;
            const distance = Phaser.Math.Distance.Between(npc.x, npc.y, otherNpc.x, otherNpc.y);
            return distance < 60 && isInFront(npc, otherNpc);
          });

          if (carsAhead.length > 0) {
            const highestPriorityCar = carsAhead.reduce((prev, current) => 
              (prev.priority > current.priority) ? prev : current
            );

            if (npc.priority < highestPriorityCar.priority) {
              npc.setVelocity(0, 0);
            } else if (npc.priority === highestPriorityCar.priority) {
              if (Math.random() > 0.5) {
                npc.setVelocity(0, 0);
              } else {
                moveNPCToNextPoint(npc);
              }
            } else {
              moveNPCToNextPoint(npc);
            }
          } else {
            moveNPCToNextPoint(npc);
          }
        }
      });
    }

    function isInFront(npc, otherNpc) {
      const angle = Phaser.Math.Angle.Between(npc.x, npc.y, otherNpc.x, otherNpc.y);
      const npcAngle = npc.rotation - Math.PI / 2;
      const angleDiff = Math.abs(Phaser.Math.Angle.Wrap(angle - npcAngle));
      return angleDiff < Math.PI / 4;
    }

    function moveNPCToNextPoint(npc) {
      const target = npc.route[npc.routeIndex];
      const angle = Phaser.Math.Angle.Between(npc.x, npc.y, target.x, target.y);
      
      const isFinalApproach = npc.routeIndex >= npc.route.length - 3;
      const speed = isFinalApproach ? npcFinalApproachSpeed : npcSpeed;
      
      const isPreRotation = npc.routeIndex === npc.route.length - 3;
      const isFinalRotating = npc.routeIndex === npc.route.length - 2;
      const isParking = npc.routeIndex === npc.route.length - 1;

      if (isPreRotation) {
        npc.rotation = npc.isClockwise ? -Phaser.Math.DegToRad(0) : Phaser.Math.DegToRad(0);
      } else if (isFinalRotating) {
        npc.rotation = 0.1;
      } else if (isParking) {
        npc.rotation = 0;
      } else {
        npc.rotation = angle + Math.PI / 2;
      }

      npc.setVelocity(
        Math.cos(angle) * speed,
        Math.sin(angle) * speed
      );
    }
  </script>
</head>
<body>
  <div id="game-container"></div>
</body>
</html>