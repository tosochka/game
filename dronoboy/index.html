<!DOCTYPE html>
<html>
<head>
    <title>DronoBoy - Движение по направлению взгляда</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 4px black;
        }
        #ammo, #score, #health { font-size: 24px; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            flex-direction: column;
        }
        #start-button {
            padding: 10px 20px;
            font-size: 20px;
            background: #4CAF50;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.1s;
        }
        #start-button:active {
            transform: scale(0.95);
            background: #45a049;
        }
        #instructions {
            margin-top: 20px;
            text-align: center;
            max-width: 500px;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="hud">
        <div id="ammo">Патроны: 300</div>
        <div id="score">Очки: 0</div>
        <div id="health">Здоровье: 100</div>
    </div>
    <div id="crosshair"></div>
    <div id="start-screen">
        <button id="start-button">Начать игру</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>

    <script>
        const DronoBoy = (() => {
            const config = {
                playerHeight: 1.7,
                gunPosition: { x: 0.4, y: -0.5, z: -1.35 },
                gunScale: 0.9,
                targetCount: 15,
                targetSpeed: { min: 0.07, max: 0.12 },
                ammoStart: 300,
                targetSize: 0.5,
                targetHeight: {
                    min: 2.0,
                    max: 20
                },
                spawnDistance: { min: -120, max: -80 },
                despawnDistance: 100,
                fadeDistance: 60,
                waveAmplitude: 3,
                waveFrequency: 0.1,
                landscapeObjects: {
                    count: 45, // Количество ландшафтных объектов 80
                    types: [
                        'models/tree1.glb',
                        'models/tree2.glb',
                        'models/tree3.glb',
                        'models/tree4.glb',
                        'models/tree5.glb',
                        'models/tree6.glb',
                        'models/tree7.glb',
                        'models/tree8.glb',
                        'models/tree9.glb',
                        'models/tree10.glb',
                        'models/tree11.glb',
                        'models/tree12.glb',
                        'models/tree13.glb',
                        'models/tree14.glb',
                        'models/tree15.glb',
                        'models/tree16.glb',
                        'models/rock1.glb',
                        'models/rock2.glb'
                    ],
                    scaleRange: { min: 10.5, max: 20.0 },
                    positionRange: { x: 45, z: 80 }
                },
                playerSpeed: 0.2,
                healthStart: 100,
                grenadeSpawnChance: 0.01,
                playerBounds: {
                    minX: -45,
                    maxX: 45,
                    minZ: -60,
                    maxZ: 60
                }
            };

            let scene, camera, renderer, controls;
            let gun, targets = [], landscape = [], grenades = [];
            let ammoCount = config.ammoStart, score = 0, health = config.healthStart;
            let isGameStarted = false;
            let moveState = { forward: false, backward: false };

            function init() {
                createScene();
                setupCamera();
                setupRenderer();
                createLighting();
                createGround();
                loadModels();
                setupControls();
                setupEventListeners();
                animate();
            }

            function createScene() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB);
                scene.fog = new THREE.Fog(0x87CEEB, 60, 120);
            }

            function setupCamera() {
                camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                camera.position.y = config.playerHeight;
            }

            function setupRenderer() {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('game-container').appendChild(renderer.domElement);
            }

            function createLighting() {
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(1, 10, 1);
                directionalLight.castShadow = true;
                
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                
                scene.add(directionalLight);
            }

            function createGround() {
                const ground = new THREE.Mesh(
                    new THREE.PlaneGeometry(200, 200),
                    new THREE.MeshStandardMaterial({ color: 0x3a5f0b })
                );
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                ground.userData.isGround = true;
                scene.add(ground);
            }

            function loadModels() {
                const loader = new THREE.GLTFLoader();
                
                loader.load('models/gun.glb', 
                    (gltf) => {
                        gun = gltf.scene;
                        gun.position.set(config.gunPosition.x, config.gunPosition.y, config.gunPosition.z);
                        gun.scale.set(config.gunScale, config.gunScale, config.gunScale);
                        camera.add(gun);
                        scene.add(camera);
                    },
                    undefined,
                    () => {
                        gun = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 0.1, 0.5),
                            new THREE.MeshStandardMaterial({ color: 0x555555 })
                        );
                        gun.position.set(config.gunPosition.x, config.gunPosition.y, config.gunPosition.z);
                        camera.add(gun);
                        scene.add(camera);
                    }
                );

                loadLandscapeObjects();

                for (let i = 0; i < config.targetCount; i++) {
                    spawnNewTarget();
                }
            }

            function loadLandscapeObjects() {
                const loader = new THREE.GLTFLoader();
                const placedObjects = [];
                
                for (let i = 0; i < config.landscapeObjects.count; i++) {
                    const typeIndex = Math.floor(Math.random() * config.landscapeObjects.types.length);
                    const modelPath = config.landscapeObjects.types[typeIndex];
                    const x = Math.random() * (config.landscapeObjects.positionRange.x * 2) - config.landscapeObjects.positionRange.x;
                    const z = Math.random() * (config.landscapeObjects.positionRange.z * 2) - config.landscapeObjects.positionRange.z;
                    
                    loader.load(modelPath, 
                        (gltf) => {
                            const obj = gltf.scene;
                            const scale = Math.random() * 
                                         (config.landscapeObjects.scaleRange.max - config.landscapeObjects.scaleRange.min) + 
                                         config.landscapeObjects.scaleRange.min;
                            
                            obj.scale.set(scale, scale, scale);
                            obj.position.set(x, 0, z);
                            obj.rotation.y = Math.random() * Math.PI * 2;
                            
                            obj.traverse(child => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                }
                            });
                            
                            obj.userData.isLandscape = true;
                            landscape.push(obj);
                            scene.add(obj);
                        },
                        undefined,
                        () => {
                            const geometry = Math.random() > 0.5 ? 
                                new THREE.ConeGeometry(1, 3, 8) : 
                                new THREE.SphereGeometry(1, 8, 8);
                            
                            const obj = new THREE.Mesh(
                                geometry,
                                new THREE.MeshStandardMaterial({ 
                                    color: Math.random() > 0.5 ? 0x228B22 : 0x808080 
                                })
                            );
                            
                            const scale = Math.random() * 
                                       (config.landscapeObjects.scaleRange.max - config.landscapeObjects.scaleRange.min) + 
                                       config.landscapeObjects.scaleRange.min;
                            
                            obj.scale.set(scale, scale, scale);
                            obj.position.set(x, 0, z);
                            obj.rotation.y = Math.random() * Math.PI * 2;
                            obj.castShadow = true;
                            obj.receiveShadow = true;
                            obj.userData.isLandscape = true;
                            
                            landscape.push(obj);
                            scene.add(obj);
                        }
                    );
                }
            }

            function spawnNewTarget() {
                const loader = new THREE.GLTFLoader();
                loader.load('models/target.glb', 
                    (gltf) => {
                        const targetGroup = new THREE.Group();
                        const target = gltf.scene;
                        
                        target.traverse(child => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                child.material.transparent = true;
                                child.material.opacity = 0;
                            }
                        });
                        
                        const box = new THREE.Box3().setFromObject(target);
                        const center = box.getCenter(new THREE.Vector3());
                        target.position.sub(center);
                        
                        target.rotation.y = Math.PI;
                        target.rotation.x = Math.PI / 18;
                        target.scale.set(config.targetSize, config.targetSize, config.targetSize);
                        
                        targetGroup.add(target);
                        
                        const initialHeight = Math.random() * 
                                         (config.targetHeight.max - config.targetHeight.min) + 
                                         config.targetHeight.min;
                        const x = Math.random() * 60 - 30;
                        const z = Math.random() * 
                                  (config.spawnDistance.max - config.spawnDistance.min) + 
                                  config.spawnDistance.min;
                        
                        targetGroup.position.set(x, initialHeight, z);
                        
                        const speed = Math.random() * 
                                    (config.targetSpeed.max - config.targetSpeed.min) + 
                                    config.targetSpeed.min;
                        
                        targetGroup.userData = {
                            isTarget: true,
                            fadingIn: true,
                            speed: speed,
                            waveMotion: Math.random() > 0.5,
                            initialHeight: initialHeight,
                            waveOffset: Math.random() * Math.PI * 2,
                            canDropGrenade: Math.random() > 0.7
                        };
                        
                        targets.push(targetGroup);
                        scene.add(targetGroup);
                    },
                    undefined,
                    () => {
                        const initialHeight = Math.random() * 
                                         (config.targetHeight.max - config.targetHeight.min) + 
                                         config.targetHeight.min;
                        const x = Math.random() * 60 - 30;
                        const z = Math.random() * 
                                  (config.spawnDistance.max - config.spawnDistance.min) + 
                                  config.spawnDistance.min;
                        
                        const speed = Math.random() * 
                                    (config.targetSpeed.max - config.targetSpeed.min) + 
                                    config.targetSpeed.min;
                        
                        const target = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.5, 0.5, 0.1, 8),
                            new THREE.MeshStandardMaterial({ 
                                color: 0xff0000,
                                transparent: true,
                                opacity: 0
                            })
                        );
                        
                        target.castShadow = true;
                        target.receiveShadow = true;
                        target.position.set(x, initialHeight, z);
                        
                        target.userData = {
                            isTarget: true,
                            fadingIn: true,
                            speed: speed,
                            waveMotion: Math.random() > 0.5,
                            initialHeight: initialHeight,
                            waveOffset: Math.random() * Math.PI * 2,
                            canDropGrenade: Math.random() > 0.7
                        };
                        
                        targets.push(target);
                        scene.add(target);
                    }
                );
            }

            function dropGrenade(target) {
                if (Math.random() > config.grenadeSpawnChance) return;
                
                const grenade = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0x880000 })
                );
                
                grenade.position.copy(target.position);
                grenade.position.y -= 1;
                grenade.castShadow = true;
                grenade.receiveShadow = true;
                
                grenade.userData = {
                    isGrenade: true,
                    speed: 0.1,
                    fallSpeed: 0,
                    gravity: 0.01,
                    damage: 20,
                    timer: 100
                };
                
                grenades.push(grenade);
                scene.add(grenade);
            }

            function setupControls() {
                controls = new THREE.PointerLockControls(camera, renderer.domElement);
                
                document.getElementById('start-button').addEventListener('click', () => {
                    controls.lock().catch(e => {
                        alert("Нажмите на экран для блокировки курсора!");
                    });
                });

                controls.addEventListener('lock', () => {
                    isGameStarted = true;
                    document.getElementById('start-screen').style.display = 'none';
                });

                controls.addEventListener('unlock', () => {
                    isGameStarted = false;
                    document.getElementById('start-screen').style.display = 'flex';
                });

                document.addEventListener('keydown', (e) => {
                    if (!isGameStarted) return;
                    
                    switch(e.key.toLowerCase()) {
                        case 'w':
                            moveState.forward = true;
                            break;
                        case 's':
                            moveState.backward = true;
                            break;
                    }
                });

                document.addEventListener('keyup', (e) => {
                    switch(e.key.toLowerCase()) {
                        case 'w':
                            moveState.forward = false;
                            break;
                        case 's':
                            moveState.backward = false;
                            break;
                    }
                });
            }

            function updatePlayerPosition() {
                if (!isGameStarted) return;
                
                const moveVector = new THREE.Vector3();
                const direction = new THREE.Vector3();
                
                // Получаем текущее направление взгляда (игнорируя вертикальный компонент)
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();
                
                if (moveState.forward) {
                    moveVector.add(direction.multiplyScalar(config.playerSpeed));
                }
                if (moveState.backward) {
                    moveVector.add(direction.multiplyScalar(-config.playerSpeed));
                }

                if (moveVector.length() > 0) {
                    const newPosition = controls.getObject().position.clone().add(moveVector);
                    
                    // Проверка границ
                    if (newPosition.x > config.playerBounds.minX && newPosition.x < config.playerBounds.maxX &&
                        newPosition.z > config.playerBounds.minZ && newPosition.z < config.playerBounds.maxZ) {
                        controls.getObject().position.copy(newPosition);
                    }
                }
            }

            function checkGrenadeCollisions() {
                for (let i = grenades.length - 1; i >= 0; i--) {
                    const grenade = grenades[i];
                    
                    grenade.position.y -= grenade.userData.fallSpeed;
                    grenade.userData.fallSpeed += grenade.userData.gravity;
                    grenade.userData.timer--;
                    
                    if (grenade.userData.timer <= 0 || grenade.position.y <= 0) {
                        explodeGrenade(grenade);
                        scene.remove(grenade);
                        grenades.splice(i, 1);
                        continue;
                    }
                    
                    const distanceToPlayer = grenade.position.distanceTo(controls.getObject().position);
                    if (distanceToPlayer < 2) {
                        takeDamage(grenade.userData.damage);
                        scene.remove(grenade);
                        grenades.splice(i, 1);
                    }
                }
            }

            function explodeGrenade(grenade) {
                const explosionGeometry = new THREE.SphereGeometry(1, 8, 8);
                const explosionMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.7
                });
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosion.position.copy(grenade.position);
                scene.add(explosion);
                
                setTimeout(() => {
                    scene.remove(explosion);
                }, 200);
            }

            function takeDamage(amount) {
                health -= amount;
                updateHUD();
                
                if (health <= 0) {
                    gameOver();
                }
            }

            function gameOver() {
                isGameStarted = false;
                controls.unlock();
                document.getElementById('start-screen').style.display = 'flex';
                document.getElementById('start-button').textContent = 'Играть снова';
                
                resetGame();
            }

            function resetGame() {
                targets.forEach(target => scene.remove(target));
                landscape.forEach(obj => scene.remove(obj));
                grenades.forEach(grenade => scene.remove(grenade));
                
                targets = [];
                landscape = [];
                grenades = [];
                ammoCount = config.ammoStart;
                score = 0;
                health = config.healthStart;
                
                controls.getObject().position.set(0, config.playerHeight, 0);
                
                createGround();
                loadModels();
                updateHUD();
            }

            function shoot() {
                if (ammoCount <= 0 || !isGameStarted) return;
                
                ammoCount--;
                updateHUD();

                if (gun) {
                    gun.position.z += 0.1;
                    setTimeout(() => gun.position.z -= 0.1, 100);
                }

                const raycaster = new THREE.Raycaster(
                    camera.position,
                    camera.getWorldDirection(new THREE.Vector3())
                );
                
                const intersects = raycaster.intersectObjects(scene.children, true);
                
                for (const intersect of intersects) {
                    let obj = intersect.object;
                    
                    while (obj) {
                        if (obj.userData.isTarget) {
                            let targetToRemove = obj;
                            while (targetToRemove.parent && targetToRemove.parent.userData.isTarget) {
                                targetToRemove = targetToRemove.parent;
                            }
                            
                            scene.remove(targetToRemove);
                            targets = targets.filter(t => t !== targetToRemove);
                            
                            score += 10;
                            updateHUD();
                            
                            spawnNewTarget();
                            
                            return;
                        }
                        obj = obj.parent;
                    }
                }
            }

            function reload() {
                ammoCount = config.ammoStart;
                updateHUD();
            }

            function updateHUD() {
                document.getElementById('ammo').textContent = `Патроны: ${ammoCount}`;
                document.getElementById('score').textContent = `Очки: ${score}`;
                document.getElementById('health').textContent = `Здоровье: ${Math.max(0, health)}`;
            }

            function setupEventListeners() {
                window.addEventListener('resize', onWindowResize);
                document.addEventListener('mousedown', onMouseDown);
                document.addEventListener('keydown', onKeyDown);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function onMouseDown(e) {
                if (e.button === 0 && isGameStarted) shoot();
            }

            function onKeyDown(e) {
                if (e.key === 'r' && isGameStarted) reload();
            }

            function animate() {
                requestAnimationFrame(animate);
                
                if (isGameStarted) {
                    updatePlayerPosition();
                    
                    targets.forEach(target => {
                        target.position.z += target.userData.speed;
                        
                        if (target.userData.waveMotion) {
                            target.position.y = target.userData.initialHeight + 
                                            Math.sin(target.position.z * config.waveFrequency + 
                                            target.userData.waveOffset) * config.waveAmplitude;
                        }
                        
                        if (target.userData.canDropGrenade) {
                            dropGrenade(target);
                        }
                        
                        if (target.position.y < config.minTargetHeight) {
                            target.position.y = config.minTargetHeight;
                        }
                        
                        if (target.userData.fadingIn && target.position.z < config.spawnDistance.max + config.fadeDistance) {
                            const fadeProgress = Math.min(1, (target.position.z - config.spawnDistance.max) / config.fadeDistance);
                            target.traverse(child => {
                                if (child.isMesh) {
                                    child.material.opacity = fadeProgress;
                                }
                            });
                            if (fadeProgress >= 1) {
                                target.userData.fadingIn = false;
                            }
                        }
                        
                        if (target.position.z > config.despawnDistance - config.fadeDistance) {
                            const fadeProgress = 1 - Math.min(1, (target.position.z - (config.despawnDistance - config.fadeDistance)) / config.fadeDistance);
                            target.traverse(child => {
                                if (child.isMesh) {
                                    child.material.opacity = fadeProgress;
                                }
                            });
                        }
                        
                        if (target.position.z > config.despawnDistance) {
                            scene.remove(target);
                            targets = targets.filter(t => t !== target);
                            spawnNewTarget();
                        }
                    });
                    
                    checkGrenadeCollisions();
                }

                renderer.render(scene, camera);
            }

            return { init };
        })();

        window.onload = DronoBoy.init;
    </script>
</body>

</html>
