<!DOCTYPE html>
<html>
<head>
    <title>DronoBoy - Эффект горизонта</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 4px black;
            z-index: 10;
        }
        #ammo, #score, #health { font-size: 24px; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            z-index: 10;
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            flex-direction: column;
            z-index: 20;
        }
        #start-button {
            padding: 10px 20px;
            font-size: 20px;
            background: #4CAF50;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.1s;
        }
        #start-button:hover {
            background: #3e8e41;
        }
        #start-button:active {
            transform: scale(0.95);
            background: #45a049;
        }
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0);
            pointer-events: none;
            transition: background-color 0.3s;
            z-index: 15;
        }
        #game-over {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            color: white;
            flex-direction: column;
            z-index: 25;
        }
        #final-score {
            font-size: 32px;
            margin-bottom: 20px;
        }
        #restart-button {
            padding: 10px 20px;
            font-size: 20px;
            background: #4CAF50;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.1s;
        }
        #restart-button:hover {
            background: #3e8e41;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="hud">
        <div id="ammo">Патроны: 30</div>
        <div id="score">Очки: 0</div>
        <div id="health">Здоровье: 100</div>
    </div>
    <div id="crosshair"></div>
    <div id="damage-overlay"></div>
    <div id="start-screen">
        <h1>DronoBoy</h1>
        <p>Управление: WASD - движение, ЛКМ - стрельба, R - перезарядка</p>
        <button id="start-button">Начать игру</button>
    </div>
    <div id="game-over">
        <h1>Игра окончена!</h1>
        <div id="final-score">Ваш счет: 0</div>
        <button id="restart-button">Играть снова</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>

    <script>
        const DronoBoy = (() => {
            const config = {
                playerHeight: 1.7,
                gunPosition: { x: 0.4, y: -0.5, z: -1.35 },
                gunScale: 0.9,
                
                bombers: {
                    count: 8,
                    speed: { min: 0.1, max: 0.15 },
                    heightRange: { min: 15, max: 30 },
                    bombChance: 0.03,
                    bombIntensity: 1.0,
                    minBombInterval: 1000,
                    maxBombInterval: 3000,
                    damage: 20,
                    color: 0xcc0000,
                    size: 2.0,
                    spawnInterval: { min: 2000, max: 4000 },
                    waveSettings: {
                        density: 0.4,
                        widthSpread: 0.6,
                        formationType: 'line',
                        clusterSize: 3,
                        waveInterval: { min: 1000, max: 2000 }
                    },
                    fadeInDuration: 1500
                },
                kamikaze: {
                    count: 5,
                    speed: { min: 0.03, max: 0.18 },
                    heightRange: { min: 3.5, max: 12 },
                    trackingSpeed: 0.02,
                    attackStartDistance: 25,
                    damage: 30,
                    explosionRange: 5,
                    attackSpeedMultiplier: 1.5,
                    attackHeightRange: { min: 0.9, max: 1.8 },
                    formationSpread: { 
                        horizontal: 3, 
                        vertical: 2
                    },
                    gravity: 0.05,
                    rotationSpeed: 0.1,
                    color: 0x0000cc,
                    size: 1.0,
                    spawnInterval: { min: 1500, max: 3000 },
                    minExplosionHeight: 0.3,
                    explosionDamageFalloff: 0.8,
                    missedTurnAroundDistance: { min: 30, max: 60 },
                    turnAroundSpeedMultiplier: 1.8,
                    turnAroundDuration: 2000,
                    waveSettings: {
                        density: 0.4,
                        widthSpread: 0.3,
                        formationType: 'line',
                        clusterSize: 2,
                        waveInterval: { min: 800, max: 1500 }
                    },
                    fadeInDuration: 1500,
                    firstWave: {
                        count: 1,
                        distance: { min:90, max: 120 },
                        xSpread: 7,
                        delayBetween: 500,
                        spawnDelay: 500
                    }
                },
                spawnDistance: { min: 100, max: 150 },
                despawnDistance: 150,
                fadeDistance: { start: 80, end: 120 },
                waveAmplitude: 3,
                waveFrequency: 0.1,
                landscapeObjects: {
                    count: 90,
                    scaleRange: { min: 10.5, max: 20.0 },
                    positionRange: { x: 45, z: 80 }
                },
                safeRadius: 3,
                targetMovementRangeX: 40,
                landscapeSafeMargin: 5,
                minDistanceBetweenObjects: 3,
                playerSpeed: 0.2,
                healthStart: 100,
                playerBoundsExtension: 25,
                groundExtension: 100,
                ammoStart: 30,
                damageEffects: {
                    cameraShakeDuration: 500,
                    cameraShakeIntensity: 0.5,
                    damageOverlayDuration: 300,
                    damageOverlayOpacity: 0.5
                },
                edgeCurvature: 0.0002,
                fogDensity: 0.01
            };

            let scene, camera, renderer, controls;
            let gun, bombers = [], kamikaze = [], landscape = [], grenades = [], particles = [];
            let ammoCount = config.ammoStart, score = 0, health = config.healthStart;
            let isGameStarted = false;
            let moveState = { forward: false, backward: false, left: false, right: false };
            let damageOverlay = document.getElementById('damage-overlay');
            let isCameraShaking = false;
            let cameraOriginalPosition = new THREE.Vector3();
            let lastDamageTime = 0;
            let nextBomberWaveTime = 0;
            let nextKamikazeWaveTime = 0;
            let isGunRecoiling = false;
            let gunRecoilAnimationId = null;

            function init() {
                createScene();
                setupCamera();
                setupRenderer();
                createLighting();
                createGround();
                loadModels();
                setupControls();
                setupEventListeners();
                animate();
            }

            function createScene() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB);
                scene.fog = new THREE.FogExp2(0x87CEEB, config.fogDensity);
            }

            function setupCamera() {
                camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                camera.position.y = config.playerHeight;
                scene.add(camera);
            }

            function setupRenderer() {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('game-container').appendChild(renderer.domElement);
            }

            function createLighting() {
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 2, 1);
                directionalLight.castShadow = true;
                
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -100;
                directionalLight.shadow.camera.right = 100;
                directionalLight.shadow.camera.top = 100;
                directionalLight.shadow.camera.bottom = -100;
                
                scene.add(directionalLight);

                const fillLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.3);
                scene.add(fillLight);

                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-5, 3, -5);
                scene.add(backLight);
            }

            function createGround() {
                const groundWidth = config.landscapeObjects.positionRange.x * 2 + config.groundExtension * 2;
                const groundHeight = config.landscapeObjects.positionRange.z * 2 + config.groundExtension * 2;
                
                const ground = new THREE.Mesh(
                    new THREE.PlaneGeometry(groundWidth, groundHeight, 100, 100),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x2a4d0b,
                        roughness: 0.8,
                        metalness: 0.1
                    })
                );
                
                const pos = ground.geometry.attributes.position;
                for (let i = 0; i < pos.count; i++) {
                    const x = pos.getX(i);
                    const z = pos.getZ(i);
                    const curveFactor = config.edgeCurvature * x * x;
                    pos.setZ(i, z * (1 + curveFactor));
                }
                pos.needsUpdate = true;
                
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                ground.userData.isGround = true;
                scene.add(ground);
            }

            function loadModels() {
                createFallbackGun();
                loadLandscapeObjects();
                nextBomberWaveTime = Date.now();
                nextKamikazeWaveTime = Date.now();
            }

            function createFallbackGun() {
                const gunGroup = new THREE.Group();
                
                // Основа оружия
                const gunBody = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.1, 1.0),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x444444,
                        roughness: 0.3,
                        metalness: 0.7
                    })
                );
                gunBody.position.z = -0.5;
                gunBody.castShadow = true;
                gunGroup.add(gunBody);
                
                // Рукоятка
                const gunHandle = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.3, 0.2),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x222222,
                        roughness: 0.8,
                        metalness: 0.2
                    })
                );
                gunHandle.position.y = -0.2;
                gunHandle.position.z = -0.3;
                gunHandle.castShadow = true;
                gunGroup.add(gunHandle);
                
                // Дуло
                const gunBarrel = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 0.7, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x888888,
                        roughness: 0.2,
                        metalness: 0.8
                    })
                );
                gunBarrel.rotation.x = Math.PI / 2;
                gunBarrel.position.z = -0.9;
                gunBarrel.castShadow = true;
                gunGroup.add(gunBarrel);
                
                gunGroup.position.set(
                    config.gunPosition.x, 
                    config.gunPosition.y, 
                    config.gunPosition.z
                );
                gunGroup.scale.set(
                    config.gunScale, 
                    config.gunScale, 
                    config.gunScale
                );
                
                gun = gunGroup;
                camera.add(gun);
            }

            function spawnBomberWave() {
                const waveSize = Math.max(1, Math.floor(config.bombers.count * config.bombers.waveSettings.density));
                const basePosition = getRandomSpawnPosition(config.bombers.waveSettings);
                
                if (!basePosition) return;
                
                for (let i = 0; i < waveSize; i++) {
                    const position = getWaveSpawnPosition(basePosition, config.bombers.waveSettings, i, waveSize);
                    
                    setTimeout(() => {
                        if (!isGameStarted) return;
                        
                        const bomber = createFallbackBomber(position);
                        bombers.push(bomber);
                        scene.add(bomber);
                    }, i * (Math.random() * 
                          (config.bombers.waveSettings.waveInterval.max - config.bombers.waveSettings.waveInterval.min) + 
                          config.bombers.waveSettings.waveInterval.min));
                }
                
                nextBomberWaveTime = Date.now() + 
                    (Math.random() * 
                    (config.bombers.spawnInterval.max - config.bombers.spawnInterval.min) + 
                    config.bombers.spawnInterval.min);
            }

            function spawnFirstKamikazeWave() {
                const waveSize = config.kamikaze.firstWave.count;
                const playerPos = controls.getObject().position;
                
                for (let i = 0; i < waveSize; i++) {
                    setTimeout(() => {
                        if (!isGameStarted) return;
                        
                        const x = (Math.random() * 2 - 1) * config.kamikaze.firstWave.xSpread;
                        const z = playerPos.z - (Math.random() * 
                              (config.kamikaze.firstWave.distance.max - config.kamikaze.firstWave.distance.min) + 
                              config.kamikaze.firstWave.distance.min);
                        
                        const kamikazeObj = createFallbackKamikaze({x, z});
                        kamikaze.push(kamikazeObj);
                        scene.add(kamikazeObj);
                    }, i * config.kamikaze.firstWave.delayBetween);
                }
                
                nextKamikazeWaveTime = Date.now() + config.kamikaze.firstWave.spawnDelay;
            }

            function spawnKamikazeWave() {
                const waveSize = Math.max(1, Math.floor(config.kamikaze.count * config.kamikaze.waveSettings.density));
                const basePosition = getRandomSpawnPosition(config.kamikaze.waveSettings);
                
                if (!basePosition) return;
                
                for (let i = 0; i < waveSize; i++) {
                    const position = getWaveSpawnPosition(basePosition, config.kamikaze.waveSettings, i, waveSize);
                    
                    setTimeout(() => {
                        if (!isGameStarted) return;
                        
                        const kamikazeObj = createFallbackKamikaze(position);
                        kamikaze.push(kamikazeObj);
                        scene.add(kamikazeObj);
                    }, i * (Math.random() * 
                          (config.kamikaze.waveSettings.waveInterval.max - config.kamikaze.waveSettings.waveInterval.min) + 
                          config.kamikaze.waveSettings.waveInterval.min));
                }
                
                nextKamikazeWaveTime = Date.now() + 
                    (Math.random() * 
                    (config.kamikaze.spawnInterval.max - config.kamikaze.spawnInterval.min) + 
                    config.kamikaze.spawnInterval.min);
            }

            function createFallbackBomber(position) {
                const initialHeight = Math.random() * 
                                   (config.bombers.heightRange.max - config.bombers.heightRange.min) + 
                                   config.bombers.heightRange.min;
                
                // Создаем бомбардировщик из примитивов
                const bomberGroup = new THREE.Group();
                
                // Корпус
                const body = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.8, 0.8, 2.5, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: config.bombers.color,
                        roughness: 0.7,
                        metalness: 0.3,
                        transparent: true,
                        opacity: 0.01
                    })
                );
                body.rotation.z = Math.PI / 2;
                body.castShadow = true;
                body.receiveShadow = true;
                bomberGroup.add(body);
                
                // Крылья
                const wing = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 0.1, 1),
                    new THREE.MeshStandardMaterial({ 
                        color: config.bombers.color,
                        roughness: 0.7,
                        metalness: 0.3,
                        transparent: true,
                        opacity: 0.01
                    })
                );
                wing.position.y = -0.2;
                wing.castShadow = true;
                wing.receiveShadow = true;
                bomberGroup.add(wing);
                
                // Хвост
                const tail = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 1, 1),
                    new THREE.MeshStandardMaterial({ 
                        color: config.bombers.color,
                        roughness: 0.7,
                        metalness: 0.3,
                        transparent: true,
                        opacity: 0.01
                    })
                );
                tail.position.x = -1.2;
                tail.position.y = 0.5;
                tail.castShadow = true;
                tail.receiveShadow = true;
                bomberGroup.add(tail);
                
                bomberGroup.position.set(position.x, initialHeight, position.z);
                bomberGroup.scale.set(
                    config.bombers.size * 0.5, 
                    config.bombers.size * 0.5, 
                    config.bombers.size * 0.5
                );
                
                const speed = Math.random() * 
                            (config.bombers.speed.max - config.bombers.speed.min) + 
                            config.bombers.speed.min;

                bomberGroup.userData = {
                    isTarget: true,
                    isBomber: true,
                    fadingIn: true,
                    fadeStartTime: Date.now(),
                    speed: speed,
                    waveMotion: Math.random() > 0.5,
                    initialHeight: initialHeight,
                    waveOffset: Math.random() * Math.PI * 2,
                    initialScale: config.bombers.size * 0.5,
                    color: config.bombers.color,
                    lastBombTime: 0,
                    baseSpeed: speed
                };
                
                return bomberGroup;
            }

            function createFallbackKamikaze(position) {
                const initialHeight = Math.random() * 
                                   (config.kamikaze.heightRange.max - config.kamikaze.heightRange.min) + 
                                   config.kamikaze.heightRange.min;
                
                // Создаем дрон-камикадзе из примитивов
                const kamikazeGroup = new THREE.Group();
                
                // Корпус
                const body = new THREE.Mesh(
                    new THREE.SphereGeometry(0.6, 16, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: config.kamikaze.color,
                        roughness: 0.7,
                        metalness: 0.3,
                        transparent: true,
                        opacity: 0.01
                    })
                );
                body.castShadow = true;
                body.receiveShadow = true;
                kamikazeGroup.add(body);
                
                // Крылья
                const wing = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.1, 0.5),
                    new THREE.MeshStandardMaterial({ 
                        color: config.kamikaze.color,
                        roughness: 0.7,
                        metalness: 0.3,
                        transparent: true,
                        opacity: 0.01
                    })
                );
                wing.position.y = -0.1;
                wing.castShadow = true;
                wing.receiveShadow = true;
                kamikazeGroup.add(wing);
                
                // Двигатели
                const engine = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 0.4, 12),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x333333,
                        roughness: 0.7,
                        metalness: 0.3,
                        transparent: true,
                        opacity: 0.01
                    })
                );
                engine.rotation.x = Math.PI / 2;
                engine.position.z = 0.5;
                engine.castShadow = true;
                engine.receiveShadow = true;
                kamikazeGroup.add(engine);
                
                const engine2 = engine.clone();
                engine2.position.z = -0.5;
                kamikazeGroup.add(engine2);
                
                kamikazeGroup.position.set(position.x, initialHeight, position.z);
                kamikazeGroup.scale.set(
                    config.kamikaze.size * 0.4, 
                    config.kamikaze.size * 0.4, 
                    config.kamikaze.size * 0.4
                );
                
                const speed = Math.random() * 
                            (config.kamikaze.speed.max - config.kamikaze.speed.min) + 
                            config.kamikaze.speed.min;

                kamikazeGroup.userData = {
                    isTarget: true,
                    isKamikaze: true,
                    fadingIn: true,
                    fadeStartTime: Date.now(),
                    speed: speed,
                    initialHeight: initialHeight,
                    initialScale: config.kamikaze.size * 0.4,
                    color: config.kamikaze.color,
                    baseSpeed: speed,
                    attackParams: {
                        attackStartDistance: config.kamikaze.attackStartDistance,
                        fixedTargetPoint: null,
                        isInFinalAttack: false,
                        isTurningAround: false,
                        turnAroundStartTime: 0,
                        originalSpeed: 0,
                        turnAroundPoint: null,
                        gravity: config.kamikaze.gravity,
                        speedMultiplier: config.kamikaze.attackSpeedMultiplier,
                        explosionDistance: config.kamikaze.explosionRange,
                        formationOffset: new THREE.Vector3(
                            (Math.random() - 0.5) * 2 * config.kamikaze.formationSpread.horizontal,
                            (Math.random() - 0.5) * 2 * config.kamikaze.formationSpread.vertical,
                            0
                        ),
                        targetRotation: 0
                    }
                };
                
                return kamikazeGroup;
            }

            function loadLandscapeObjects() {
                const placedObjects = [];
                
                for (let i = 0; i < config.landscapeObjects.count; i++) {
                    const position = getRandomSafePosition(placedObjects);
                    
                    if (!position) continue;
                    
                    // Создаем случайные объекты ландшафта
                    const isTree = Math.random() > 0.3;
                    let obj;
                    
                    if (isTree) {
                        // Дерево
                        const trunk = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.4, 2, 8),
                            new THREE.MeshStandardMaterial({ 
                                color: 0x5D4037,
                                roughness: 0.9,
                                metalness: 0.1
                            })
                        );
                        trunk.position.y = 1;
                        trunk.castShadow = true;
                        trunk.receiveShadow = true;
                        
                        const leaves = new THREE.Mesh(
                            new THREE.ConeGeometry(1.5, 3, 8),
                            new THREE.MeshStandardMaterial({ 
                                color: 0x1B5E20,
                                roughness: 0.9,
                                metalness: 0.1
                            })
                        );
                        leaves.position.y = 3;
                        leaves.castShadow = true;
                        leaves.receiveShadow = true;
                        
                        obj = new THREE.Group();
                        obj.add(trunk);
                        obj.add(leaves);
                    } else {
                        // Камень
                        obj = new THREE.Mesh(
                            new THREE.DodecahedronGeometry(1, 0),
                            new THREE.MeshStandardMaterial({ 
                                color: 0x757575,
                                roughness: 0.9,
                                metalness: 0.1
                            })
                        );
                        obj.castShadow = true;
                        obj.receiveShadow = true;
                    }
                    
                    const scale = Math.random() * 
                               (config.landscapeObjects.scaleRange.max - config.landscapeObjects.scaleRange.min) + 
                               config.landscapeObjects.scaleRange.min;
                    
                    obj.scale.set(scale, scale, scale);
                    obj.position.set(position.x, 0, position.z);
                    obj.rotation.y = Math.random() * Math.PI * 2;
                    obj.userData.isLandscape = true;
                    
                    landscape.push(obj);
                    placedObjects.push(obj);
                    scene.add(obj);
                }
            }

            function getRandomSpawnPosition(waveSettings) {
                const playerPos = controls.getObject().position;
                let x, z;
                let attempts = 0;
                const maxAttempts = 50;
                
                do {
                    const widthFactor = waveSettings ? waveSettings.widthSpread : 1;
                    x = (Math.random() * 2 - 1) * config.targetMovementRangeX * widthFactor;
                    
                    z = playerPos.z - (Math.random() * 
                        (config.spawnDistance.max - config.spawnDistance.min) + 
                        config.spawnDistance.min);
                    attempts++;
                    
                    const screenPos = new THREE.Vector3(x, config.bombers.heightRange.min, z)
                        .project(camera);
                    if (Math.abs(screenPos.x) < 1.5 && Math.abs(screenPos.y) < 1.5) {
                        continue;
                    }
                } while (!isPositionSafe(x, z) && attempts < maxAttempts);
                
                return attempts < maxAttempts ? { x, z } : null;
            }

            function getWaveSpawnPosition(basePosition, waveSettings, index, totalInWave) {
                if (!waveSettings) return basePosition;
                
                let x = basePosition.x;
                const z = basePosition.z;
                
                switch(waveSettings.formationType) {
                    case 'line':
                        x = -config.targetMovementRangeX * waveSettings.widthSpread + 
                            (2 * config.targetMovementRangeX * waveSettings.widthSpread / (totalInWave - 1)) * index;
                        break;
                        
                    case 'cluster':
                        const clusterIndex = Math.floor(index / waveSettings.clusterSize);
                        const clusterOffset = (Math.random() - 0.5) * 5;
                        x = -config.targetMovementRangeX * waveSettings.widthSpread + 
                            (2 * config.targetMovementRangeX * waveSettings.widthSpread / 
                            (Math.ceil(totalInWave / waveSettings.clusterSize) - 1)) * clusterIndex + clusterOffset;
                        break;
                        
                    case 'random':
                        x = (Math.random() * 2 - 1) * config.targetMovementRangeX * waveSettings.widthSpread;
                        break;
                }
                
                return { x, z };
            }

            function isPositionSafe(x, z) {
                return Math.sqrt(x*x + z*z) > config.safeRadius;
            }

            function isPositionValid(x, z, objects) {
                if (!isPositionSafe(x, z)) return false;
                
                if (Math.abs(x) < config.targetMovementRangeX + config.landscapeSafeMargin) {
                    return false;
                }
                
                for (const obj of objects) {
                    const dx = x - obj.position.x;
                    const dz = z - obj.position.z;
                    const distance = Math.sqrt(dx*dx + dz*dz);
                    
                    if (distance < config.minDistanceBetweenObjects) {
                        return false;
                    }
                }
                
                return true;
            }

            function getRandomSafePosition(existingObjects) {
                let x, z;
                let attempts = 0;
                const maxAttempts = 100;
                
                const xRange = config.landscapeObjects.positionRange.x;
                const zRange = config.landscapeObjects.positionRange.z;
                
                const leftZone = {
                    min: -xRange,
                    max: -config.targetMovementRangeX - config.landscapeSafeMargin
                };
                
                const rightZone = {
                    min: config.targetMovementRangeX + config.landscapeSafeMargin,
                    max: xRange
                };
                
                do {
                    const zone = Math.random() > 0.5 ? leftZone : rightZone;
                    x = Math.random() * (zone.max - zone.min) + zone.min;
                    z = Math.random() * zRange * 2 - zRange;
                    attempts++;
                } while (!isPositionValid(x, z, existingObjects) && attempts < maxAttempts);
                
                return attempts < maxAttempts ? { x, z } : null;
            }

            function updateTargetVisibility(target) {
                const distanceToPlayer = target.position.distanceTo(camera.position);
                
                if (distanceToPlayer > config.fadeDistance.start) {
                    const fadeProgress = 1 - Math.min(1, 
                        (distanceToPlayer - config.fadeDistance.start) / 
                        (config.fadeDistance.end - config.fadeDistance.start));
                    
                    target.traverse(child => {
                        if (child.isMesh) {
                            child.material.opacity = fadeProgress;
                            const scale = target.userData.initialScale * fadeProgress;
                            child.scale.set(scale, scale, scale);
                        }
                    });
                    
                    if (fadeProgress <= 0) {
                        return false;
                    }
                }
                return true;
            }

            function dropGrenade(bomber, currentTime) {
                if (currentTime - bomber.userData.lastBombTime < 
                    Math.random() * (config.bombers.maxBombInterval - config.bombers.minBombInterval) + 
                    config.bombers.minBombInterval) {
                    return;
                }
                
                if (Math.random() > config.bombers.bombChance * config.bombers.bombIntensity) {
                    return;
                }
                
                const grenade = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x660000,
                        roughness: 0.8
                    })
                );
                
                grenade.position.copy(bomber.position);
                grenade.position.y -= 1;
                grenade.castShadow = true;
                grenade.receiveShadow = true;
                
                grenade.userData = {
                    isGrenade: true,
                    speed: 0.1,
                    fallSpeed: 0,
                    gravity: 0.01,
                    damage: config.bombers.damage,
                    timer: 100
                };
                
                grenades.push(grenade);
                scene.add(grenade);
                bomber.userData.lastBombTime = currentTime;
            }

            function startTurnAround(kamikazeObj) {
                const attack = kamikazeObj.userData.attackParams;
                attack.isTurningAround = true;
                attack.turnAroundStartTime = Date.now();
                attack.originalSpeed = kamikazeObj.userData.speed;
                kamikazeObj.userData.speed *= config.kamikaze.turnAroundSpeedMultiplier;
                
                const player = controls.getObject().position;
                attack.turnAroundPoint = new THREE.Vector3(
                    player.x + (Math.random() - 0.5) * 10,
                    Math.max(config.kamikaze.minExplosionHeight, player.y + (Math.random() - 0.5) * 3),
                    player.z + 20 + Math.random() * 10
                );
            }

            function handleTurnAround(kamikazeObj) {
                const attack = kamikazeObj.userData.attackParams;
                const targetPos = kamikazeObj.position;
                const turnAroundPoint = attack.turnAroundPoint;
                
                const direction = new THREE.Vector3().subVectors(turnAroundPoint, targetPos).normalize();
                targetPos.x += direction.x * kamikazeObj.userData.speed;
                targetPos.y += direction.y * kamikazeObj.userData.speed;
                targetPos.z += direction.z * kamikazeObj.userData.speed;
                
                if (targetPos.distanceTo(turnAroundPoint) < 2 || 
                    Date.now() - attack.turnAroundStartTime > config.kamikaze.turnAroundDuration) {
                    
                    attack.isTurningAround = false;
                    attack.isInFinalAttack = true;
                    attack.fixedTargetPoint = new THREE.Vector3(
                        controls.getObject().position.x,
                        Math.max(
                            config.kamikaze.minExplosionHeight,
                            Math.random() * 
                            (config.kamikaze.attackHeightRange.max - config.kamikaze.attackHeightRange.min) + 
                            config.kamikaze.attackHeightRange.min
                        ),
                        controls.getObject().position.z
                    );
                }
                
                // Поворачиваем модель в направлении движения
                let targetRotation = Math.atan2(direction.x, direction.z);
                kamikazeObj.rotation.y = targetRotation;
                
                return false;
            }

            function kamikazeAttack(kamikazeObj) {
                const player = controls.getObject().position;
                const targetPos = kamikazeObj.position;
                const attack = kamikazeObj.userData.attackParams;

                if (!attack.isInFinalAttack && !attack.isTurningAround && 
                    targetPos.z > player.z + config.kamikaze.missedTurnAroundDistance.min) {
                    
                    const turnAroundDist = Math.random() * 
                        (config.kamikaze.missedTurnAroundDistance.max - 
                         config.kamikaze.missedTurnAroundDistance.min) + 
                         config.kamikaze.missedTurnAroundDistance.min;
                    
                    if (targetPos.z > player.z + turnAroundDist) {
                        startTurnAround(kamikazeObj);
                    }
                }

                if (attack.isTurningAround) {
                    return handleTurnAround(kamikazeObj);
                }

                const direction = new THREE.Vector3();
                
                if (!attack.isInFinalAttack) {
                    direction.set(0, 0, 1);
                    
                    const distanceToPlayer = targetPos.distanceTo(player);
                    if (distanceToPlayer < attack.attackStartDistance) {
                        attack.isInFinalAttack = true;
                        attack.fixedTargetPoint = new THREE.Vector3(
                            player.x, 
                            Math.max(
                                config.kamikaze.minExplosionHeight,
                                Math.random() * 
                                (config.kamikaze.attackHeightRange.max - config.kamikaze.attackHeightRange.min) + 
                                config.kamikaze.attackHeightRange.min
                            ),
                            player.z
                        );
                    }
                } else {
                    direction.subVectors(attack.fixedTargetPoint, targetPos).normalize();
                    direction.y -= config.kamikaze.gravity;
                    direction.normalize();

                    const distanceToTarget = targetPos.distanceTo(attack.fixedTargetPoint);
                    if (distanceToTarget < 1.0) {
                        const explosionPos = targetPos.clone();
                        explodeTarget(kamikazeObj, true);
                        
                        const distanceToPlayer = explosionPos.distanceTo(player);
                        const explosionRadius = config.kamikaze.explosionRange;
                        
                        if (distanceToPlayer < explosionRadius) {
                            const damage = config.kamikaze.damage * 
                                         Math.pow(1 - distanceToPlayer / explosionRadius, config.kamikaze.explosionDamageFalloff);
                            takeDamage(damage);
                            showDamageEffects();
                        }
                        return true;
                    }
                }

                // Поворачиваем модель в направлении движения
                let targetRotation = Math.atan2(direction.x, direction.z);
                kamikazeObj.rotation.y = targetRotation;

                kamikazeObj.userData.speed = attack.isInFinalAttack ? 
                    kamikazeObj.userData.baseSpeed * attack.speedMultiplier : 
                    kamikazeObj.userData.baseSpeed;

                targetPos.x += direction.x * kamikazeObj.userData.speed;
                targetPos.z += direction.z * kamikazeObj.userData.speed;
                targetPos.y += direction.y * kamikazeObj.userData.speed;

                if (attack.isInFinalAttack && targetPos.y <= config.kamikaze.minExplosionHeight) {
                    const explosionPos = targetPos.clone();
                    explodeTarget(kamikazeObj, true);
                    
                    const distanceToPlayer = explosionPos.distanceTo(player);
                    const explosionRadius = config.kamikaze.explosionRange;
                    
                    if (distanceToPlayer < explosionRadius) {
                        const damage = config.kamikaze.damage * 
                                     Math.pow(1 - distanceToPlayer / explosionRadius, config.kamikaze.explosionDamageFalloff);
                        takeDamage(damage);
                        showDamageEffects();
                    }
                    return true;
                }

                return false;
            }

            function showDamageEffects() {
                const now = Date.now();
                if (now - lastDamageTime < 1000) return;
                lastDamageTime = now;
                
                damageOverlay.style.backgroundColor = 'rgba(255, 0, 0, ' + 
                    config.damageEffects.damageOverlayOpacity + ')';
                
                setTimeout(() => {
                    damageOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0)';
                }, config.damageEffects.damageOverlayDuration);
                
                if (!isCameraShaking) {
                    isCameraShaking = true;
                    cameraOriginalPosition.copy(camera.position);
                    
                    const shakeEndTime = Date.now() + config.damageEffects.cameraShakeDuration;
                    const intensity = config.damageEffects.cameraShakeIntensity;
                    
                    const shakeCamera = () => {
                        if (Date.now() > shakeEndTime) {
                            camera.position.copy(cameraOriginalPosition);
                            isCameraShaking = false;
                            return;
                        }
                        
                        camera.position.x = cameraOriginalPosition.x + 
                            (Math.random() * 2 - 1) * intensity;
                        camera.position.y = cameraOriginalPosition.y + 
                            (Math.random() * 2 - 1) * intensity;
                        camera.position.z = cameraOriginalPosition.z + 
                            (Math.random() * 2 - 1) * intensity;
                        
                        requestAnimationFrame(shakeCamera);
                    };
                    
                    shakeCamera();
                }
            }

            function createExplosionParticles(position, color) {
                const particleCount = 20;
                
                for (let i = 0; i < particleCount; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.copy(position);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.1 + Math.random() * 0.1;
                    const radius = 0.5 + Math.random() * 1;
                    
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            Math.cos(angle) * speed,
                            Math.random() * 0.1,
                            Math.sin(angle) * speed
                        ),
                        life: 100,
                        maxLife: 100
                    };
                    
                    particles.push(particle);
                    scene.add(particle);
                }
            }

            function updateParticles() {
                for (let i = particles.length - 1; i >= 0; i--) {
                    const particle = particles[i];
                    
                    particle.position.add(particle.userData.velocity);
                    particle.userData.life--;
                    
                    const scale = 0.5 * (particle.userData.life / particle.userData.maxLife);
                    particle.scale.set(scale, scale, scale);
                    
                    if (particle.userData.life <= 0) {
                        scene.remove(particle);
                        particles.splice(i, 1);
                    }
                }
            }

            function explodeTarget(target, isKamikaze = false) {
                const explosionGeometry = new THREE.SphereGeometry(isKamikaze ? 2 : 1.5, 16, 16);
                const explosionMaterial = new THREE.MeshStandardMaterial({
                    color: target.userData.color,
                    transparent: true,
                    opacity: 0.7,
                    roughness: 0.5,
                    emissive: isKamikaze ? 0xff0000 : 0xff6600,
                    emissiveIntensity: 0.5
                });
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosion.position.copy(target.position);
                scene.add(explosion);
                
                if (target.userData.isBomber) {
                    bombers = bombers.filter(b => b !== target);
                } else if (target.userData.isKamikaze) {
                    kamikaze = kamikaze.filter(k => k !== target);
                }
                
                scene.remove(target);
                
                // Создаем частицы взрыва
                createExplosionParticles(target.position, target.userData.color);
                
                setTimeout(() => {
                    scene.remove(explosion);
                }, 300);
            }

            function setupControls() {
                controls = new THREE.PointerLockControls(camera, renderer.domElement);
                
                const startButton = document.getElementById('start-button');
                const restartButton = document.getElementById('restart-button');
                
                startButton.addEventListener('click', () => {
                    try {
                        const promise = controls.lock();
                        if (promise) {
                            promise.catch(e => {
                                console.error("Ошибка блокировки указателя:", e);
                                // Эмуляция для тестирования
                                isGameStarted = true;
                                document.getElementById('start-screen').style.display = 'none';
                                nextBomberWaveTime = Date.now();
                                spawnFirstKamikazeWave();
                            });
                        }
                    } catch (e) {
                        console.error("Ошибка при блокировке указателя:", e);
                    }
                });

                restartButton.addEventListener('click', () => {
                    document.getElementById('game-over').style.display = 'none';
                    resetGame();
                    
                    try {
                        const promise = controls.lock();
                        if (promise) {
                            promise.catch(e => {
                                console.error("Ошибка блокировки указателя:", e);
                            });
                        }
                    } catch (e) {
                        console.error("Ошибка при блокировке указателя:", e);
                    }
                });

                controls.addEventListener('lock', () => {
                    isGameStarted = true;
                    document.getElementById('start-screen').style.display = 'none';
                    nextBomberWaveTime = Date.now();
                    spawnFirstKamikazeWave();
                });

                controls.addEventListener('unlock', () => {
                    isGameStarted = false;
                    document.getElementById('start-screen').style.display = 'flex';
                });

                document.addEventListener('keydown', (e) => {
                    if (!isGameStarted) return;
                    
                    switch(e.key.toLowerCase()) {
                        case 'w':
                            moveState.forward = true;
                            break;
                        case 's':
                            moveState.backward = true;
                            break;
                        case 'a':
                            moveState.left = true;
                            break;
                        case 'd':
                            moveState.right = true;
                            break;
                        case 'r':
                            reload();
                            break;
                    }
                });

                document.addEventListener('keyup', (e) => {
                    switch(e.key.toLowerCase()) {
                        case 'w':
                            moveState.forward = false;
                            break;
                        case 's':
                            moveState.backward = false;
                            break;
                        case 'a':
                            moveState.left = false;
                            break;
                        case 'd':
                            moveState.right = false;
                            break;
                    }
                });
            }

            function updatePlayerPosition() {
                if (!isGameStarted) return;
                
                const moveVector = new THREE.Vector3();
                const direction = new THREE.Vector3();
                
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();
                
                if (moveState.forward) {
                    moveVector.add(direction.multiplyScalar(config.playerSpeed));
                }
                if (moveState.backward) {
                    moveVector.add(direction.multiplyScalar(-config.playerSpeed));
                }
                
                // Боковое движение
                if (moveState.left) {
                    const leftDirection = new THREE.Vector3()
                        .crossVectors(direction, new THREE.Vector3(0, 1, 0))
                        .normalize();
                    moveVector.add(leftDirection.multiplyScalar(-config.playerSpeed));
                }
                if (moveState.right) {
                    const rightDirection = new THREE.Vector3()
                        .crossVectors(direction, new THREE.Vector3(0, 1, 0))
                        .normalize();
                    moveVector.add(rightDirection.multiplyScalar(config.playerSpeed));
                }

                if (moveVector.length() > 0) {
                    const newPosition = controls.getObject().position.clone().add(moveVector);
                    
                    const bounds = {
                        minX: -config.landscapeObjects.positionRange.x - config.playerBoundsExtension,
                        maxX: config.landscapeObjects.positionRange.x + config.playerBoundsExtension,
                        minZ: -config.landscapeObjects.positionRange.z - config.playerBoundsExtension,
                        maxZ: config.landscapeObjects.positionRange.z + config.playerBoundsExtension
                    };
                    
                    if (newPosition.x > bounds.minX && newPosition.x < bounds.maxX &&
                        newPosition.z > bounds.minZ && newPosition.z < bounds.maxZ) {
                        controls.getObject().position.copy(newPosition);
                    }
                }
            }

            function checkGrenadeCollisions() {
                for (let i = grenades.length - 1; i >= 0; i--) {
                    const grenade = grenades[i];
                    
                    grenade.position.y -= grenade.userData.fallSpeed;
                    grenade.userData.fallSpeed += grenade.userData.gravity;
                    grenade.userData.timer--;
                    
                    if (grenade.userData.timer <= 0 || grenade.position.y <= 0) {
                        explodeGrenade(grenade);
                        scene.remove(grenade);
                        grenades.splice(i, 1);
                        continue;
                    }
                    
                    const distanceToPlayer = grenade.position.distanceTo(controls.getObject().position);
                    if (distanceToPlayer < 1.5) {
                        takeDamage(grenade.userData.damage);
                        showDamageEffects();
                        scene.remove(grenade);
                        grenades.splice(i, 1);
                    }
                }
            }

            function explodeGrenade(grenade) {
                const explosionGeometry = new THREE.SphereGeometry(1, 8, 8);
                const explosionMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff5500,
                    transparent: true,
                    opacity: 0.6,
                    roughness: 0.5
                });
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosion.position.copy(grenade.position);
                scene.add(explosion);
                
                // Создаем частицы взрыва
                createExplosionParticles(grenade.position, 0xff5500);
                
                setTimeout(() => {
                    scene.remove(explosion);
                }, 200);
            }

            function takeDamage(amount) {
                health -= Math.floor(amount);
                updateHUD();
                
                if (health <= 0) {
                    gameOver();
                }
            }

            function gameOver() {
                isGameStarted = false;
                controls.unlock();
                
                document.getElementById('final-score').textContent = `Ваш счет: ${score}`;
                document.getElementById('game-over').style.display = 'flex';
            }

            function resetGame() {
                // Останавливаем анимацию отдачи
                if (gunRecoilAnimationId !== null) {
                    cancelAnimationFrame(gunRecoilAnimationId);
                    gunRecoilAnimationId = null;
                }
                isGunRecoiling = false;
                
                // Полностью удаляем оружие
                if (gun) {
                    camera.remove(gun);
                    gun = null;
                }
                
                bombers.forEach(bomber => scene.remove(bomber));
                kamikaze.forEach(k => scene.remove(k));
                landscape.forEach(obj => scene.remove(obj));
                grenades.forEach(grenade => scene.remove(grenade));
                particles.forEach(particle => scene.remove(particle));
                
                bombers = [];
                kamikaze = [];
                landscape = [];
                grenades = [];
                particles = [];
                ammoCount = config.ammoStart;
                score = 0;
                health = config.healthStart;
                
                controls.getObject().position.set(0, config.playerHeight, 0);
                
                createGround();
                loadModels();
                updateHUD();
            }

            function shoot() {
                if (ammoCount <= 0 || !isGameStarted) return;
                
                ammoCount--;
                updateHUD();

                if (gun && !isGunRecoiling) {
                    startGunRecoil();
                }

                // Создаем эффект выстрела
                createMuzzleFlash();
                
                const raycaster = new THREE.Raycaster(
                    camera.position,
                    camera.getWorldDirection(new THREE.Vector3())
                );
                
                const intersects = raycaster.intersectObjects(scene.children, true);
                
                for (const intersect of intersects) {
                    let obj = intersect.object;
                    
                    while (obj) {
                        if (obj.userData.isTarget) {
                            let targetToRemove = obj;
                            while (targetToRemove.parent && targetToRemove.parent.userData.isTarget) {
                                targetToRemove = targetToRemove.parent;
                            }
                            
                            explodeTarget(targetToRemove, targetToRemove.userData.isKamikaze);
                            
                            score += targetToRemove.userData.isKamikaze ? 15 : 10;
                            updateHUD();
                            
                            return;
                        }
                        obj = obj.parent;
                    }
                }
            }

            function createMuzzleFlash() {
                const flash = new THREE.PointLight(0xff6600, 1, 10);
                flash.position.set(0, 0, -1.5);
                camera.add(flash);
                
                setTimeout(() => {
                    camera.remove(flash);
                }, 50);
            }

            function startGunRecoil() {
                isGunRecoiling = true;
                const startTime = Date.now();
                const duration = 100; // длительность анимации в ms
                const recoilDistance = 0.1;
                const originalZ = gun.position.z;
                
                function animateRecoil() {
                    const currentTime = Date.now();
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    if (progress < 0.5) {
                        // Отдача вперед
                        gun.position.z = originalZ + recoilDistance * (progress * 2);
                    } else {
                        // Возврат назад
                        gun.position.z = originalZ + recoilDistance * (2 - progress * 2);
                    }
                    
                    if (progress < 1) {
                        gunRecoilAnimationId = requestAnimationFrame(animateRecoil);
                    } else {
                        // Гарантированно возвращаем на исходную позицию
                        gun.position.z = originalZ;
                        isGunRecoiling = false;
                        gunRecoilAnimationId = null;
                    }
                }
                
                gunRecoilAnimationId = requestAnimationFrame(animateRecoil);
            }

            function reload() {
                ammoCount = config.ammoStart;
                updateHUD();
            }

            function updateHUD() {
                document.getElementById('ammo').textContent = `Патроны: ${ammoCount}`;
                document.getElementById('score').textContent = `Очки: ${score}`;
                document.getElementById('health').textContent = `Здоровье: ${Math.max(0, health)}`;
            }

            function setupEventListeners() {
                window.addEventListener('resize', onWindowResize);
                document.addEventListener('mousedown', onMouseDown);
                document.addEventListener('keydown', onKeyDown);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function onMouseDown(e) {
                if (e.button === 0 && isGameStarted) shoot();
            }

            function onKeyDown(e) {
                if (e.key === 'r' && isGameStarted) reload();
            }

            function animate() {
                requestAnimationFrame(animate);
                
                if (isGameStarted) {
                    const playerPos = controls.getObject().position;
                    updatePlayerPosition();
                    
                    const currentTime = Date.now();
                    
                    if (currentTime > nextBomberWaveTime && bombers.length < config.bombers.count) {
                        spawnBomberWave();
                    }
                    
                    if (currentTime > nextKamikazeWaveTime && kamikaze.length < config.kamikaze.count) {
                        spawnKamikazeWave();
                    }
                    
                    for (let i = bombers.length - 1; i >= 0; i--) {
                        const bomber = bombers[i];
                        
                        if (bomber.userData.fadingIn) {
                            const fadeProgress = Math.min(1, (currentTime - bomber.userData.fadeStartTime) / config.bombers.fadeInDuration);
                            bomber.traverse(child => {
                                if (child.isMesh) {
                                    child.material.opacity = fadeProgress;
                                }
                            });
                            
                            if (fadeProgress >= 1) {
                                bomber.userData.fadingIn = false;
                            }
                        }
                        
                        bomber.position.z += bomber.userData.speed;
                        
                        if (bomber.userData.waveMotion) {
                            bomber.position.y = bomber.userData.initialHeight + 
                                            Math.sin(bomber.position.z * config.waveFrequency + 
                                            bomber.userData.waveOffset) * config.waveAmplitude;
                        }
                        
                        dropGrenade(bomber, currentTime);
                        
                        if (!updateTargetVisibility(bomber)) {
                            scene.remove(bomber);
                            bombers.splice(i, 1);
                            continue;
                        }
                        
                        if (bomber.position.z > playerPos.z + config.despawnDistance) {
                            scene.remove(bomber);
                            bombers.splice(i, 1);
                        }
                    }
                    
                    for (let i = kamikaze.length - 1; i >= 0; i--) {
                        const kamikazeObj = kamikaze[i];
                        
                        if (kamikazeObj.userData.fadingIn) {
                            const fadeProgress = Math.min(1, (currentTime - kamikazeObj.userData.fadeStartTime) / config.kamikaze.fadeInDuration);
                            kamikazeObj.traverse(child => {
                                if (child.isMesh) {
                                    child.material.opacity = fadeProgress;
                                }
                            });
                            
                            if (fadeProgress >= 1) {
                                kamikazeObj.userData.fadingIn = false;
                            }
                        }
                        
                        if (kamikazeAttack(kamikazeObj)) {
                            continue;
                        }
                        
                        if (!kamikazeObj.userData.attackParams.isInFinalAttack && 
                            !kamikazeObj.userData.attackParams.isTurningAround) {
                            kamikazeObj.position.z += kamikazeObj.userData.speed;
                        }
                        
                        if (!updateTargetVisibility(kamikazeObj)) {
                            scene.remove(kamikazeObj);
                            kamikaze.splice(i, 1);
                            continue;
                        }
                        
                        if (kamikazeObj.position.z > playerPos.z + config.despawnDistance) {
                            scene.remove(kamikazeObj);
                            kamikaze.splice(i, 1);
                        }
                    }
                    
                    checkGrenadeCollisions();
                    updateParticles();
                }

                renderer.render(scene, camera);
            }

            return { init };
        })();

        window.onload = DronoBoy.init;
    </script>
</body>
</html>