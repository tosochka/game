<!DOCTYPE html>
<html>
<head>
    <title>DronoBoy - Улучшенные камикадзе</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 4px black;
        }
        #ammo, #score, #health { font-size: 24px; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            flex-direction: column;
        }
        #start-button {
            position: relative;
            padding: 10px 20px;
            font-size: 20px;
            background: #333;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.1s;
            overflow: hidden;
        }
        #start-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: var(--progress, 0%);
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
            z-index: 0;
        }
        #start-button span {
            position: relative;
            z-index: 1;
        }
        #start-button:disabled {
            cursor: not-allowed;
            color: #aaa;
        }
        #start-button:disabled::before {
            background: #555;
        }
        #start-button:not(:disabled):active {
            transform: scale(0.95);
        }
        #start-button.inactive {
            cursor: default;
            pointer-events: none;
            opacity: 0.7;
        }
        #start-button.inactive::before {
            background: #555 !important;
        }
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            background-color: rgba(255, 50, 0, 0.5);
        }
        #loading-text {
            margin-top: 10px;
            font-size: 18px;
        }
        #loading-message {
            margin-top: 20px;
            color: #ccc;
            font-size: 14px;
            text-align: center;
            max-width: 300px;
        }
        #blocking-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="hud">
        <div id="ammo">Патроны: 30</div>
        <div id="score">Очки: 0</div>
        <div id="health">Здоровье: 100</div>
    </div>
    <div id="crosshair"></div>
    <div id="damage-overlay"></div>
    <div id="start-screen">
        <button id="start-button" disabled class="inactive">
            <span>Загрузка...</span>
        </button>
        <div id="loading-text">0%</div>
        <div id="loading-message">Пожалуйста, подождите, идет загрузка ресурсов...</div>
    </div>
    <div id="blocking-overlay"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>

    <script>
        const DronoBoy = (() => {
            const config = {
                playerHeight: 1.7,
                gunPosition: { x: 0.4, y: -0.5, z: -1.35 },
                gunScale: 0.9,
                bomberCount: 8,
                kamikazeCount: 5,
                targetSpeed: { min: 0.1, max: 0.15 },
                ammoStart: 30,
                spawnDistance: 150,
                fadeInDistance: 80,
                fadeOutDistance: 50,
                despawnDistance: 200,
                waveAmplitude: 3,
                waveFrequency: 0.1,
                landscapeObjects: {
                    count: 90,
                    types: [
                        'models/tree1.glb',
                        'models/tree2.glb',
                        'models/tree3.glb',
                        'models/tree4.glb',
                        'models/tree5.glb',
                        'models/tree6.glb',
                        'models/tree7.glb',
                        'models/tree8.glb',
                        'models/tree9.glb',
                        'models/tree10.glb',
                        'models/tree11.glb',
                        'models/tree12.glb',
                        'models/tree13.glb',
                        'models/tree14.glb',
                        'models/tree15.glb',
                        'models/tree16.glb',
                        'models/rock1.glb',
                        'models/rock2.glb'
                    ],
                    scaleRange: { min: 10.5, max: 20.0 },
                    positionRange: { x: 45, z: 80 }
                },
                safeRadius: 3,
                targetMovementRangeX: 40,
                landscapeSafeMargin: 5,
                minDistanceBetweenObjects: 3,
                playerSpeed: 0.2,
                healthStart: 100,
                playerBoundsExtension: 25,
                groundExtension: 100,
                spawnInterval: 2000,

                waveSettings: {
                    bomber: {
                        groupSpread: 15,
                        inGroupSpread: 5,
                        groupSize: 3,
                        spawnDelay: 500,
                        waveDensity: 0.1,
                        waveWidthUsage: 1.8,
                        waveDistribution: "uniform",
                        spawnInterval: 1500
                    },
                    kamikaze: {
                        groupSpread: 10,
                        inGroupSpread: 3,
                        groupSize: 2,
                        spawnDelay: 300,
                        waveDensity: 0.1,
                        waveWidthUsage: 1.0,
                        waveDistribution: "uniform",
                        spawnInterval: 2000
                    }
                },

                targetSettings: {
                    baseScale: 1.5,
                    fadeScaleMultiplier: 1.5,
                    aimPointOffset: new THREE.Vector3(0, -0.5, 0),
                    modelScale: {
                        bomber: 2.0,
                        kamikaze: 1.8
                    }
                },

                bomberSettings: {
                    modelPath: 'models/bomber.glb',
                    color: 0x8DA9C2,
                    bombChance: 0.03,
                    bombIntensity: 1.0,
                    minBombInterval: 1000,
                    maxBombInterval: 3000,
                    heightRange: { min: 20, max: 40 },
                    damage: 20
                },

                kamikazeSettings: {
                    modelPath: 'models/kamikaze.glb',
                    color: 0xFF0000,
                    trackingSpeed: 0.03,
                    attackStartDistance: 25,
                    damage: 30,
                    acceleration: 0.001,
                    maxSpeed: 0.3,
                    minDistanceToGround: 1.5,
                    attackHeightOffset: 0.8,
                    heightVariation: 1.5,
                    attackDelayRange: { min: 10000, max: 30000 },
                    minDistanceBetween: 2.5,
                    avoidanceAngle: 0.5,
                    sideStepFactor: 0.7,
                    rotationSpeed: 0.1,
                    hitRadius: 0.5,
                    hitRadiusMultiplier: 0.3,
                    playerRadius: 0.5,
                    heightRange: { min: 3.5, max: 12 },
                    maxActive: 5,
                    waveCooldown: 5000,
                    firstWave: {
                        count: 0,
                        distance: 150,
                        spread: 20,
                        height: 10
                    }
                },

                damageEffects: {
                    screenShakeIntensity: 0.5,
                    overlayDuration: 300
                }
            };

            let scene, camera, renderer, controls;
            let gun, bombers = [], kamikazes = [], landscape = [], grenades = [], particles;
            let ammoCount = config.ammoStart, score = 0, health = config.healthStart;
            let isGameStarted = false;
            let moveState = { forward: false, backward: false };
            let lastSpawnTime = 0;
            let damageOverlay;
            let playerPosition = new THREE.Vector3(0, config.playerHeight, 0);
            const DEBUG_MODE = false;

            let currentBomberWave = [];
            let currentKamikazeWave = [];
            let lastBomberGroupTime = 0;
            let lastKamikazeGroupTime = 0;
            let bomberGroupsSpawned = 0;
            let kamikazeGroupsSpawned = 0;
            let lastBomberSpawnTime = 0;
            let lastKamikazeSpawnTime = 0;

            // Loading tracking variables
            let landscapeResourcesToLoad = 0;
            let loadedLandscapeResources = 0;
            let startButton = document.getElementById('start-button');
            let loadingText = document.getElementById('loading-text');
            let landscapeLoadingComplete = false;
            let isRestarting = false;
            let blockingOverlay = document.getElementById('blocking-overlay');

            // Флаг для отслеживания состояния блокировки курсора
            let isPointerLocked = false;
            let canLockPointer = true;
            
            // Флаг для отслеживания состояния загрузки
            let isLoadingComplete = false;

            // Directional light for shadows
            let directionalLight;

            function updateLoadingProgress() {
                const progress = Math.round((loadedLandscapeResources / landscapeResourcesToLoad) * 100);
                startButton.style.setProperty('--progress', progress + '%');
                loadingText.textContent = `${progress}%`;
                
                if (progress >= 100) {
                    landscapeLoadingComplete = true;
                    isLoadingComplete = true;
                    startButton.querySelector('span').textContent = isRestarting ? 'Играть снова' : 'Начать игру';
                    startButton.disabled = false;
                    startButton.classList.remove('inactive');
                    document.getElementById('loading-message').textContent = 'Загрузка завершена!';
                    blockingOverlay.style.display = 'none';
                }
            }

            function incrementLoadedLandscapeResources() {
                loadedLandscapeResources++;
                updateLoadingProgress();
            }

            function resetLoadingState() {
                loadedLandscapeResources = 0;
                landscapeLoadingComplete = false;
                isLoadingComplete = false;
                startButton.disabled = true;
                startButton.classList.add('inactive');
                startButton.querySelector('span').textContent = 'Загрузка...';
                startButton.style.setProperty('--progress', '0%');
                loadingText.textContent = '0%';
                document.getElementById('loading-message').textContent = 'Пожалуйста, подождите, идет загрузка ресурсов...';
                blockingOverlay.style.display = 'block';
            }

            function createScene() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB);
                scene.fog = new THREE.FogExp2(0x87CEEB, 0.004);
            }

            function setupCamera() {
                camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                camera.position.y = config.playerHeight;
            }

            function setupRenderer() {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('game-container').appendChild(renderer.domElement);
            }

            function createLighting() {
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                scene.add(ambientLight);
                
                // Main directional light for shadows - positioned above
                directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(0, 50, 0);
                directionalLight.castShadow = true;
                
                directionalLight.shadow.mapSize.width = 4096;
                directionalLight.shadow.mapSize.height = 4096;
                directionalLight.shadow.camera.near = 0.1;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -250;
                directionalLight.shadow.camera.right = 250;
                directionalLight.shadow.camera.top = 250;
                directionalLight.shadow.camera.bottom = -250;
                
                scene.add(directionalLight);

                const fillLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.3);
                scene.add(fillLight);

                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-5, 3, -5);
                scene.add(backLight);

                const frontLight = new THREE.DirectionalLight(0xffffff, 0.3);
                frontLight.position.set(5, 3, 5);
                scene.add(frontLight);
            }

            function updateShadowCamera() {
                if (!directionalLight || !controls) return;
                
                const playerPos = controls.getObject().position;
                directionalLight.shadow.camera.position.set(
                    playerPos.x,
                    playerPos.y + 50,
                    playerPos.z
                );
                directionalLight.shadow.camera.updateProjectionMatrix();
            }

            function createGround() {
                const groundWidth = config.landscapeObjects.positionRange.x * 2 + config.groundExtension * 2;
                const groundHeight = config.landscapeObjects.positionRange.z * 2 + config.groundExtension * 2;
                
                const ground = new THREE.Mesh(
                    new THREE.PlaneGeometry(groundWidth, groundHeight, 100, 100),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x2a4d0b,
                        roughness: 0.8,
                        metalness: 0.1
                    })
                );
                
                const pos = ground.geometry.attributes.position;
                for (let i = 0; i < pos.count; i++) {
                    const x = pos.getX(i);
                    const z = pos.getZ(i);
                    const curveFactor = 0.0002 * x * x;
                    pos.setZ(i, z * (1 + curveFactor));
                }
                pos.needsUpdate = true;
                
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                ground.userData.isGround = true;
                scene.add(ground);
            }

            function createParticles() {
                const particleGeo = new THREE.BufferGeometry();
                const particleCnt = 1000;
                const posArray = new Float32Array(particleCnt * 3);
                for (let i = 0; i < particleCnt * 3; i++) {
                    posArray[i] = (Math.random() - 0.5) * 500;
                }
                particleGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                particles = new THREE.Points(particleGeo, new THREE.PointsMaterial({
                    color: 0xaaaaaa,
                    size: 0.5,
                    transparent: true,
                    opacity: 0.8
                }));
                scene.add(particles);
            }

            function isPositionSafe(x, z) {
                return Math.sqrt(x*x + z*z) > config.safeRadius;
            }

            function isPositionValid(x, z, objects) {
                if (!isPositionSafe(x, z)) return false;
                
                if (Math.abs(x) < config.targetMovementRangeX + config.landscapeSafeMargin) {
                    return false;
                }
                
                for (const obj of objects) {
                    const dx = x - obj.position.x;
                    const dz = z - obj.position.z;
                    const distance = Math.sqrt(dx*dx + dz*dz);
                    
                    if (distance < config.minDistanceBetweenObjects) {
                        return false;
                    }
                }
                
                return true;
            }

            function getRandomSafePosition(existingObjects) {
                let x, z;
                let attempts = 0;
                const maxAttempts = 100;
                
                const xRange = config.landscapeObjects.positionRange.x;
                const zRange = config.landscapeObjects.positionRange.z;
                
                const leftZone = {
                    min: -xRange,
                    max: -config.targetMovementRangeX - config.landscapeSafeMargin
                };
                
                const rightZone = {
                    min: config.targetMovementRangeX + config.landscapeSafeMargin,
                    max: xRange
                };
                
                do {
                    const zone = Math.random() > 0.5 ? leftZone : rightZone;
                    x = Math.random() * (zone.max - zone.min) + zone.min;
                    z = Math.random() * zRange * 2 - zRange;
                    attempts++;
                } while (!isPositionValid(x, z, existingObjects) && attempts < maxAttempts);
                
                return attempts < maxAttempts ? { x, z } : null;
            }

            function loadLandscapeObjects() {
                const loader = new THREE.GLTFLoader();
                const placedObjects = [];
                
                // Reset loading state for landscape objects
                landscapeResourcesToLoad = config.landscapeObjects.count;
                resetLoadingState();
                
                for (let i = 0; i < config.landscapeObjects.count; i++) {
                    const typeIndex = Math.floor(Math.random() * config.landscapeObjects.types.length);
                    const modelPath = config.landscapeObjects.types[typeIndex];
                    const position = getRandomSafePosition(placedObjects);
                    
                    if (!position) continue;
                    
                    loader.load(modelPath, 
                        (gltf) => {
                            const obj = gltf.scene;
                            const scale = Math.random() * 
                                         (config.landscapeObjects.scaleRange.max - config.landscapeObjects.scaleRange.min) + 
                                         config.landscapeObjects.scaleRange.min;
                            
                            obj.scale.set(scale, scale, scale);
                            obj.position.set(position.x, 0, position.z);
                            obj.rotation.y = Math.random() * Math.PI * 2;
                            
                            obj.traverse(child => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    child.material.roughness = 0.9;
                                    child.material.metalness = 0.05;
                                }
                            });
                            
                            obj.userData.isLandscape = true;
                            landscape.push(obj);
                            placedObjects.push(obj);
                            scene.add(obj);
                            incrementLoadedLandscapeResources();
                        },
                        undefined,
                        () => {
                            const geometry = Math.random() > 0.5 ? 
                                new THREE.ConeGeometry(1, 3, 8) : 
                                new THREE.SphereGeometry(1, 8, 8);
                            
                            const obj = new THREE.Mesh(
                                geometry,
                                new THREE.MeshStandardMaterial({ 
                                    color: Math.random() > 0.5 ? 0x1a5a1a : 0x707070,
                                    roughness: 0.9,
                                    metalness: 0.05
                                })
                            );
                            
                            const scale = Math.random() * 
                                       (config.landscapeObjects.scaleRange.max - config.landscapeObjects.scaleRange.min) + 
                                       config.landscapeObjects.scaleRange.min;
                            
                            obj.scale.set(scale, scale, scale);
                            obj.position.set(position.x, 0, position.z);
                            obj.rotation.y = Math.random() * Math.PI * 2;
                            obj.castShadow = true;
                            obj.receiveShadow = true;
                            obj.userData.isLandscape = true;
                            
                            landscape.push(obj);
                            placedObjects.push(obj);
                            scene.add(obj);
                            incrementLoadedLandscapeResources();
                        }
                    );
                }
            }

            function spawnBomberWave() {
                const now = Date.now();
                if (now - lastBomberGroupTime < config.waveSettings.bomber.spawnDelay) return;
                
                lastBomberGroupTime = now;
                
                const waveWidth = config.targetMovementRangeX * 2 * config.waveSettings.bomber.waveWidthUsage;
                const groupCenterX = (Math.random() > 0.5 ? 1 : -1) * 
                                   (config.targetMovementRangeX - waveWidth/2) + 
                                   (Math.random() * 2 - 1) * (waveWidth/2);
                
                const groupCenterZ = playerPosition.z - config.spawnDistance + 
                                   (Math.random() * 20 - 10) * (1 - config.waveSettings.bomber.waveDensity);
                
                for (let i = 0; i < config.waveSettings.bomber.groupSize; i++) {
                    setTimeout(() => {
                        let x, z;
                        
                        if (config.waveSettings.bomber.waveDistribution === "uniform") {
                            const step = waveWidth / (config.waveSettings.bomber.groupSize + 1);
                            x = groupCenterX - waveWidth/2 + step * (i + 1);
                            z = groupCenterZ + (Math.random() * 2 - 1) * config.waveSettings.bomber.inGroupSpread;
                        } else {
                            const densityOffset = (Math.random() * 2 - 1) * 10 * (1 - config.waveSettings.bomber.waveDensity);
                            x = groupCenterX + (Math.random() * 2 - 1) * config.waveSettings.bomber.inGroupSpread;
                            z = groupCenterZ + densityOffset + 
                                (Math.random() * 2 - 1) * config.waveSettings.bomber.inGroupSpread;
                        }
                        
                        spawnBomber(false, x, z);
                    }, i * config.waveSettings.bomber.spawnInterval);
                }
                
                bomberGroupsSpawned++;
                
                if (bomberGroupsSpawned >= Math.ceil(config.bomberCount / config.waveSettings.bomber.groupSize)) {
                    bomberGroupsSpawned = 0;
                    lastBomberGroupTime = 0;
                }
            }

            function spawnFirstKamikazeWave() {
                for (let i = 0; i < config.kamikazeSettings.firstWave.count; i++) {
                    const x = (Math.random() * 2 - 1) * config.kamikazeSettings.firstWave.spread;
                    const z = playerPosition.z - config.kamikazeSettings.firstWave.distance;
                    const y = config.kamikazeSettings.firstWave.height;
                    
                    spawnKamikaze(false, x, z, y, true);
                }
                
                lastKamikazeGroupTime = Date.now();
            }

            function spawnKamikazeWave() {
                const now = Date.now();
                
                if (now - lastKamikazeGroupTime < config.kamikazeSettings.waveCooldown || 
                    kamikazes.length >= config.kamikazeSettings.maxActive) {
                    return;
                }
                
                lastKamikazeGroupTime = now;
                
                const waveWidth = config.targetMovementRangeX * 2 * config.waveSettings.kamikaze.waveWidthUsage;
                const groupCenterX = (Math.random() > 0.5 ? 1 : -1) * 
                                   (config.targetMovementRangeX - waveWidth/2) + 
                                   (Math.random() * 2 - 1) * (waveWidth/2);
                
                const groupCenterZ = playerPosition.z - config.spawnDistance + 
                                   (Math.random() * 20 - 10) * (1 - config.waveSettings.kamikaze.waveDensity);
                
                const toSpawn = Math.min(
                    config.waveSettings.kamikaze.groupSize,
                    config.kamikazeSettings.maxActive - kamikazes.length
                );
                
                for (let i = 0; i < toSpawn; i++) {
                    setTimeout(() => {
                        if (kamikazes.length >= config.kamikazeSettings.maxActive) return;
                        
                        let x, z;
                        
                        if (config.waveSettings.kamikaze.waveDistribution === "uniform") {
                            const step = waveWidth / (toSpawn + 1);
                            x = groupCenterX - waveWidth/2 + step * (i + 1);
                            z = groupCenterZ + (Math.random() * 2 - 1) * config.waveSettings.kamikaze.inGroupSpread;
                        } else {
                            const densityOffset = (Math.random() * 2 - 1) * 10 * (1 - config.waveSettings.kamikaze.waveDensity);
                            x = groupCenterX + (Math.random() * 2 - 1) * config.waveSettings.kamikaze.inGroupSpread;
                            z = groupCenterZ + densityOffset + 
                                (Math.random() * 2 - 1) * config.waveSettings.kamikaze.inGroupSpread;
                        }
                        
                        spawnKamikaze(false, x, z);
                    }, i * config.waveSettings.kamikaze.spawnInterval);
                }
            }

            function spawnBomber(initialSpawn = false, customX = null, customZ = null) {
                const loader = new THREE.GLTFLoader();
                
                let spawnZ, x;
                if (initialSpawn) {
                    spawnZ = playerPosition.z - config.spawnDistance + (Math.random() * 20 - 10);
                    x = (Math.random() * 2 - 1) * config.targetMovementRangeX;
                } else {
                    spawnZ = customZ !== null ? customZ : playerPosition.z - config.spawnDistance;
                    x = customX !== null ? customX : (Math.random() * 2 - 1) * config.targetMovementRangeX;
                    
                    const screenPos = new THREE.Vector3(x, config.bomberSettings.heightRange.min + 5, spawnZ).project(camera);
                    if (Math.abs(screenPos.x) < 1.5 && Math.abs(screenPos.y) < 1.5) {
                        spawnZ = playerPosition.z - config.spawnDistance * 1.5;
                    }
                }

                loader.load(config.bomberSettings.modelPath, 
                    (gltf) => {
                        const bomber = gltf.scene;
                        
                        bomber.traverse(child => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                child.material.transparent = true;
                                child.material.opacity = initialSpawn ? 1 : 0;
                                child.material.roughness = 0.7;
                                child.material.metalness = 0.1;
                                child.material.color.setHex(config.bomberSettings.color);
                            }
                        });
                        
                        const box = new THREE.Box3().setFromObject(bomber);
                        const center = box.getCenter(new THREE.Vector3());
                        bomber.position.sub(center);
                        
                        const size = box.getSize(new THREE.Vector3()).length();
                        const scaleFactor = config.targetSettings.baseScale * 
                                           config.targetSettings.modelScale.bomber / size;
                        bomber.scale.set(scaleFactor, scaleFactor, scaleFactor);
                        
                        bomber.rotation.y = Math.PI;
                        
                        const initialHeight = Math.random() * 
                            (config.bomberSettings.heightRange.max - config.bomberSettings.heightRange.min) + 
                            config.bomberSettings.heightRange.min;
                        
                        bomber.position.set(x, initialHeight, spawnZ);
                        
                        const speed = Math.random() * 
                            (config.targetSpeed.max - config.targetSpeed.min) + 
                            config.targetSpeed.min;
                        
                        bomber.userData = {
                            isBomber: true,
                            fadingIn: !initialSpawn,
                            speed: speed,
                            waveMotion: Math.random() > 0.5,
                            initialHeight: initialHeight,
                            waveOffset: Math.random() * Math.PI * 2,
                            baseSize: size,
                            currentScale: scaleFactor,
                            lastBombTime: 0,
                            baseSpeed: speed,
                            currentSpeed: speed
                        };
                        
                        if (DEBUG_MODE) {
                            const helper = new THREE.BoxHelper(bomber, 0xffff00);
                            scene.add(helper);
                            bomber.userData.debugHelper = helper;
                        }
                        
                        bombers.push(bomber);
                        scene.add(bomber);
                    },
                    undefined,
                    () => {
                        const initialHeight = Math.random() * 
                            (config.bomberSettings.heightRange.max - config.bomberSettings.heightRange.min) + 
                            config.bomberSettings.heightRange.min;
                        
                        const speed = Math.random() * 
                            (config.targetSpeed.max - config.targetSpeed.min) + 
                            config.targetSpeed.min;
                        
                        const bomber = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.5, 0.5, 0.1, 8),
                            new THREE.MeshStandardMaterial({ 
                                color: config.bomberSettings.color,
                                transparent: true,
                                opacity: initialSpawn ? 1 : 0,
                                roughness: 0.7,
                                metalness: 0.1
                            })
                        );
                        
                        bomber.castShadow = true;
                        bomber.receiveShadow = true;
                        bomber.position.set(x, initialHeight, spawnZ);
                        bomber.rotation.y = Math.PI;
                        bomber.scale.set(
                            config.targetSettings.baseScale * config.targetSettings.modelScale.bomber,
                            config.targetSettings.baseScale * config.targetSettings.modelScale.bomber,
                            config.targetSettings.baseScale * config.targetSettings.modelScale.bomber
                        );
                        
                        bomber.userData = {
                            isBomber: true,
                            fadingIn: !initialSpawn,
                            speed: speed,
                            waveMotion: Math.random() > 0.5,
                            initialHeight: initialHeight,
                            waveOffset: Math.random() * Math.PI * 2,
                            baseSize: 1,
                            currentScale: config.targetSettings.baseScale * config.targetSettings.modelScale.bomber,
                            lastBombTime: 0,
                            baseSpeed: speed,
                            currentSpeed: speed
                        };
                        
                        if (DEBUG_MODE) {
                            const helper = new THREE.BoxHelper(bomber, 0xffff00);
                            scene.add(helper);
                            bomber.userData.debugHelper = helper;
                        }
                        
                        bombers.push(bomber);
                        scene.add(bomber);
                    }
                );
            }

            function spawnKamikaze(initialSpawn = false, customX = null, customZ = null, customY = null, isFirstWave = false) {
                const loader = new THREE.GLTFLoader();
                
                let x, z, y;
                
                if (isFirstWave) {
                    x = customX;
                    z = customZ;
                    y = customY !== null ? customY : config.kamikazeSettings.firstWave.height;
                } else if (initialSpawn) {
                    x = (Math.random() * 2 - 1) * config.targetMovementRangeX;
                    z = playerPosition.z - config.spawnDistance + (Math.random() * 20 - 10);
                    y = Math.random() * 
                        (config.kamikazeSettings.heightRange.max - config.kamikazeSettings.heightRange.min) + 
                        config.kamikazeSettings.heightRange.min;
                } else {
                    x = customX !== null ? customX : (Math.random() * 2 - 1) * config.targetMovementRangeX;
                    z = customZ !== null ? customZ : playerPosition.z - config.spawnDistance;
                    y = customY !== null ? customY : 
                        Math.random() * 
                        (config.kamikazeSettings.heightRange.max - config.kamikazeSettings.heightRange.min) + 
                        config.kamikazeSettings.heightRange.min;
                }

                loader.load(config.kamikazeSettings.modelPath, 
                    (gltf) => {
                        const kamikaze = gltf.scene;
                        
                        kamikaze.traverse(child => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                child.material.transparent = true;
                                child.material.opacity = initialSpawn || isFirstWave ? 1 : 0;
                                child.material.roughness = 0.7,
                                child.material.metalness = 0.1,
                                child.material.color.setHex(config.kamikazeSettings.color);
                            }
                        });
                        
                        const box = new THREE.Box3().setFromObject(kamikaze);
                        const center = box.getCenter(new THREE.Vector3());
                        kamikaze.position.sub(center);
                        
                        const size = box.getSize(new THREE.Vector3()).length();
                        const scaleFactor = config.targetSettings.baseScale * 
                                         config.targetSettings.modelScale.kamikaze / size;
                        kamikaze.scale.set(scaleFactor, scaleFactor, scaleFactor);
                        
                        kamikaze.position.set(x, y, z);
                        
                        const speed = Math.random() * 
                            (config.targetSpeed.max - config.targetSpeed.min) + 
                            config.targetSpeed.min;
                        
                        kamikaze.userData = {
                            isKamikaze: true,
                            fadingIn: !initialSpawn && !isFirstWave,
                            speed: speed,
                            initialHeight: y,
                            baseSize: size,
                            currentScale: scaleFactor,
                            lastBombTime: 0,
                            baseSpeed: speed,
                            currentSpeed: speed,
                            targetRotation: Math.PI,
                            rotationSpeed: config.kamikazeSettings.rotationSpeed,
                            isAttacking: false
                        };
                        
                        if (DEBUG_MODE) {
                            const helper = new THREE.BoxHelper(kamikaze, 0xffff00);
                            scene.add(helper);
                            kamikaze.userData.debugHelper = helper;
                        }
                        
                        kamikazes.push(kamikaze);
                        scene.add(kamikaze);
                    },
                    undefined,
                    () => {
                        const speed = Math.random() * 
                            (config.targetSpeed.max - config.targetSpeed.min) + 
                            config.targetSpeed.min;
                        
                        const kamikaze = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.5, 0.5, 0.1, 8),
                            new THREE.MeshStandardMaterial({ 
                                color: config.kamikazeSettings.color,
                                transparent: true,
                                opacity: initialSpawn || isFirstWave ? 1 : 0,
                                roughness: 0.7,
                                metalness: 0.1
                            })
                        );
                        
                        kamikaze.castShadow = true;
                        kamikaze.receiveShadow = true;
                        kamikaze.position.set(x, y, z);
                        kamikaze.rotation.y = Math.PI;
                        kamikaze.scale.set(
                            config.targetSettings.baseScale * config.targetSettings.modelScale.kamikaze,
                            config.targetSettings.baseScale * config.targetSettings.modelScale.kamikaze,
                            config.targetSettings.baseScale * config.targetSettings.modelScale.kamikaze
                        );
                        
                        kamikaze.userData = {
                            isKamikaze: true,
                            fadingIn: !initialSpawn && !isFirstWave,
                            speed: speed,
                            initialHeight: y,
                            baseSize: 1,
                            currentScale: config.targetSettings.baseScale * config.targetSettings.modelScale.kamikaze,
                            lastBombTime: 0,
                            baseSpeed: speed,
                            currentSpeed: speed,
                            targetRotation: Math.PI,
                            rotationSpeed: config.kamikazeSettings.rotationSpeed,
                            isAttacking: false
                        };
                        
                        if (DEBUG_MODE) {
                            const helper = new THREE.BoxHelper(kamikaze, 0xffff00);
                            scene.add(helper);
                            kamikaze.userData.debugHelper = helper;
                        }
                        
                        kamikazes.push(kamikaze);
                        scene.add(kamikaze);
                    }
                );
            }

            function dropGrenade(bomber, currentTime) {
                if (currentTime - bomber.userData.lastBombTime < 
                    Math.random() * (config.bomberSettings.maxBombInterval - config.bomberSettings.minBombInterval) + 
                    config.bomberSettings.minBombInterval) {
                    return;
                }
                
                if (Math.random() > config.bomberSettings.bombChance * config.bomberSettings.bombIntensity) {
                    return;
                }
                
                const grenade = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x660000,
                        roughness: 0.8
                    })
                );
                
                grenade.position.copy(bomber.position);
                grenade.position.y -= 1;
                grenade.castShadow = true;
                grenade.receiveShadow = true;
                
                grenade.userData = {
                    isGrenade: true,
                    speed: 0.1,
                    fallSpeed: 0,
                    gravity: 0.01,
                    damage: config.bomberSettings.damage,
                    timer: 100
                };
                
                grenades.push(grenade);
                scene.add(grenade);
                bomber.userData.lastBombTime = currentTime;
            }

            function kamikazeAttack(kamikaze) {
                const targetPosition = kamikaze.position.clone();
                const groundLevel = 0;
                
                let targetRadius;
                if (kamikaze.children && kamikaze.children[0]) {
                    const box = new THREE.Box3().setFromObject(kamikaze);
                    targetRadius = box.getSize(new THREE.Vector3()).length() * 
                                  config.kamikazeSettings.hitRadiusMultiplier;
                } else {
                    targetRadius = config.kamikazeSettings.hitRadius;
                }

                const aimPoint = new THREE.Vector3().copy(playerPosition)
                    .add(config.targetSettings.aimPointOffset);
                
                const distanceToPlayer = targetPosition.distanceTo(aimPoint);
                const hitPlayer = distanceToPlayer < targetRadius + config.kamikazeSettings.playerRadius;
                const hitGround = kamikaze.position.y <= groundLevel;
                
                if (!kamikaze.userData.attackTime) {
                    kamikaze.userData.attackTime = Date.now() + 
                        Math.random() * (config.kamikazeSettings.attackDelayRange.max - 
                                        config.kamikazeSettings.attackDelayRange.min) + 
                        config.kamikazeSettings.attackDelayRange.min;
                }
                
                const prevPosition = kamikaze.userData.lastPosition || kamikaze.position.clone();
                kamikaze.userData.lastPosition = kamikaze.position.clone();
                
                const moveDirection = new THREE.Vector3();
                moveDirection.subVectors(kamikaze.position, prevPosition);
                
                if (moveDirection.length() > 0.01) {
                    moveDirection.normalize();
                    
                    const moveAngle = Math.atan2(moveDirection.x, moveDirection.z);
                    const targetAngle = moveAngle + Math.PI;
                    
                    if (kamikaze.children && kamikaze.children[0]) {
                        const currentRotation = kamikaze.children[0].rotation.y;
                        let angleDifference = targetAngle - currentRotation;
                        
                        angleDifference = ((angleDifference + Math.PI) % (Math.PI * 2)) - Math.PI;
                        
                        kamikaze.children[0].rotation.y += angleDifference * kamikaze.userData.rotationSpeed;
                    } else {
                        const currentRotation = kamikaze.rotation.y;
                        let angleDifference = targetAngle - currentRotation;
                        
                        angleDifference = ((angleDifference + Math.PI) % (Math.PI * 2)) - Math.PI;
                        
                        kamikaze.rotation.y += angleDifference * kamikaze.userData.rotationSpeed;
                    }
                }
                
                if (Date.now() < kamikaze.userData.attackTime) {
                    kamikaze.position.z += kamikaze.userData.baseSpeed;
                    return false;
                }
                
                kamikaze.userData.isAttacking = true;
                kamikaze.userData.currentSpeed = Math.min(
                    kamikaze.userData.currentSpeed + config.kamikazeSettings.acceleration,
                    config.kamikazeSettings.maxSpeed
                );
                
                const attackDirection = new THREE.Vector3()
                    .subVectors(aimPoint, targetPosition)
                    .normalize();
                
                const moveDistance = kamikaze.userData.currentSpeed;
                const desiredPosition = kamikaze.position.clone().add(
                    attackDirection.clone().multiplyScalar(moveDistance)
                );
                
                let canMove = true;
                for (const otherKamikaze of kamikazes) {
                    if (otherKamikaze !== kamikaze) {
                        const distance = desiredPosition.distanceTo(otherKamikaze.position);
                        if (distance < config.kamikazeSettings.minDistanceBetween) {
                            canMove = false;
                            break;
                        }
                    }
                }
                
                if (!canMove) {
                    const zOnlyPosition = kamikaze.position.clone();
                    zOnlyPosition.z += attackDirection.z * moveDistance;
                    let zOnlyValid = true;
                    
                    for (const otherKamikaze of kamikazes) {
                        if (otherKamikaze !== kamikaze) {
                            const distance = zOnlyPosition.distanceTo(otherKamikaze.position);
                            if (distance < config.kamikazeSettings.minDistanceBetween) {
                                zOnlyValid = false;
                                break;
                            }
                        }
                    }
                    
                    if (zOnlyValid) {
                        kamikaze.position.copy(zOnlyPosition);
                    } else {
                        const sideStep = new THREE.Vector3(-attackDirection.z, 0, attackDirection.x).normalize();
                        const sidePosition = kamikaze.position.clone().add(
                            sideStep.multiplyScalar(moveDistance * config.kamikazeSettings.sideStepFactor)
                        );
                        let sideValid = true;
                        
                        for (const otherKamikaze of kamikazes) {
                            if (otherKamikaze !== kamikaze) {
                                const distance = sidePosition.distanceTo(otherKamikaze.position);
                                if (distance < config.kamikazeSettings.minDistanceBetween) {
                                    sideValid = false;
                                    break;
                                }
                            }
                        }
                        
                        if (sideValid) {
                            kamikaze.position.copy(sidePosition);
                        }
                    }
                } else {
                    kamikaze.position.copy(desiredPosition);
                }
                
                if (!kamikaze.userData.attackHeight) {
                    kamikaze.userData.attackHeight = config.playerHeight + 
                        (Math.random() * 2 - 1) * config.kamikazeSettings.heightVariation;
                }
                
                if (Math.abs(kamikaze.position.y - kamikaze.userData.attackHeight) > 0.1) {
                    const heightDirection = kamikaze.userData.attackHeight > kamikaze.position.y ? 1 : -1;
                    kamikaze.position.y += heightDirection * 0.02;
                }
                
                if (hitPlayer || hitGround) {
                    if (hitPlayer) {
                        showDamageEffect();
                        takeDamage(config.kamikazeSettings.damage);
                    }
                    
                    explodeTarget(kamikaze, true);
                    return true;
                }
                
                return false;
            }

            function showDamageEffect() {
                const originalPosition = camera.position.clone();
                const shakeIntensity = config.damageEffects.screenShakeIntensity;
                
                let shakeCount = 0;
                const maxShake = 10;
                const shakeInterval = setInterval(() => {
                    camera.position.x = originalPosition.x + (Math.random() - 0.5) * shakeIntensity;
                    camera.position.y = originalPosition.y + (Math.random() - 0.5) * shakeIntensity;
                    shakeCount++;
                    
                    if (shakeCount >= maxShake) {
                        clearInterval(shakeInterval);
                        camera.position.copy(originalPosition);
                    }
                }, 50);
                
                damageOverlay.style.opacity = 1;
                setTimeout(() => {
                    damageOverlay.style.opacity = 0;
                }, config.damageEffects.overlayDuration);
            }

            function explodeTarget(target, isKamikaze = false) {
                if (DEBUG_MODE && target.userData.debugHelper) {
                    scene.remove(target.userData.debugHelper);
                }

                const explosionGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                const explosionMaterial = new THREE.MeshStandardMaterial({
                    color: isKamikaze ? config.kamikazeSettings.color : config.bomberSettings.color,
                    transparent: true,
                    opacity: 0.7,
                    roughness: 0.5,
                    emissive: 0xff6600,
                    emissiveIntensity: 0.5
                });
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosion.position.copy(target.position);
                scene.add(explosion);
                
                setTimeout(() => {
                    scene.remove(explosion);
                }, 300);
                
                scene.remove(target);
                
                if (isKamikaze) {
                    kamikazes = kamikazes.filter(t => t !== target);
                } else {
                    bombers = bombers.filter(t => t !== target);
                    setTimeout(() => spawnBomber(), 1000);
                }
            }

            function setupControls() {
                controls = new THREE.PointerLockControls(camera, renderer.domElement);
                
                document.getElementById('start-button').addEventListener('click', () => {
                    // Добавляем дополнительную проверку на флаг загрузки
                    if (!landscapeLoadingComplete || !canLockPointer || !isLoadingComplete) return;
                    
                    canLockPointer = false;
                    controls.lock().catch(e => {
                        console.log("Не удалось заблокировать курсор:", e);
                        canLockPointer = true;
                    });
                });

                controls.addEventListener('lock', () => {
                    isGameStarted = true;
                    isPointerLocked = true;
                    canLockPointer = true;
                    document.getElementById('start-screen').style.display = 'none';
                    lastSpawnTime = Date.now();
                    
                    spawnFirstKamikazeWave();
                });

                controls.addEventListener('unlock', () => {
                    isGameStarted = false;
                    isPointerLocked = false;
                    document.getElementById('start-screen').style.display = 'flex';
                    
                    // Имитируем загрузку, чтобы выиграть время
                    startButton.disabled = true;
                    startButton.classList.add('inactive');
                    startButton.querySelector('span').textContent = 'Загрузка...';
                    loadingText.textContent = '0%';
                    startButton.style.setProperty('--progress', '0%');
                    
                    let progress = 0;
                    const fakeLoadInterval = setInterval(() => {
                        progress += 5;
                        startButton.style.setProperty('--progress', progress + '%');
                        loadingText.textContent = `${progress}%`;
                        
                        if (progress >= 100) {
                            clearInterval(fakeLoadInterval);
                            startButton.querySelector('span').textContent = isRestarting ? 'Играть снова' : 'Начать игру';
                            startButton.disabled = false;
                            startButton.classList.remove('inactive');
                            canLockPointer = true;
                        }
                    }, 100);
                });

                document.addEventListener('keydown', (e) => {
                    if (!isGameStarted) return;
                    
                    switch(e.key.toLowerCase()) {
                        case 'w':
                            moveState.forward = true;
                            break;
                        case 's':
                            moveState.backward = true;
                            break;
                        case 'r':
                            reload();
                            break;
                    }
                });

                document.addEventListener('keyup', (e) => {
                    switch(e.key.toLowerCase()) {
                        case 'w':
                            moveState.forward = false;
                            break;
                        case 's':
                            moveState.backward = false;
                            break;
                    }
                });
            }

            function updatePlayerPosition() {
                if (!isGameStarted) return;
                
                const moveVector = new THREE.Vector3();
                const direction = new THREE.Vector3();
                
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();
                
                if (moveState.forward) {
                    moveVector.add(direction.multiplyScalar(config.playerSpeed));
                }
                if (moveState.backward) {
                    moveVector.add(direction.multiplyScalar(-config.playerSpeed));
                }

                if (moveVector.length() > 0) {
                    const newPosition = controls.getObject().position.clone().add(moveVector);
                    
                    const bounds = {
                        minX: -config.landscapeObjects.positionRange.x - config.playerBoundsExtension,
                        maxX: config.landscapeObjects.positionRange.x + config.playerBoundsExtension,
                        minZ: -config.landscapeObjects.positionRange.z - config.playerBoundsExtension,
                        maxZ: config.landscapeObjects.positionRange.z + config.playerBoundsExtension
                    };
                    
                    if (newPosition.x > bounds.minX && newPosition.x < bounds.maxX &&
                        newPosition.z > bounds.minZ && newPosition.z < bounds.maxZ) {
                        controls.getObject().position.copy(newPosition);
                    }
                }
                
                playerPosition.copy(controls.getObject().position);
            }

            function checkGrenadeCollisions() {
                for (let i = grenades.length - 1; i >= 0; i--) {
                    const grenade = grenades[i];
                    
                    grenade.position.y -= grenade.userData.fallSpeed;
                    grenade.userData.fallSpeed += grenade.userData.gravity;
                    grenade.userData.timer--;
                    
                    if (grenade.userData.timer <= 0 || grenade.position.y <= 0) {
                        explodeGrenade(grenade);
                        scene.remove(grenade);
                        grenades.splice(i, 1);
                        continue;
                    }
                    
                    const distanceToPlayer = grenade.position.distanceTo(playerPosition);
                    if (distanceToPlayer < 1.5) {
                        showDamageEffect();
                        takeDamage(grenade.userData.damage);
                        explodeGrenade(grenade);
                        scene.remove(grenade);
                        grenades.splice(i, 1);
                    }
                }
            }

            function explodeGrenade(grenade) {
                const explosionGeometry = new THREE.SphereGeometry(1, 8, 8);
                const explosionMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff5500,
                    transparent: true,
                    opacity: 0.6,
                    roughness: 0.5
                });
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosion.position.copy(grenade.position);
                scene.add(explosion);
                
                setTimeout(() => {
                    scene.remove(explosion);
                }, 200);
            }

            function takeDamage(amount) {
                health -= amount;
                updateHUD();
                
                if (health <= 0) {
                    gameOver();
                }
            }

            function gameOver() {
                isGameStarted = false;
                controls.unlock();
                document.getElementById('start-screen').style.display = 'flex';
                
                isRestarting = true;
                resetGame();
            }

            function resetGame() {
                // Удаляем старое оружие из сцены
                if (gun) {
                    camera.remove(gun);
                    gun = null;
                }

                // Clear all game objects
                bombers.forEach(bomber => {
                    if (DEBUG_MODE && bomber.userData.debugHelper) {
                        scene.remove(bomber.userData.debugHelper);
                    }
                    scene.remove(bomber);
                });
                
                kamikazes.forEach(kamikaze => {
                    if (DEBUG_MODE && kamikaze.userData.debugHelper) {
                        scene.remove(kamikaze.userData.debugHelper);
                    }
                    scene.remove(kamikaze);
                });
                
                landscape.forEach(obj => scene.remove(obj));
                grenades.forEach(grenade => scene.remove(grenade));
                
                // Reset game state
                bombers = [];
                kamikazes = [];
                landscape = [];
                grenades = [];
                ammoCount = config.ammoStart;
                score = 0;
                health = config.healthStart;
                
                // Reset player position
                controls.getObject().position.set(0, config.playerHeight, 0);
                playerPosition.set(0, config.playerHeight, 0);
                
                // Recreate game world
                createGround();
                loadModels();
                updateHUD();
            }

            function shoot() {
                if (!gun || ammoCount <= 0 || !isGameStarted) return;
                
                ammoCount--;
                updateHUD();

                // Сохраняем исходную позицию
                const originalPosition = gun.position.clone();
                
                // Анимация отдачи - двигаем всё оружие вперед
                gun.position.z += 0.1;
                
                // Плавное возвращение на место
                const startTime = Date.now();
                const duration = 100;
                
                const animateReturn = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Плавно возвращаем на исходную позицию
                    gun.position.z = originalPosition.z + 0.1 * (1 - progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateReturn);
                    } else {
                        // Гарантируем точное возвращение на место
                        gun.position.copy(originalPosition);
                    }
                };
                
                animateReturn();

                const raycaster = new THREE.Raycaster(
                    camera.position,
                    camera.getWorldDirection(new THREE.Vector3())
                );
                
                const intersects = raycaster.intersectObjects(scene.children, true);
                
                for (const intersect of intersects) {
                    let obj = intersect.object;
                    
                    while (obj) {
                        if (obj.userData.isBomber || obj.userData.isKamikaze) {
                            let targetToRemove = obj;
                            while (targetToRemove.parent && 
                                  (targetToRemove.parent.userData.isBomber || targetToRemove.parent.userData.isKamikaze)) {
                                targetToRemove = targetToRemove.parent;
                            }
                            
                            explodeTarget(targetToRemove, obj.userData.isKamikaze);
                            
                            score += 10;
                            updateHUD();
                            return;
                        }
                        obj = obj.parent;
                    }
                }
            }

            function reload() {
                ammoCount = config.ammoStart;
                updateHUD();
            }

            function updateHUD() {
                document.getElementById('ammo').textContent = `Патроны: ${ammoCount}`;
                document.getElementById('score').textContent = `Очки: ${score}`;
                document.getElementById('health').textContent = `Здоровье: ${Math.max(0, health)}`;
            }

            function setupEventListeners() {
                window.addEventListener('resize', onWindowResize);
                document.addEventListener('mousedown', onMouseDown);
                document.addEventListener('keydown', onKeyDown);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function onMouseDown(e) {
                if (e.button === 0 && isGameStarted) shoot();
            }

            function onKeyDown(e) {
                if (e.key === 'r' && isGameStarted) reload();
            }

            function loadModels() {
                const loader = new THREE.GLTFLoader();
                
                loader.load('models/gun.glb', 
                    (gltf) => {
                        console.log('Модель оружия загружена');
                        gun = gltf.scene;
                        
                        // Добавляем тени для модели оружия
                        gun.traverse((child) => {
                            if (child.isMesh) {
                                child.material = new THREE.MeshStandardMaterial({
                                    color: 0xa6a6a6,
                                    roughness: 0.3,
                                    metalness: 0.7,
                                    emissive: 0x111111,
                                    emissiveIntensity: 0.2
                                });
                                child.castShadow = true;    // Включаем отбрасывание тени
                                child.receiveShadow = true; // Включаем получение тени
                            }
                        });

                        gun.position.set(config.gunPosition.x, config.gunPosition.y, config.gunPosition.z);
                        gun.scale.set(config.gunScale, config.gunScale, config.gunScale);
                        
                        camera.add(gun);
                        scene.add(camera);
                        console.log('Оружие добавлено к камере');
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading gun model:', error);
                        createFallbackGun();
                    }
                );

                loadLandscapeObjects();

                for (let i = 0; i < config.bomberCount; i++) {
                    const x = (Math.random() * 2 - 1) * config.targetMovementRangeX;
                    const z = playerPosition.z - config.spawnDistance + (Math.random() * 20 - 10);
                    spawnBomber(false, x, z);
                }

                for (let i = 0; i < config.kamikazeCount; i++) {
                    const x = (Math.random() * 2 - 1) * config.targetMovementRangeX;
                    const z = playerPosition.z - config.spawnDistance + (Math.random() * 20 - 10);
                    spawnKamikaze(false, x, z);
                }
            }

            function createFallbackGun() {
                console.log('Создаем примитив вместо оружия');
                
                const gunGroup = new THREE.Group();
                
                const gunBody = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.1, 1.0),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x444444,
                        roughness: 0.3,
                        metalness: 0.7
                    })
                );
                gunBody.position.z = -0.5;
                gunBody.castShadow = true;
                gunBody.receiveShadow = true;
                gunGroup.add(gunBody);
                
                const gunHandle = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.3, 0.2),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x222222,
                        roughness: 0.8,
                        metalness: 0.2
                    })
                );
                gunHandle.position.y = -0.2;
                gunHandle.position.z = -0.3;
                gunHandle.castShadow = true;
                gunHandle.receiveShadow = true;
                gunGroup.add(gunHandle);
                
                const gunBarrel = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 0.7, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x888888,
                        roughness: 0.2,
                        metalness: 0.8
                    })
                );
                gunBarrel.rotation.x = Math.PI / 2;
                gunBarrel.position.z = -0.9;
                gunBarrel.castShadow = true;
                gunBarrel.receiveShadow = true;
                gunGroup.add(gunBarrel);
                
                gunGroup.position.set(
                    config.gunPosition.x, 
                    config.gunPosition.y, 
                    config.gunPosition.z
                );
                gunGroup.scale.set(
                    config.gunScale, 
                    config.gunScale, 
                    config.gunScale
                );
                
                gun = gunGroup;
                camera.add(gun);
                scene.add(camera);
                console.log('Примитивное оружие добавлено к камере');
            }

            function init() {
                createScene();
                setupCamera();
                setupRenderer();
                createLighting();
                createGround();
                setupControls();
                setupEventListeners();
                
                damageOverlay = document.getElementById('damage-overlay');
                
                resetLoadingState();
                isRestarting = false;
                
                loadModels();
                animate();
            }

            function animate() {
                requestAnimationFrame(animate);
                
                if (isGameStarted) {
                    updatePlayerPosition();
                    updateShadowCamera();
                    
                    const currentTime = Date.now();
                    if (currentTime - lastSpawnTime > config.spawnInterval) {
                        if (bombers.length < config.bomberCount) spawnBomberWave();
                        
                        if (kamikazes.length < config.kamikazeSettings.maxActive && 
                            currentTime - lastKamikazeGroupTime > config.kamikazeSettings.waveCooldown) {
                            spawnKamikazeWave();
                        }
                        
                        lastSpawnTime = currentTime;
                    }
                    
                    for (let i = bombers.length - 1; i >= 0; i--) {
                        const bomber = bombers[i];
                        
                        const distanceToPlayer = bomber.position.distanceTo(playerPosition);
                        const scaleProgress = Math.min(1, distanceToPlayer / config.fadeInDistance);
                        const currentScale = config.targetSettings.baseScale * 
                            config.targetSettings.modelScale.bomber *
                            (1 + (config.targetSettings.fadeScaleMultiplier - 1) * scaleProgress);
                        
                        if (bomber.children && bomber.children[0]) {
                            bomber.children[0].scale.set(currentScale, currentScale, currentScale);
                        } else {
                            bomber.scale.set(currentScale, currentScale, currentScale);
                        }
                        
                        bomber.position.z += bomber.userData.speed;
                        
                        if (bomber.userData.waveMotion) {
                            bomber.position.y = bomber.userData.initialHeight + 
                                            Math.sin(bomber.position.z * config.waveFrequency + 
                                            bomber.userData.waveOffset) * config.waveAmplitude;
                        }
                        
                        dropGrenade(bomber, currentTime);
                        
                        if (bomber.userData.fadingIn && distanceToPlayer < config.spawnDistance) {
                            const fadeProgress = 1 - (distanceToPlayer / config.spawnDistance);
                            bomber.traverse(child => {
                                if (child.isMesh) {
                                    child.material.opacity = fadeProgress;
                                }
                            });
                            if (fadeProgress >= 1) {
                                bomber.userData.fadingIn = false;
                            }
                        }
                        
                        const distanceBehind = bomber.position.z - playerPosition.z;
                        if (distanceBehind > 0) {
                            const fadeProgress = 1 - Math.min(1, 
                                (distanceBehind - config.fadeOutDistance) / 
                                (config.despawnDistance - config.fadeOutDistance)
                            );
                            
                            bomber.traverse(child => {
                                if (child.isMesh) {
                                    child.material.opacity = Math.max(0, fadeProgress);
                                }
                            });
                            
                            if (distanceBehind > config.despawnDistance) {
                                if (DEBUG_MODE && bomber.userData.debugHelper) {
                                    scene.remove(bomber.userData.debugHelper);
                                }
                                scene.remove(bomber);
                                bombers.splice(i, 1);
                                continue;
                            }
                        }
                    }
                    
                    for (let i = kamikazes.length - 1; i >= 0; i--) {
                        const kamikaze = kamikazes[i];
                        
                        const distanceToPlayer = kamikaze.position.distanceTo(playerPosition);
                        const scaleProgress = Math.min(1, distanceToPlayer / config.fadeInDistance);
                        const currentScale = config.targetSettings.baseScale * 
                            config.targetSettings.modelScale.kamikaze *
                            (1 + (config.targetSettings.fadeScaleMultiplier - 1) * scaleProgress);
                        
                        if (kamikaze.children && kamikaze.children[0]) {
                            kamikaze.children[0].scale.set(currentScale, currentScale, currentScale);
                        } else {
                            kamikaze.scale.set(currentScale, currentScale, currentScale);
                        }
                        
                        if (kamikazeAttack(kamikaze)) {
                            continue;
                        }
                        
                        if (kamikaze.userData.fadingIn && distanceToPlayer < config.spawnDistance) {
                            const fadeProgress = 1 - (distanceToPlayer / config.spawnDistance);
                            kamikaze.traverse(child => {
                                if (child.isMesh) {
                                    child.material.opacity = fadeProgress;
                                }
                            });
                            if (fadeProgress >= 1) {
                                kamikaze.userData.fadingIn = false;
                            }
                        }
                        
                        const distanceBehind = kamikaze.position.z - playerPosition.z;
                        if (distanceBehind > 0) {
                            const fadeProgress = 1 - Math.min(1, 
                                (distanceBehind - config.fadeOutDistance) / 
                                (config.despawnDistance - config.fadeOutDistance)
                            );
                            
                            kamikaze.traverse(child => {
                                if (child.isMesh) {
                                    child.material.opacity = Math.max(0, fadeProgress);
                                }
                            });
                            
                            if (distanceBehind > config.despawnDistance) {
                                if (DEBUG_MODE && kamikaze.userData.debugHelper) {
                                    scene.remove(kamikaze.userData.debugHelper);
                                }
                                scene.remove(kamikaze);
                                kamikazes.splice(i, 1);
                                continue;
                            }
                        }
                    }
                    
                    checkGrenadeCollisions();
                }

                renderer.render(scene, camera);
            }

            return { init };
        })();

        window.onload = DronoBoy.init;
    </script>
</body>
</html>